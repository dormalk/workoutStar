// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __assign, __awaiter, __extends, __generator } from "tslib";
import { isTokenCredential, isNode, getDefaultProxySettings } from "@azure/core-http";
import { CanonicalCode } from "@azure/core-tracing";
import { Messages, MessageId, Queue } from "./generated/src/operations";
import { newPipeline, Pipeline } from "./Pipeline";
import { StorageClient } from "./StorageClient";
import { appendToURLPath, extractConnectionStringParts, truncatedISO8061Date, getValueInConnString, getStorageClientContext } from "./utils/utils.common";
import { StorageSharedKeyCredential } from "./credentials/StorageSharedKeyCredential";
import { AnonymousCredential } from "./credentials/AnonymousCredential";
import { createSpan } from "./utils/tracing";
import { DevelopmentConnectionString } from "./utils/constants";
/**
 * A QueueClient represents a URL to an Azure Storage Queue's messages allowing you to manipulate its messages.
 *
 * @export
 * @class QueueClient
 */
var QueueClient = /** @class */ (function (_super) {
    __extends(QueueClient, _super);
    function QueueClient(urlOrConnectionString, credentialOrPipelineOrQueueName, options) {
        var _this = this;
        options = options || {};
        var pipeline;
        var url;
        if (credentialOrPipelineOrQueueName instanceof Pipeline) {
            // (url: string, pipeline: Pipeline)
            url = urlOrConnectionString;
            pipeline = credentialOrPipelineOrQueueName;
        }
        else if ((isNode && credentialOrPipelineOrQueueName instanceof StorageSharedKeyCredential) ||
            credentialOrPipelineOrQueueName instanceof AnonymousCredential ||
            isTokenCredential(credentialOrPipelineOrQueueName)) {
            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)
            url = urlOrConnectionString;
            pipeline = newPipeline(credentialOrPipelineOrQueueName, options);
        }
        else if (!credentialOrPipelineOrQueueName &&
            typeof credentialOrPipelineOrQueueName !== "string") {
            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)
            // The second paramter is undefined. Use anonymous credential.
            url = urlOrConnectionString;
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        else if (credentialOrPipelineOrQueueName &&
            typeof credentialOrPipelineOrQueueName === "string") {
            // (connectionString: string, containerName: string, queueName: string, options?: StoragePipelineOptions)
            var extractedCreds = extractConnectionStringParts(urlOrConnectionString);
            if (extractedCreds.kind === "AccountConnString") {
                if (isNode) {
                    var queueName = credentialOrPipelineOrQueueName;
                    var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                    url = appendToURLPath(extractedCreds.url, queueName);
                    options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);
                    pipeline = newPipeline(sharedKeyCredential, options);
                }
                else {
                    throw new Error("Account connection string is only supported in Node.js environment");
                }
            }
            else if (extractedCreds.kind === "SASConnString") {
                var queueName = credentialOrPipelineOrQueueName;
                url = appendToURLPath(extractedCreds.url, queueName) + "?" + extractedCreds.accountSas;
                pipeline = newPipeline(new AnonymousCredential(), options);
            }
            else {
                throw new Error("Connection string must be either an Account connection string or a SAS connection string");
            }
        }
        else {
            throw new Error("Expecting non-empty strings for queueName parameter");
        }
        _this = _super.call(this, url, pipeline) || this;
        _this._name = _this.getQueueNameFromUrl();
        _this.queueContext = new Queue(_this.storageClientContext);
        // MessagesContext
        // Build the url with "messages"
        var partsOfUrl = _this.url.split("?");
        _this._messagesUrl = partsOfUrl[1]
            ? appendToURLPath(partsOfUrl[0], "messages") + "?" + partsOfUrl[1]
            : appendToURLPath(partsOfUrl[0], "messages");
        _this.messagesContext = new Messages(getStorageClientContext(_this._messagesUrl, _this.pipeline));
        return _this;
    }
    Object.defineProperty(QueueClient.prototype, "name", {
        /**
         * The name of the queue.
         */
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    QueueClient.prototype.getMessageIdContext = function (messageId) {
        // Build the url with messageId
        var partsOfUrl = this._messagesUrl.split("?");
        var urlWithMessageId = partsOfUrl[1]
            ? appendToURLPath(partsOfUrl[0], messageId) + "?" + partsOfUrl[1]
            : appendToURLPath(partsOfUrl[0], messageId);
        return new MessageId(getStorageClientContext(urlWithMessageId, this.pipeline));
    };
    /**
     * Creates a new queue under the specified account.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-queue4
     *
     * @param {QueueCreateOptions} [options] Options to Queue create operation.
     * @returns {Promise<QueueCreateResponse>} Response data for the Queue create operation.
     * @memberof QueueClient
     *
     * @example
     * ```js
     * const queueClient = queueServiceClient.getQueueClient("<new queue name>");
     * const createQueueResponse = await queueClient.create();
     * ```
     */
    QueueClient.prototype.create = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("QueueClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.queueContext.create(__assign(__assign({}, options), { abortSignal: options.abortSignal, spanOptions: spanOptions }))];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Deletes the specified queue permanently.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-queue3
     *
     * @param {QueueDeleteOptions} [options] Options to Queue delete operation.
     * @returns {Promise<QueueDeleteResponse>} Response data for the Queue delete operation.
     * @memberof QueueClient
     *
     * @example
     * ```js
     * const deleteQueueResponse = await queueClient.delete();
     * console.log(
     *   "Delete queue successfully, service assigned request Id:", deleteQueueResponse.requestId
     * );
     * ```
     */
    QueueClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("QueueClient-delete", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.queueContext.deleteMethod({
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Gets all user-defined metadata and system properties for the specified
     * queue. Metadata is associated with the queue as name-values pairs.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-queue-metadata
     *
     * @param {QueueGetPropertiesOptions} [options] Options to Queue get properties operation.
     * @returns {Promise<QueueGetPropertiesResponse>} Response data for the Queue get properties operation.
     * @memberof QueueClient
     */
    QueueClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("QueueClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.queueContext.getProperties({
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Sets one or more user-defined name-value pairs for the specified queue.
     *
     * If no option provided, or no metadata defined in the option parameter, the queue
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-queue-metadata
     *
     * @param {Metadata} [metadata] If no metadata provided, all existing metadata will be removed.
     * @param {QueueSetMetadataOptions} [options] Options to Queue set metadata operation.
     * @returns {Promise<QueueSetMetadataResponse>} Response data for the Queue set metadata operation.
     * @memberof QueueClient
     */
    QueueClient.prototype.setMetadata = function (metadata, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("QueueClient-setMetadata", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.queueContext.setMetadata({
                            abortSignal: options.abortSignal,
                            metadata: metadata,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Gets details about any stored access policies specified on the queue that may be used with Shared Access Signatures.
     *
     * WARNING: JavaScript Date will potential lost precision when parsing start and expiry string.
     * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-queue-acl
     *
     * @param {QueueGetAccessPolicyOptions} [options] Options to Queue get access policy operation.
     * @returns {Promise<QueueGetAccessPolicyResponse>} Response data for the Queue get access policy operation.
     * @memberof QueueClient
     */
    QueueClient.prototype.getAccessPolicy = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, res, _i, response_1, identifier, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueClient-getAccessPolicy", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.queueContext.getAccessPolicy({
                                abortSignal: options.abortSignal,
                                spanOptions: spanOptions
                            })];
                    case 2:
                        response = _b.sent();
                        res = {
                            _response: response._response,
                            date: response.date,
                            requestId: response.requestId,
                            clientRequestId: response.clientRequestId,
                            signedIdentifiers: [],
                            version: response.version,
                            errorCode: response.errorCode
                        };
                        for (_i = 0, response_1 = response; _i < response_1.length; _i++) {
                            identifier = response_1[_i];
                            res.signedIdentifiers.push({
                                accessPolicy: {
                                    expiresOn: new Date(identifier.accessPolicy.expiresOn),
                                    permissions: identifier.accessPolicy.permissions,
                                    startsOn: new Date(identifier.accessPolicy.startsOn)
                                },
                                id: identifier.id
                            });
                        }
                        return [2 /*return*/, res];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets stored access policies for the queue that may be used with Shared Access Signatures.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-queue-acl
     *
     * @param {SignedIdentifier[]} [queueAcl]
     * @param {QueueSetAccessPolicyOptions} [options] Options to Queue set access policy operation.
     * @returns {Promise<QueueSetAccessPolicyResponse>} Response data for the Queue set access policy operation.
     * @memberof QueueClient
     */
    QueueClient.prototype.setAccessPolicy = function (queueAcl, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, acl, _i, _b, identifier;
            return __generator(this, function (_c) {
                _a = createSpan("QueueClient-setAccessPolicy", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    acl = [];
                    for (_i = 0, _b = queueAcl || []; _i < _b.length; _i++) {
                        identifier = _b[_i];
                        acl.push({
                            accessPolicy: {
                                expiresOn: truncatedISO8061Date(identifier.accessPolicy.expiresOn),
                                permissions: identifier.accessPolicy.permissions,
                                startsOn: truncatedISO8061Date(identifier.accessPolicy.startsOn)
                            },
                            id: identifier.id
                        });
                    }
                    return [2 /*return*/, this.queueContext.setAccessPolicy({
                            abortSignal: options.abortSignal,
                            queueAcl: acl,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Clear deletes all messages from a queue.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/clear-messages
     *
     * @param {QueueClearMessagesOptions} [options] Options to clear messages operation.
     * @returns {Promise<QueueClearMessagesResponse>} Response data for the clear messages operation.
     * @memberof QueueClient
     */
    QueueClient.prototype.clearMessages = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("QueueClient-clearMessages", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.messagesContext.clear({
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * sendMessage adds a new message to the back of a queue. The visibility timeout specifies how long
     * the message should be invisible to Dequeue and Peek operations.
     * The message content is up to 64KB in size, and must be in a format that can be included in an XML request with UTF-8 encoding.
     * To include markup in the message, the contents of the message must either be XML-escaped or Base64-encode.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-message
     *
     * @param {string} messageText Text of the message to send
     * @param {QueueSendMessageOptions} [options] Options to send messages operation.
     * @returns {Promise<QueueSendMessageResponse>} Response data for the send messages operation.
     * @memberof QueueClient
     *
     * @example
     * ```js
     * const sendMessageResponse = await queueClient.sendMessage("Hello World!");
     * console.log(
     *   "Sent message successfully, service assigned message Id:", sendMessageResponse.messageId,
     *   "service assigned request Id:", sendMessageResponse.requestId
     * );
     * ```
     */
    QueueClient.prototype.sendMessage = function (messageText, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, item, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueClient-sendMessage", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.messagesContext.enqueue({
                                messageText: messageText
                            }, __assign(__assign({ abortSignal: options.abortSignal }, options), { spanOptions: spanOptions }))];
                    case 2:
                        response = _b.sent();
                        item = response[0];
                        return [2 /*return*/, {
                                _response: response._response,
                                date: response.date,
                                requestId: response.requestId,
                                clientRequestId: response.clientRequestId,
                                version: response.version,
                                errorCode: response.errorCode,
                                messageId: item.messageId,
                                popReceipt: item.popReceipt,
                                nextVisibleOn: item.nextVisibleOn,
                                insertedOn: item.insertedOn,
                                expiresOn: item.expiresOn
                            }];
                    case 3:
                        e_2 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * receiveMessages retrieves one or more messages from the front of the queue.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-messages
     *
     * @param {QueueReceiveMessageOptions} [options] Options to receive messages operation.
     * @returns {Promise<QueueReceiveMessageResponse>} Response data for the receive messages operation.
     * @memberof QueueClient
     *
     * @example
     * ```js
     * const response = await queueClient.receiveMessages();
     * if (response.receivedMessageItems.length == 1) {
     *   const receivedMessageItem = response.receivedMessageItems[0];
     *   console.log("Processing & deleting message with content:", receivedMessageItem.messageText);
     *   const deleteMessageResponse = await queueClient.deleteMessage(
     *     receivedMessageItem.messageId,
     *     receivedMessageItem.popReceipt
     *   );
     *   console.log(
     *     "Delete message succesfully, service assigned request Id:",
     *     deleteMessageResponse.requestId
     *   );
     * }
     * ```
     */
    QueueClient.prototype.receiveMessages = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, res, _i, response_2, item, e_3;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueClient-receiveMessages", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.messagesContext.dequeue(__assign(__assign({ abortSignal: options.abortSignal }, options), { spanOptions: spanOptions }))];
                    case 2:
                        response = _b.sent();
                        res = {
                            _response: response._response,
                            date: response.date,
                            requestId: response.requestId,
                            clientRequestId: response.clientRequestId,
                            receivedMessageItems: [],
                            version: response.version,
                            errorCode: response.errorCode
                        };
                        for (_i = 0, response_2 = response; _i < response_2.length; _i++) {
                            item = response_2[_i];
                            res.receivedMessageItems.push(item);
                        }
                        return [2 /*return*/, res];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * peekMessages retrieves one or more messages from the front of the queue but does not alter the visibility of the message.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/peek-messages
     *
     * @param {QueuePeekMessagesOptions} [options] Options to peek messages operation.
     * @returns {QueuePeekMessagesResponse>} Response data for the peek messages operation.
     * @memberof QueueClient
     *
     * @example
     * ```js
     * const peekMessagesResponse = await queueClient.peekMessages();
     * console.log("The peeked message is:", peekMessagesResponse.peekedMessageItems[0].messageText);
     * ```
     */
    QueueClient.prototype.peekMessages = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, res, _i, response_3, item, e_4;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueClient-peekMessages", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.messagesContext.peek(__assign(__assign({ abortSignal: options.abortSignal }, options), { spanOptions: spanOptions }))];
                    case 2:
                        response = _b.sent();
                        res = {
                            _response: response._response,
                            date: response.date,
                            requestId: response.requestId,
                            clientRequestId: response.clientRequestId,
                            peekedMessageItems: [],
                            version: response.version,
                            errorCode: response.errorCode
                        };
                        for (_i = 0, response_3 = response; _i < response_3.length; _i++) {
                            item = response_3[_i];
                            res.peekedMessageItems.push(item);
                        }
                        return [2 /*return*/, res];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * deleteMessage permanently removes the specified message from its queue.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-message2
     *
     * @param {string} messageId Id of the message.
     * @param {string} popReceipt A valid pop receipt value returned from an earlier call to the receive messages or update message operation.
     * @param {QueueDeleteMessageOptions} [options] Options to delete message operation.
     * @returns {Promise<QueueDeleteMessageResponse>} Response data for the delete message operation.
     * @memberof QueueClient
     */
    QueueClient.prototype.deleteMessage = function (messageId, popReceipt, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("QueueClient-deleteMessage", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.getMessageIdContext(messageId).deleteMethod(popReceipt, {
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Update changes a message's visibility timeout and contents.
     * The message content is up to 64KB in size, and must be in a format that can be included in an XML request with UTF-8 encoding.
     * To include markup in the message, the contents of the message must either be XML-escaped or Base64-encode.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/update-message
     *
     * @param {string} messageId Id of the message
     * @param {string} popReceipt A valid pop receipt value returned from an earlier call to the receive messages or update message operation.
     * @param {string} message Message to update.
     * @param {number} visibilityTimeout Specifies the new visibility timeout value, in seconds,
     *                                   relative to server time. The new value must be larger than or equal to 0,
     *                                   and cannot be larger than 7 days. The visibility timeout of a message cannot
     *                                   be set to a value later than the expiry time.
     *                                   A message can be updated until it has been deleted or has expired.
     * @param {QueueUpdateMessageOptions} [options] Options to update message operation.
     * @returns {Promise<QueueUpdateMessageResponse>} Response data for the update message operation.
     * @memberof QueueClient
     */
    QueueClient.prototype.updateMessage = function (messageId, popReceipt, message, visibilityTimeout, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("QueueClient-updateMessage", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.getMessageIdContext(messageId).update({
                            messageText: message
                        }, popReceipt, visibilityTimeout || 0, {
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    QueueClient.prototype.getQueueNameFromUrl = function () {
        var queueName;
        try {
            //  URL may look like the following
            // "https://myaccount.queue.core.windows.net/myqueue?sasString".
            // "https://myaccount.queue.core.windows.net/myqueue".
            // or an emulator URL that starts with the endpoint `http://127.0.0.1:10001/devstoreaccount1`
            var urlWithoutSAS = this.url.split("?")[0]; // removing the sas part of url if present
            urlWithoutSAS = urlWithoutSAS.endsWith("/") ? urlWithoutSAS.slice(0, -1) : urlWithoutSAS; // Slicing off '/' at the end if exists
            // http://127.0.0.1:10001/devstoreaccount1
            var emulatorQueueEndpoint = getValueInConnString(DevelopmentConnectionString, "QueueEndpoint");
            if (this.url.startsWith(emulatorQueueEndpoint)) {
                // Emulator URL starts with `http://127.0.0.1:10001/devstoreaccount1`
                queueName = urlWithoutSAS.match(emulatorQueueEndpoint + "/([^/]*)")[1];
            }
            else {
                queueName = urlWithoutSAS.match("([^/]*)://([^/]*)/([^/]*)")[3];
            }
            if (!queueName) {
                throw new Error("Provided queueName is invalid.");
            }
            else {
                return queueName;
            }
        }
        catch (error) {
            throw new Error("Unable to extract queueName with provided information.");
        }
    };
    return QueueClient;
}(StorageClient));
export { QueueClient };
//# sourceMappingURL=QueueClient.js.map