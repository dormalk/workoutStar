// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import * as tslib_1 from "tslib";
import * as log from "./log";
import { CloseReason } from "./eventProcessor";
import { AbortController } from "@azure/abort-controller";
export class PartitionPump {
    constructor(eventHubClient, partitionProcessor, initialEventPosition, options) {
        this._isReceiving = false;
        if (!options)
            options = {};
        this._eventHubClient = eventHubClient;
        this._partitionProcessor = partitionProcessor;
        this._initialEventPosition = initialEventPosition;
        this._processorOptions = options;
        this._abortController = new AbortController();
    }
    get isReceiving() {
        return this._isReceiving;
    }
    start() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._isReceiving = true;
            try {
                yield this._partitionProcessor.initialize();
            }
            catch (_a) {
                // swallow the error from the user-defined code
            }
            this._receiveEvents(this._partitionProcessor.partitionId);
            log.partitionPump("Successfully started the receiver.");
        });
    }
    _receiveEvents(partitionId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._receiver = this._eventHubClient.createConsumer(this._partitionProcessor.consumerGroupName, partitionId, this._initialEventPosition, {
                ownerLevel: 0,
                trackLastEnqueuedEventInfo: this._processorOptions.trackLastEnqueuedEventInfo
            });
            while (this._isReceiving) {
                try {
                    const receivedEvents = yield this._receiver.receiveBatch(this._processorOptions.maxBatchSize || 1, this._processorOptions.maxWaitTimeInSeconds, this._abortController.signal);
                    if (this._processorOptions.trackLastEnqueuedEventInfo &&
                        this._receiver.lastEnqueuedEventInfo) {
                        this._partitionProcessor.lastEnqueuedEventInfo = this._receiver.lastEnqueuedEventInfo;
                    }
                    // avoid calling user's processEvents handler if the pump was stopped while receiving events
                    if (!this._isReceiving) {
                        return;
                    }
                    yield this._partitionProcessor.processEvents(receivedEvents);
                }
                catch (err) {
                    // check if this pump is still receiving
                    // it may not be if the EventProcessor was stopped during processEvents
                    if (!this._isReceiving) {
                        // no longer receiving, so close was called from somewhere else
                        return;
                    }
                    // forward error to user's processError and swallow errors they may throw
                    try {
                        yield this._partitionProcessor.processError(err);
                    }
                    catch (err) {
                        log.error("An error was thrown by user's processError method: ", err);
                    }
                    // close the partition processor if a non-retryable error was encountered
                    if (typeof err !== "object" || !err.retryable) {
                        try {
                            // If the exception indicates that the partition was stolen (i.e some other consumer with same ownerlevel
                            // started consuming the partition), update the closeReason
                            if (err.name === "ReceiverDisconnectedError") {
                                return yield this.stop(CloseReason.OwnershipLost);
                            }
                            // this will close the pump and will break us out of the while loop
                            return yield this.stop(CloseReason.Shutdown);
                        }
                        catch (err) {
                            log.error(`An error occurred while closing the receiver with reason ${CloseReason.Shutdown}: `, err);
                        }
                    }
                }
            }
        });
    }
    stop(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._isReceiving = false;
            try {
                if (this._receiver) {
                    yield this._receiver.close();
                }
                this._abortController.abort();
                yield this._partitionProcessor.close(reason);
            }
            catch (err) {
                log.error("An error occurred while closing the receiver.", err);
                throw err;
            }
        });
    }
}
//# sourceMappingURL=partitionPump.js.map