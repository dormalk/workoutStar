import * as tslib_1 from "tslib";
/**
 * The `PartitionProcessor` is responsible for processing events received from Event Hubs when using `EventProcessor`
 *
 * The EventProcessor creates a new instance of the PartitionProcessor for each partition of the event hub it starts processing. When you extend the `PartitionProcessor` in order to customize it as you see fit,
 * - Override the `processEvents()` method to add the code to process the received events. This is also a good place to update the checkpoints using the `updateCheckpoint()` method
 * - Optionally override the `processError()` method to handle any error that might have occurred when processing the events.
 * - Optionally override the `initialize()` method to implement any set up related tasks you would want to carry out before starting to receive events from the partition
 * - Optionally override the `close()` method to implement any tear down or clean up tasks you would want to carry out.
 */
export class PartitionProcessor {
    constructor() {
        this._eTag = "";
    }
    /**
     * @property Information on the last enqueued event in the partition that is being processed.
     * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventInfo` option is set to true
     * when creating an instance of EventProcessor
     * @readonly
     */
    get lastEnqueuedEventInfo() {
        return this._lastEnqueuedEventInfo;
    }
    /**
     * @property Information on the last enqueued event in the partition that is being processed.
     * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventInfo` option is set to true
     * when creating an instance of EventProcessor
     */
    set lastEnqueuedEventInfo(lastEnqueuedEventInfo) {
        this._lastEnqueuedEventInfo = lastEnqueuedEventInfo;
    }
    /**
     * @property The fully qualified namespace from where the current partition is being processed. It is set by the `EventProcessor`
     * @readonly
     */
    get fullyQualifiedNamespace() {
        return this._fullyQualifiedNamespace;
    }
    /**
     * @property The fully qualified namespace from where the current partition is being processed. It is set by the `EventProcessor`
     */
    set fullyQualifiedNamespace(fullyQualifiedNamespace) {
        if (!this._fullyQualifiedNamespace) {
            this._fullyQualifiedNamespace = fullyQualifiedNamespace;
        }
    }
    /**
     * @property The name of the consumer group from where the current partition is being processed. It is set by the `EventProcessor`
     * @readonly
     */
    get consumerGroupName() {
        return this._consumerGroupName;
    }
    /**
     * @property The name of the consumer group from where the current partition is being processed. It is set by the `EventProcessor`
     */
    set consumerGroupName(consumerGroupName) {
        if (!this._consumerGroupName) {
            this._consumerGroupName = consumerGroupName;
        }
    }
    /**
     * @property The name of the event hub to which the current partition belongs. It is set by the `EventProcessor`
     * @readonly
     */
    get eventHubName() {
        return this._eventHubName;
    }
    /**
     * @property The name of the event hub to which the current partition belongs. It is set by the `EventProcessor`
     */
    set eventHubName(eventHubName) {
        if (!this._eventHubName) {
            this._eventHubName = eventHubName;
        }
    }
    /**
     * @property The identifier of the Event Hub partition that is being processed. It is set by the `EventProcessor`
     * @readonly
     */
    get partitionId() {
        return this._partitionId;
    }
    /**
     * @property The identifier of the Event Hub partition that is being processed. It is set by the `EventProcessor`
     */
    set partitionId(partitionId) {
        if (!this._partitionId) {
            this._partitionId = partitionId;
        }
    }
    /**
     * @property The unique identifier of the `EventProcessor` that has spawned the current instance of `PartitionProcessor`. This is set by the `EventProcessor`
     */
    set eventProcessorId(eventProcessorId) {
        if (!this._eventProcessorId) {
            this._eventProcessorId = eventProcessorId;
        }
    }
    /**
     * @property The Partition Manager used for checkpointing events. This is set by the `EventProcessor`
     */
    set partitionManager(partitionManager) {
        if (!this._partitionManager) {
            this._partitionManager = partitionManager;
        }
    }
    /**
     * This method is called when the `EventProcessor` takes ownership of a new partition and before any
     * events are received.
     *
     * @return {Promise<void>}
     */
    initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { });
    }
    /**
     * This method is called before the partition processor is closed by the EventProcessor.
     *
     * @param reason The reason for closing this partition processor.
     * @return {Promise<void>}
     */
    close(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { });
    }
    /**
     * This method is called when new events are received.
     *
     * This is also a good place to update checkpoints as appropriate.
     *
     * @param events The received events to be processed.
     * @return {Promise<void>}
     */
    processEvents(events) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { });
    }
    /**
     * This method is called when an error occurs while receiving events from Event Hubs.
     *
     * @param error The error to be processed.
     * @return {Promise<void>}
     */
    processError(error) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { });
    }
    updateCheckpoint(eventDataOrSequenceNumber, offset) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const checkpoint = {
                fullyQualifiedNamespace: this._fullyQualifiedNamespace,
                eventHubName: this._eventHubName,
                consumerGroupName: this._consumerGroupName,
                ownerId: this._eventProcessorId,
                partitionId: this._partitionId,
                sequenceNumber: typeof eventDataOrSequenceNumber === "number"
                    ? eventDataOrSequenceNumber
                    : eventDataOrSequenceNumber.sequenceNumber,
                offset: typeof offset === "number"
                    ? offset
                    : eventDataOrSequenceNumber.offset,
                eTag: this._eTag
            };
            this._eTag = yield this._partitionManager.updateCheckpoint(checkpoint);
        });
    }
}
//# sourceMappingURL=partitionProcessor.js.map