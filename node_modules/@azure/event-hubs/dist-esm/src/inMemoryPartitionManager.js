// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import * as tslib_1 from "tslib";
import { generate_uuid } from "rhea-promise";
/**
 * The `EventProcessor` relies on a `PartitionManager` to store checkpoints and handle partition
 * ownerships. `InMemoryPartitionManager` is simple partition manager that stores checkpoints and
 * partition ownerships in memory of your program.
 *
 * You can use the `InMemoryPartitionManager` to get started with using the `EventProcessor`.
 * But in production, you should choose an implementation of the `PartitionManager` interface that will
 * store the checkpoints and partition ownerships to a durable store instead.
 *
 * @class
 */
export class InMemoryPartitionManager {
    constructor() {
        this._partitionOwnershipMap = new Map();
    }
    /**
     * Get the list of all existing partition ownership from the underlying data store. Could return empty
     * results if there are is no existing ownership information.
     *
     * @param fullyQualifiedNamespace The fully qualified Event Hubs namespace. This is likely to be similar to
     * <yournamespace>.servicebus.windows.net.
     * @param eventHubName The event hub name.
     * @param consumerGroupName The consumer group name.
     * @return Partition ownership details of all the partitions that have/had an owner..
     */
    listOwnership(fullyQualifiedNamespace, eventHubName, consumerGroupName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return Array.from(this._partitionOwnershipMap.values());
        });
    }
    /**
     * Claim ownership of a list of partitions. This will return the list of partitions that were owned
     * successfully.
     *
     * @param partitionOwnership The list of partition ownership this instance is claiming to own.
     * @return A list partitions this instance successfully claimed ownership.
     */
    claimOwnership(partitionOwnership) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            for (const ownership of partitionOwnership) {
                if (!this._partitionOwnershipMap.has(ownership.partitionId) ||
                    this._partitionOwnershipMap.get(ownership.partitionId).eTag === ownership.eTag) {
                    ownership.eTag = generate_uuid();
                    var date = new Date();
                    ownership.lastModifiedTimeInMS = date.getTime();
                    this._partitionOwnershipMap.set(ownership.partitionId, ownership);
                }
            }
            return partitionOwnership;
        });
    }
    /**
     * Updates the checkpoint in the data store for a partition.
     *
     * @param checkpoint The checkpoint.
     * @return The new eTag on successful update
     */
    updateCheckpoint(checkpoint) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const partitionOwnership = this._partitionOwnershipMap.get(checkpoint.partitionId);
            if (partitionOwnership) {
                partitionOwnership.sequenceNumber = checkpoint.sequenceNumber;
                partitionOwnership.offset = checkpoint.offset;
                partitionOwnership.eTag = generate_uuid();
                return partitionOwnership.eTag;
            }
            return "";
        });
    }
}
//# sourceMappingURL=inMemoryPartitionManager.js.map