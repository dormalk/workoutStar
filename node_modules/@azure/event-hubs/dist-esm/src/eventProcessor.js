// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import * as tslib_1 from "tslib";
import uuid from "uuid/v4";
import { EventPosition } from "./eventPosition";
import { PumpManager } from "./pumpManager";
import { AbortController } from "@azure/abort-controller";
import * as log from "./log";
import { PartitionLoadBalancer } from "./partitionLoadBalancer";
import { delay } from "@azure/core-amqp";
/**
 * An enum representing the different reasons for an `EventProcessor` to stop processing
 * events from a partition in a consumer group of an Event Hub instance.
 */
export var CloseReason;
(function (CloseReason) {
    /**
     * Ownership of the partition was lost or transitioned to a new processor instance.
     */
    CloseReason["OwnershipLost"] = "OwnershipLost";
    /**
     * The EventProcessor was shutdown.
     */
    CloseReason["Shutdown"] = "Shutdown";
})(CloseReason || (CloseReason = {}));
/**
 * Event Processor based applications consist of one or more instances of EventProcessor which have been
 * configured to consume events from the same Event Hub and consumer group. They balance the
 * workload across different instances by distributing the partitions to be processed among themselves.
 * They also allow the user to track progress when events are processed using checkpoints.
 *
 * A checkpoint is meant to represent the last successfully processed event by the user from a particular
 * partition of a consumer group in an Event Hub instance.
 *
 * You need the below to create an instance of `EventProcessor`
 * - The name of the consumer group from which you want to process events
 * - An instance of `EventHubClient` class that was created for the Event Hub instance.
 * - A user implemented class that extends the `PartitionProcessor` class. To get started, you can use the
 * base class `PartitionProcessor` which simply logs the incoming events. To provide your code to process incoming
 * events, extend this class and override the `processEvents()` method. For example:
 * ```js
 * class SamplePartitionProcessor extends PartitionProcessor {
 *     async processEvents(events) {
 *        // user code to process events here
 *        // Information on the partition being processed is available as properties on the `SamplePartitionProcessor` class
 *        // use `this.updateCheckpoint()` method to update checkpoints as needed
 *     }
 * }
 * ```
 * - An instance of `PartitionManager`. To get started, you can pass an instance of `InMemoryPartitionManager`.
 * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.
 * Implementations of `PartitionManager` can be found on npm by searching for packages with the prefix &commat;azure/eventhub-checkpointstore-.
 *
 * @class EventProcessor
 */
export class EventProcessor {
    /**
     * @param consumerGroupName The name of the consumer group from which you want to process events.
     * @param eventHubClient An instance of `EventHubClient` that was created for the Event Hub instance.
     * @param PartitionProcessorClass A user-provided class that extends the `PartitionProcessor` class.
     * This class will be responsible for processing and checkpointing events.
     * @param partitionManager An instance of `PartitionManager`. To get started, you can pass an instance of `InMemoryPartitionManager`.
     * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.
     * @param options A set of options to configure the Event Processor
     * - `maxBatchSize`         : The max size of the batch of events passed each time to user code for processing.
     * - `maxWaitTimeInSeconds` : The maximum amount of time to wait to build up the requested message count before
     * passing the data to user code for processing. If not provided, it defaults to 60 seconds.
     */
    constructor(consumerGroupName, eventHubClient, PartitionProcessorClass, partitionManager, options) {
        this._id = uuid();
        this._isRunning = false;
        if (!options)
            options = {};
        this._consumerGroupName = consumerGroupName;
        this._eventHubClient = eventHubClient;
        this._partitionProcessorClass = PartitionProcessorClass;
        this._partitionManager = partitionManager;
        this._processorOptions = options;
        this._pumpManager = new PumpManager(this._id, this._processorOptions);
        const inactiveTimeLimitInMS = 60000; // ownership expiration time (1 mintue)
        this._partitionLoadBalancer = new PartitionLoadBalancer(this._id, inactiveTimeLimitInMS);
    }
    /**
     * The unique identifier for the EventProcessor.
     *
     * @return {string}
     */
    get id() {
        return this._id;
    }
    _createPartitionOwnershipRequest(partitionOwnershipMap, partitionIdToClaim) {
        const previousPartitionOwnership = partitionOwnershipMap.get(partitionIdToClaim);
        const partitionOwnership = {
            ownerId: this._id,
            partitionId: partitionIdToClaim,
            fullyQualifiedNamespace: this._eventHubClient.fullyQualifiedNamespace,
            consumerGroupName: this._consumerGroupName,
            eventHubName: this._eventHubClient.eventHubName,
            sequenceNumber: previousPartitionOwnership
                ? previousPartitionOwnership.sequenceNumber
                : undefined,
            offset: previousPartitionOwnership ? previousPartitionOwnership.offset : undefined,
            eTag: previousPartitionOwnership ? previousPartitionOwnership.eTag : undefined,
            ownerLevel: 0
        };
        return partitionOwnership;
    }
    /*
     * Claim ownership of the given partition if it's available
     */
    _claimOwnership(partitionOwnershipMap, partitionIdToClaim) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            log.partitionLoadBalancer(`[${this._id}] Attempting to claim ownership of partition ${partitionIdToClaim}.`);
            const ownershipRequest = this._createPartitionOwnershipRequest(partitionOwnershipMap, partitionIdToClaim);
            try {
                yield this._partitionManager.claimOwnership([ownershipRequest]);
                log.partitionLoadBalancer(`[${this._id}] Successfully claimed ownership of partition ${partitionIdToClaim}.`);
                log.partitionLoadBalancer(`[${this._id}] [${partitionIdToClaim}] Calling user-provided PartitionProcessorFactory.`);
                const partitionProcessor = new this._partitionProcessorClass();
                partitionProcessor.fullyQualifiedNamespace = this._eventHubClient.fullyQualifiedNamespace;
                partitionProcessor.eventHubName = this._eventHubClient.eventHubName;
                partitionProcessor.consumerGroupName = this._consumerGroupName;
                partitionProcessor.partitionId = ownershipRequest.partitionId;
                partitionProcessor.partitionManager = this._partitionManager;
                partitionProcessor.eventProcessorId = this.id;
                const eventPosition = ownershipRequest.sequenceNumber
                    ? EventPosition.fromSequenceNumber(ownershipRequest.sequenceNumber)
                    : EventPosition.earliest();
                yield this._pumpManager.createPump(this._eventHubClient, eventPosition, partitionProcessor);
                log.partitionLoadBalancer(`[${this._id}] PartitionPump created successfully.`);
            }
            catch (err) {
                log.error(`[${this.id}] Failed to claim ownership of partition ${ownershipRequest.partitionId}`);
            }
        });
    }
    /**
     * Every loop to this method will result in this EventProcessor owning at most one new partition.
     *
     * The load is considered balanced when no active EventProcessor owns 2 partitions more than any other active
     * EventProcessor. Given that each invocation to this method results in ownership claim of at most one partition,
     * this algorithm converges gradually towards a steady state.
     *
     * When a new partition is claimed, this method is also responsible for starting a partition pump that creates an
     * EventHubConsumer for processing events from that partition.
     */
    _runLoop(abortSignal) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // periodically check if there is any partition not being processed and process it
            const waitIntervalInMs = 10000;
            while (!abortSignal.aborted) {
                try {
                    const partitionOwnershipMap = new Map();
                    // Retrieve current partition ownership details from the datastore.
                    const partitionOwnership = yield this._partitionManager.listOwnership(this._eventHubClient.fullyQualifiedNamespace, this._eventHubClient.eventHubName, this._consumerGroupName);
                    for (const ownership of partitionOwnership) {
                        partitionOwnershipMap.set(ownership.partitionId, ownership);
                    }
                    const partitionIds = yield this._eventHubClient.getPartitionIds();
                    if (abortSignal.aborted) {
                        return;
                    }
                    if (partitionIds.length > 0) {
                        const partitionToClaim = this._partitionLoadBalancer.loadBalance(partitionOwnershipMap, partitionIds);
                        if (partitionToClaim) {
                            yield this._claimOwnership(partitionOwnershipMap, partitionToClaim);
                        }
                    }
                    // sleep
                    log.eventProcessor(`[${this._id}] Pausing the EventProcessor loop for ${waitIntervalInMs} ms.`);
                    yield delay(waitIntervalInMs, abortSignal);
                }
                catch (err) {
                    log.error(`[${this._id}] An error occured within the EventProcessor loop: ${err}`);
                }
            }
        });
    }
    /**
     * Starts the `EventProcessor`. Based on the number of instances of `EventProcessor` that are running for the
     * same consumer group, the partitions are distributed among these instances to process events.
     *
     * For each partition, the user provided `PartitionProcessor` is instantiated.
     *
     * Subsequent calls to start will be ignored if this event processor is already running.
     * Calling `start()` after `stop()` is called will restart this event processor.
     *
     * @return {void}
     */
    start() {
        if (this._isRunning) {
            log.eventProcessor(`[${this._id}] Attempted to start an already running EventProcessor.`);
            return;
        }
        this._isRunning = true;
        this._abortController = new AbortController();
        log.eventProcessor(`[${this._id}] Starting an EventProcessor.`);
        this._loopTask = this._runLoop(this._abortController.signal);
    }
    /**
     * Stops processing events for all partitions owned by this event processor.
     * All `PartitionProcessor` will be shutdown and any open resources will be closed.
     *
     * Subsequent calls to stop will be ignored if the event processor is not running.
     *
     */
    stop() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            log.eventProcessor(`[${this._id}] Stopping an EventProcessor.`);
            if (this._abortController) {
                // cancel the event processor loop
                this._abortController.abort();
            }
            this._isRunning = false;
            try {
                // remove all existing pumps
                yield this._pumpManager.removeAllPumps(CloseReason.Shutdown);
                // waits for the event processor loop to complete
                // will complete immediately if _loopTask is undefined
                yield this._loopTask;
            }
            catch (err) {
                log.error(`[${this._id}] An error occured while stopping the EventProcessor: ${err}`);
            }
            finally {
                log.eventProcessor(`[${this._id}] EventProcessor stopped.`);
            }
        });
    }
}
//# sourceMappingURL=eventProcessor.js.map