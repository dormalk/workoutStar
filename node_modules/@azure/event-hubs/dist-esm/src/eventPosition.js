// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { translate, Constants, ErrorNameConditionMapper } from "@azure/core-amqp";
/**
 * Represents the position of an event in an Event Hub partition, typically used in the creation of
 * an `EventHubConsumer` to specify the position in the partition to begin receiving events from.
 *
 * Make use of the below static helpers to create an instance of `EventPosition`
 * - `fromOffset()`
 * - `fromSequenceNumber()`
 * - `fromEnqueuedTime()`
 * - `earliest()`
 * - `latest()`
 * @class
 */
export class EventPosition {
    /**
     * Instead of constructing an event position using `new Event Position()`, make use of the below static helpers
     * - `fromOffset()`
     * - `fromSequenceNumber()`
     * - `fromEnqueuedTime()`
     * - `earliest()`
     * - `latest()`
     *
     * @constructor
     * @internal
     * @ignore
     * @param options
     */
    constructor(options) {
        /**
         * @property Indicates if the specified offset is inclusive of the event which it identifies.
         * This information is only relevent if the event position was identified by an offset or sequence number.
         * Default value: `false`.
         */
        this.isInclusive = false;
        if (options) {
            this.offset = options.offset;
            this.enqueuedTime = options.enqueuedTime;
            this.sequenceNumber = options.sequenceNumber;
            this.isInclusive = options.isInclusive || false;
        }
    }
    /**
     * Gets an instance of `EventPosition` corresponding to the event in the partition at the provided offset.
     *
     * @param offset The offset of an event with respect to its relative position in the partition.
     * @param isInclusive If true, the specified event is included;
     * otherwise the next event is returned.
     * Default: `false`.
     * @returns EventPosition
     */
    static fromOffset(offset, isInclusive) {
        if (typeof offset !== "number" && typeof offset !== "string") {
            throw new Error(`Invalid offset "${offset}" provided to "fromOffset" method.`);
        }
        return new EventPosition({ offset: offset, isInclusive: isInclusive });
    }
    /**
     * Gets an instance of `EventPosition` corresponding to the event in the partition having a specified sequence number associated with it.
     *
     * @param sequenceNumber The sequence number assigned to an event when it was enqueued in the partition.
     * @param isInclusive If true, event with the `sequenceNumber` is included;
     * otherwise the next event in sequence will be received.
     * Default `false`.
     * @returns EventPosition
     */
    static fromSequenceNumber(sequenceNumber, isInclusive) {
        if (sequenceNumber == undefined) {
            throw new Error('Missing parameter "sequenceNumber"');
        }
        if (typeof sequenceNumber !== "number") {
            throw new Error('The parameter "sequenceNumber" should be of type "number"');
        }
        return new EventPosition({ sequenceNumber: sequenceNumber, isInclusive: isInclusive });
    }
    /**
     * Gets an instance of `EventPosition` corresponding to a specific date and time within the partition to begin seeking an event;
     * the event enqueued after the requested `enqueuedTime` will become the current position.
     *
     * @param enqueuedTime The date and time, in UTC, from which the next available event should be chosen.
     * @returns EventPosition
     */
    static fromEnqueuedTime(enqueuedTime) {
        if (typeof enqueuedTime !== "number" && !(enqueuedTime instanceof Date)) {
            throw new Error(`Invalid enqueuedTime "${enqueuedTime}" provided to "fromEnqueuedTime" method.`);
        }
        return new EventPosition({ enqueuedTime: enqueuedTime });
    }
    /**
     * Gets an instance of `EventPosition` corresponding to the location of the the first event present in the partition.
     * Use this position to begin receiving from the first event that was enqueued in the partition
     * which has not expired due to the retention policy.
     * @returns EventPosition
     */
    static earliest() {
        return EventPosition.fromOffset(EventPosition.startOfStream);
    }
    /**
     * Gets an instance of `EventPosition` corresponding to the end of the partition, where no more events are currently enqueued.
     * Use this position to begin receiving from the next event to be enqueued in the partion after an ``EventHubConsumer``
     * is created with this position.
     * @returns EventPosition
     */
    static latest() {
        return new EventPosition({ offset: EventPosition.endOfStream });
    }
}
/**
 * @property The token that represents the beginning event in the stream of a partition: `-1`.
 * @static
 * @readonly
 * @ignore
 */
EventPosition.startOfStream = -1;
/**
 * @property The token that represents the last event in the stream of a partition: `"@latest"`.
 * @static
 * @readonly
 * @ignore
 */
EventPosition.endOfStream = "@latest";
/**
 * @internal
 * @ignore
 * Gets the expression to be set as the filter clause when creating the receiver
 * @return {string} filterExpression
 */
export function getEventPositionFilter(eventPosition) {
    let result;
    // order of preference
    if (eventPosition.offset != undefined) {
        result = eventPosition.isInclusive
            ? `${Constants.offsetAnnotation} >= '${eventPosition.offset}'`
            : `${Constants.offsetAnnotation} > '${eventPosition.offset}'`;
    }
    else if (eventPosition.sequenceNumber != undefined) {
        result = eventPosition.isInclusive
            ? `${Constants.sequenceNumberAnnotation} >= '${eventPosition.sequenceNumber}'`
            : `${Constants.sequenceNumberAnnotation} > '${eventPosition.sequenceNumber}'`;
    }
    else if (eventPosition.enqueuedTime != undefined) {
        const time = eventPosition.enqueuedTime instanceof Date
            ? eventPosition.enqueuedTime.getTime()
            : eventPosition.enqueuedTime;
        result = `${Constants.enqueuedTimeAnnotation} > '${time}'`;
    }
    if (!result) {
        throw translate({
            condition: ErrorNameConditionMapper.ArgumentError,
            description: "No starting position was set in the EventPosition."
        });
    }
    return result;
}
//# sourceMappingURL=eventPosition.js.map