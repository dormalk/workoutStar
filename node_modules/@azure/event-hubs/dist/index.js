'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib_1 = require('tslib');
var debugModule = _interopDefault(require('debug'));
var coreAmqp = require('@azure/core-amqp');
var os = require('os');
var crypto = _interopDefault(require('crypto'));
var rheaPromise = require('rhea-promise');
var abortController = require('@azure/abort-controller');
var coreTracing = require('@azure/core-tracing');
require('@azure/core-asynciterator-polyfill');

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @ignore
 * log statements for error
 */
const error = debugModule("azure:event-hubs:error");
/**
 * @ignore
 * log statements for management
 */
const mgmt = debugModule("azure:event-hubs:management");
/**
 * @ignore
 * log statements for sender
 */
const sender = debugModule("azure:event-hubs:sender");
/**
 * @ignore
 * log statements for receiver
 */
const receiver = debugModule("azure:event-hubs:receiver");
/**
 * @ignore
 * log statements for receiverbatching
 */
const batching = debugModule("azure:event-hubs:receiverbatching");
/**
 * @ignore
 * log statements for receiverstreaming
 */
const streaming = debugModule("azure:event-hubs:receiverstreaming");
/**
 * @ignore
 * log statements for linkEntity
 */
const link = debugModule("azure:event-hubs:linkEntity");
/**
 * @ignore
 * log statements for connectionContext
 */
const context = debugModule("azure:event-hubs:connectionContext");
/**
 * @ignore
 * log statements for client
 */
const client = debugModule("azure:event-hubs:client");
/**
 * @ignore
 * log statements for iothub client
 */
const iotClient = debugModule("azure:event-hubs:iothubClient");
/**
 * @ignore
 * log statements for partitionManager
 */
const partitionPump = debugModule("azure:event-hubs:partitionPump");
/**
 * @ignore
 * log statements for pumpManager
 */
const pumpManager = debugModule("azure:event-hubs:pumpManager");
/**
 * @ignore
 * log statements for eventProcessor
 */
const eventProcessor = debugModule("azure:event-hubs:eventProcessor");
/**
 * @ignore
 * log statements for partitionLoadBalancer
 */
const partitionLoadBalancer = debugModule("azure:event-hubs:partitionLoadBalancer");

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the receive handler object that is returned from the receive() method with handlers.
 * The ReceiveHandler is used to stop receiving more messages.
 * @class ReceiveHandler
 */
class ReceiveHandler {
    /**
     * Creates an instance of the ReceiveHandler.
     * @constructor
     * @internal
     * @param receiver The underlying EventHubReceiver.
     */
    constructor(receiver) {
        this._receiver = receiver;
    }
    /**
     * @property The partitionId from which the handler is receiving events.
     * @readonly
     */
    get partitionId() {
        return this._receiver ? this._receiver.partitionId : undefined;
    }
    /**
     * @property The consumer group from which the handler is receiving events.
     * @readonly
     */
    get consumerGroup() {
        return this._receiver ? this._receiver.consumerGroup : undefined;
    }
    /**
     * @property Indicates whether the receiver is connected/open.
     * `true` - is open; `false` otherwise.
     * @readonly
     */
    get isReceiverOpen() {
        return this._receiver ? this._receiver.isOpen() : false;
    }
    /**
     * Stops the underlying EventHubReceiver from receiving more messages.
     * @returns Promise<void>
     * @throws {Error} Thrown if the underlying connection encounters an error while closing.
     */
    stop() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this._receiver) {
                try {
                    yield this._receiver.close();
                }
                catch (err) {
                    error("An error occurred while stopping the receiver '%s' with address '%s': %O", this._receiver.name, this._receiver.address, err);
                }
            }
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * @ignore
 */
const packageJsonInfo = {
    name: "@azure/event-hubs",
    version: "5.0.0-preview.5"
};

// Unique ID creation requires a high quality random # generator.  In node.js
// this is pretty straight-forward - we use the crypto API.



var rng = function nodeRNG() {
  return crypto.randomBytes(16);
};

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

var bytesToUuid_1 = bytesToUuid;

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid_1(rnds);
}

var v4_1 = v4;

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the base class for entities like EventHub Sender, Receiver and Management link.
 * @internal
 * @ignore
 * @class LinkEntity
 */
class LinkEntity {
    /**
     * Creates a new LinkEntity instance.
     * @ignore
     * @constructor
     * @param context The connection context.
     * @param [options] Options that can be provided while creating the LinkEntity.
     */
    constructor(context, options) {
        /**
         * @property isConnecting Indicates whether the link is in the process of connecting
         * (establishing) itself. Default value: `false`.
         */
        this.isConnecting = false;
        if (!options)
            options = {};
        this._context = context;
        this.address = options.address || "";
        this.audience = options.audience || "";
        this.name = `${options.name}-${v4_1()}`;
        this.partitionId = options.partitionId;
    }
    /**
     * Negotiates cbs claim for the LinkEntity.
     * @ignore
     * @protected
     * @param [setTokenRenewal] Set the token renewal timer. Default false.
     * @returns Promise<void>
     */
    _negotiateClaim(setTokenRenewal) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Acquire the lock and establish a cbs session if it does not exist on the connection.
            // Although node.js is single threaded, we need a locking mechanism to ensure that a
            // race condition does not happen while creating a shared resource (in this case the
            // cbs session, since we want to have exactly 1 cbs session per connection).
            link("[%s] Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: " +
                "'%s' with address: '%s'.", this._context.connectionId, this._context.cbsSession.cbsLock, this._type, this.name, this.address);
            yield coreAmqp.defaultLock.acquire(this._context.cbsSession.cbsLock, () => {
                return this._context.cbsSession.init();
            });
            let tokenObject;
            let tokenType;
            if (this._context.tokenCredential instanceof coreAmqp.SharedKeyCredential) {
                tokenObject = this._context.tokenCredential.getToken(this.audience);
                tokenType = coreAmqp.TokenType.CbsTokenTypeSas;
                // renew sas token in every 45 minutess
                this._tokenTimeoutInMs = (3600 - 900) * 1000;
            }
            else {
                const aadToken = yield this._context.tokenCredential.getToken(coreAmqp.Constants.aadEventHubsScope);
                if (!aadToken) {
                    throw new Error(`Failed to get token from the provided "TokenCredential" object`);
                }
                tokenObject = aadToken;
                tokenType = coreAmqp.TokenType.CbsTokenTypeJwt;
                this._tokenTimeoutInMs = tokenObject.expiresOnTimestamp - Date.now() - 2 * 60 * 1000;
            }
            link("[%s] %s: calling negotiateClaim for audience '%s'.", this._context.connectionId, this._type, this.audience);
            // Acquire the lock to negotiate the CBS claim.
            link("[%s] Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.", this._context.connectionId, this._context.negotiateClaimLock, this._type, this.name, this.address);
            yield coreAmqp.defaultLock.acquire(this._context.negotiateClaimLock, () => {
                return this._context.cbsSession.negotiateClaim(this.audience, tokenObject, tokenType);
            });
            link("[%s] Negotiated claim for %s '%s' with with address: %s", this._context.connectionId, this._type, this.name, this.address);
            if (setTokenRenewal) {
                yield this._ensureTokenRenewal();
            }
        });
    }
    /**
     * Ensures that the token is renewed within the predefined renewal margin.
     * @ignore
     * @protected
     * @returns
     */
    _ensureTokenRenewal() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this._tokenTimeoutInMs) {
                return;
            }
            this._tokenRenewalTimer = setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield this._negotiateClaim(true);
                }
                catch (err) {
                    error("[%s] %s '%s' with address %s, an error occurred while renewing the token: %O", this._context.connectionId, this._type, this.name, this.address, err);
                }
            }), this._tokenTimeoutInMs);
            link("[%s] %s '%s' with address %s, has next token renewal in %d milliseconds @(%s).", this._context.connectionId, this._type, this.name, this.address, this._tokenTimeoutInMs, new Date(Date.now() + this._tokenTimeoutInMs).toString());
        });
    }
    /**
     * Closes the Sender|Receiver link and it's underlying session and also removes it from the
     * internal map.
     * @ignore
     * @param [link] The Sender or Receiver link that needs to be closed and
     * removed.
     */
    _closeLink(link$1) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            clearTimeout(this._tokenRenewalTimer);
            if (link$1) {
                try {
                    // Closing the link and its underlying session if the link is open. This should also
                    // remove them from the internal map.
                    yield link$1.close();
                    link("[%s] %s '%s' with address '%s' closed.", this._context.connectionId, this._type, this.name, this.address);
                }
                catch (err) {
                    error("[%s] An error occurred while closing the %s '%s' with address '%s': %O", this._context.connectionId, this._type, this.name, this.address, err);
                }
            }
        });
    }
    /**
     * Provides the current type of the LinkEntity.
     * @returns The entity type.
     */
    get _type() {
        let result = "LinkEntity";
        if (this.constructor && this.constructor.name) {
            result = this.constructor.name;
        }
        return result;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @class ManagementClient
 * @internal
 * @ignore
 * Descibes the EventHubs Management Client that talks
 * to the $management endpoint over AMQP connection.
 */
class ManagementClient extends LinkEntity {
    /**
     * Instantiates the management client.
     * @constructor
     * @ignore
     * @param context The connection context.
     * @param [address] The address for the management endpoint. For IotHub it will be
     * `/messages/events/$management`.
     */
    constructor(context, options) {
        super(context, {
            address: options && options.address ? options.address : coreAmqp.Constants.management,
            audience: options && options.audience ? options.audience : context.config.getManagementAudience()
        });
        this.managementLock = `${coreAmqp.Constants.managementRequestKey}-${v4_1()}`;
        /**
         * @property replyTo The reply to Guid for the management client.
         */
        this.replyTo = v4_1();
        this._context = context;
        this.entityPath = context.config.entityPath;
    }
    /**
     * Provides the eventhub runtime information.
     * @ignore
     * @param connection - The established amqp connection
     * @returns
     */
    getHubRuntimeInformation(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!options) {
                options = {};
            }
            const request = {
                body: Buffer.from(JSON.stringify([])),
                message_id: v4_1(),
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.readOperation,
                    name: this.entityPath,
                    type: `${coreAmqp.Constants.vendorString}:${coreAmqp.Constants.eventHub}`
                }
            };
            const info = yield this._makeManagementRequest(request, Object.assign({}, options, { requestName: "getHubRuntimeInformation" }));
            const runtimeInfo = {
                path: info.name,
                createdAt: new Date(info.created_at),
                partitionIds: info.partition_ids
            };
            mgmt("[%s] The hub runtime info is: %O", this._context.connectionId, runtimeInfo);
            return runtimeInfo;
        });
    }
    /**
     * Provides an array of partitionIds.
     * @ignore
     * @param connection - The established amqp connection
     * @returns
     */
    getPartitionIds() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const runtimeInfo = yield this.getHubRuntimeInformation();
            return runtimeInfo.partitionIds;
        });
    }
    /**
     * Provides information about the specified partition.
     * @ignore
     * @param connection - The established amqp connection
     * @param partitionId Partition ID for which partition information is required.
     */
    getPartitionProperties(partitionId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!options) {
                options = {};
            }
            const request = {
                body: Buffer.from(JSON.stringify([])),
                message_id: v4_1(),
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.readOperation,
                    name: this.entityPath,
                    type: `${coreAmqp.Constants.vendorString}:${coreAmqp.Constants.partition}`,
                    partition: `${partitionId}`
                }
            };
            const info = yield this._makeManagementRequest(request, Object.assign({}, options, { requestName: "getPartitionInformation" }));
            const partitionInfo = {
                beginningSequenceNumber: info.begin_sequence_number,
                eventHubName: info.name,
                lastEnqueuedOffset: info.last_enqueued_offset,
                lastEnqueuedTimeUtc: new Date(info.last_enqueued_time_utc),
                lastEnqueuedSequenceNumber: info.last_enqueued_sequence_number,
                partitionId: info.partition
            };
            mgmt("[%s] The partition info is: %O.", this._context.connectionId, partitionInfo);
            return partitionInfo;
        });
    }
    /**
     * Closes the AMQP management session to the Event Hub for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @ignore
     * @returns
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._isMgmtRequestResponseLinkOpen()) {
                    const mgmtLink = this._mgmtReqResLink;
                    this._mgmtReqResLink = undefined;
                    clearTimeout(this._tokenRenewalTimer);
                    yield mgmtLink.close();
                    mgmt("Successfully closed the management session.");
                }
            }
            catch (err) {
                const msg = `An error occurred while closing the management session: ${err}`;
                error(msg);
                throw new Error(msg);
            }
        });
    }
    _init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!this._isMgmtRequestResponseLinkOpen()) {
                    yield this._negotiateClaim();
                    const rxopt = {
                        source: { address: this.address },
                        name: this.replyTo,
                        target: { address: this.replyTo },
                        onSessionError: (context) => {
                            const id = context.connection.options.id;
                            const ehError = coreAmqp.translate(context.session.error);
                            error("[%s] An error occurred on the session for request/response links for " +
                                "$management: %O", id, ehError);
                        }
                    };
                    const sropt = { target: { address: this.address } };
                    mgmt("[%s] Creating sender/receiver links on a session for $management endpoint with " +
                        "srOpts: %o, receiverOpts: %O.", this._context.connectionId, sropt, rxopt);
                    this._mgmtReqResLink = yield coreAmqp.RequestResponseLink.create(this._context.connection, sropt, rxopt);
                    this._mgmtReqResLink.sender.on(rheaPromise.SenderEvents.senderError, (context) => {
                        const id = context.connection.options.id;
                        const ehError = coreAmqp.translate(context.sender.error);
                        error("[%s] An error occurred on the $management sender link.. %O", id, ehError);
                    });
                    this._mgmtReqResLink.receiver.on(rheaPromise.ReceiverEvents.receiverError, (context) => {
                        const id = context.connection.options.id;
                        const ehError = coreAmqp.translate(context.receiver.error);
                        error("[%s] An error occurred on the $management receiver link.. %O", id, ehError);
                    });
                    mgmt("[%s] Created sender '%s' and receiver '%s' links for $management endpoint.", this._context.connectionId, this._mgmtReqResLink.sender.name, this._mgmtReqResLink.receiver.name);
                    yield this._ensureTokenRenewal();
                }
            }
            catch (err) {
                err = coreAmqp.translate(err);
                error("[%s] An error occured while establishing the $management links: %O", this._context.connectionId, err);
                throw err;
            }
        });
    }
    /**
     * @private
     * Helper method to make the management request
     * @param request The AMQP message to send
     * @param options The options to use when sending a request over a $management link
     */
    _makeManagementRequest(request, options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const retryOptions = options.retryOptions || {};
            try {
                const abortSignal = options && options.abortSignal;
                const sendOperationPromise = () => new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    let count = 0;
                    const retryTimeoutInMs = getRetryAttemptTimeoutInMs(options.retryOptions);
                    let timeTakenByInit = 0;
                    const rejectOnAbort = () => {
                        const requestName = options.requestName;
                        const desc = `[${this._context.connectionId}] The request "${requestName}" ` +
                            `to has been cancelled by the user.`;
                        error(desc);
                        const error$1 = new abortController.AbortError(`The ${requestName ? requestName + " " : ""}operation has been cancelled by the user.`);
                        reject(error$1);
                    };
                    if (abortSignal) {
                        if (abortSignal.aborted) {
                            return rejectOnAbort();
                        }
                    }
                    if (!this._isMgmtRequestResponseLinkOpen()) {
                        mgmt("[%s] Acquiring lock to get the management req res link.", this._context.connectionId);
                        const initOperationStartTime = Date.now();
                        const actionAfterTimeout = () => {
                            const desc = `The request with message_id "${request.message_id}" timed out. Please try again later.`;
                            const e = {
                                name: "OperationTimeoutError",
                                message: desc
                            };
                            return reject(coreAmqp.translate(e));
                        };
                        const waitTimer = setTimeout(actionAfterTimeout, retryTimeoutInMs);
                        try {
                            yield coreAmqp.defaultLock.acquire(this.managementLock, () => {
                                return this._init();
                            });
                        }
                        catch (err) {
                            return reject(coreAmqp.translate(err));
                        }
                        finally {
                            clearTimeout(waitTimer);
                        }
                        timeTakenByInit = Date.now() - initOperationStartTime;
                    }
                    const remainingOperationTimeoutInMs = retryTimeoutInMs - timeTakenByInit;
                    const sendRequestOptions = {
                        abortSignal: options.abortSignal,
                        requestName: options.requestName,
                        timeoutInMs: remainingOperationTimeoutInMs
                    };
                    count++;
                    if (count !== 1) {
                        // Generate a new message_id every time after the first attempt
                        request.message_id = rheaPromise.generate_uuid();
                    }
                    else if (!request.message_id) {
                        // Set the message_id in the first attempt only if it is not set
                        request.message_id = rheaPromise.generate_uuid();
                    }
                    try {
                        const result = yield this._mgmtReqResLink.sendRequest(request, sendRequestOptions);
                        resolve(result);
                    }
                    catch (err) {
                        err = coreAmqp.translate(err);
                        const address = this._mgmtReqResLink || this._mgmtReqResLink.sender.address
                            ? "address"
                            : this._mgmtReqResLink.sender.address;
                        error("[%s] An error occurred during send on management request-response link with address " +
                            "'%s': %O", this._context.connectionId, address, err);
                        reject(err);
                    }
                }));
                const config = {
                    operation: sendOperationPromise,
                    connectionId: this._context.connectionId,
                    operationType: coreAmqp.RetryOperationType.management,
                    abortSignal: abortSignal,
                    retryOptions: retryOptions
                };
                return (yield coreAmqp.retry(config)).body;
            }
            catch (err) {
                err = coreAmqp.translate(err);
                error("An error occurred while making the request to $management endpoint: %O", err);
                throw err;
            }
        });
    }
    _isMgmtRequestResponseLinkOpen() {
        return this._mgmtReqResLink && this._mgmtReqResLink.isOpen();
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * @ignore
 */
var ConnectionContext;
(function (ConnectionContext) {
    /**
     * @property userAgent The user agent string for the EventHubs client.
     * See guideline at https://github.com/Azure/azure-sdk/blob/master/docs/design/Telemetry.mdk
     */
    const userAgent = `azsdk-js-azureeventhubs/${packageJsonInfo.version} (NODE-VERSION ${process.version}; ${os.type()} ${os.release()})`;
    function getUserAgent(options) {
        const finalUserAgent = options.userAgent ? `${userAgent},${options.userAgent}` : userAgent;
        if (finalUserAgent.length > coreAmqp.Constants.maxUserAgentLength) {
            throw new Error(`The user-agent string cannot be more than ${coreAmqp.Constants.maxUserAgentLength} characters in length.` +
                `The given user-agent string is: ${finalUserAgent} with length: ${finalUserAgent.length}`);
        }
        return finalUserAgent;
    }
    ConnectionContext.getUserAgent = getUserAgent;
    function create(config, tokenCredential, options) {
        if (!options)
            options = {};
        config.webSocket = options.webSocket;
        config.webSocketEndpointPath = "$servicebus/websocket";
        config.webSocketConstructorOptions = options.webSocketConstructorOptions;
        const parameters = {
            config: config,
            tokenCredential: tokenCredential,
            dataTransformer: options.dataTransformer,
            isEntityPathRequired: true,
            connectionProperties: {
                product: "MSJSClient",
                userAgent: getUserAgent(options),
                version: packageJsonInfo.version
            }
        };
        // Let us create the base context and then add EventHub specific ConnectionContext properties.
        const connectionContext = coreAmqp.ConnectionContextBase.create(parameters);
        connectionContext.wasConnectionCloseCalled = false;
        connectionContext.senders = {};
        connectionContext.receivers = {};
        const mOptions = {
            address: options.managementSessionAddress,
            audience: options.managementSessionAudience
        };
        connectionContext.managementSession = new ManagementClient(connectionContext, mOptions);
        // Define listeners to be added to the connection object for
        // "connection_open" and "connection_error" events.
        const onConnectionOpen = (context$1) => {
            connectionContext.wasConnectionCloseCalled = false;
            context("[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.", connectionContext.connection.id, connectionContext.wasConnectionCloseCalled);
        };
        const disconnected = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const connectionError = context.connection && context.connection.error ? context.connection.error : undefined;
            if (connectionError) {
                error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, connectionError);
            }
            const contextError = context.error;
            if (contextError) {
                error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, contextError);
            }
            const state = {
                wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,
                numSenders: Object.keys(connectionContext.senders).length,
                numReceivers: Object.keys(connectionContext.receivers).length
            };
            // Clear internal map maintained by rhea to avoid reconnecting of old links once the
            // connection is back up.
            connectionContext.connection.removeAllSessions();
            // Close the cbs session to ensure all the event handlers are released.
            yield connectionContext.cbsSession.close();
            // Close the management session to ensure all the event handlers are released.
            yield connectionContext.managementSession.close();
            // The connection should always be brought back up if the sdk did not call connection.close()
            // and there was atleast one sender/receiver link on the connection before it went down.
            error("[%s] state: %O", connectionContext.connection.id, state);
            if (!state.wasConnectionCloseCalled && (state.numSenders || state.numReceivers)) {
                error("[%s] connection.close() was not called from the sdk and there were some " +
                    "sender or receiver links or both. We should reconnect.", connectionContext.connection.id);
                yield coreAmqp.delay(coreAmqp.Constants.connectionReconnectDelay);
                // reconnect senders if any
                for (const senderName of Object.keys(connectionContext.senders)) {
                    const sender = connectionContext.senders[senderName];
                    if (!sender.isConnecting) {
                        error("[%s] calling detached on sender '%s' with address '%s'.", connectionContext.connection.id, sender.name, sender.address);
                        sender.onDetached(connectionError || contextError).catch((err) => {
                            error("[%s] An error occurred while reconnecting the sender '%s' with adress '%s' %O.", connectionContext.connection.id, sender.name, sender.address, err);
                        });
                    }
                    else {
                        error("[%s] sender '%s' with address '%s' is already reconnecting. Hence not " +
                            "calling detached on the sender.", connectionContext.connection.id, sender.name, sender.address);
                    }
                }
                // reconnect receivers if any
                for (const receiverName of Object.keys(connectionContext.receivers)) {
                    const receiver = connectionContext.receivers[receiverName];
                    if (!receiver.isConnecting) {
                        error("[%s] calling detached on receiver '%s' with address '%s'.", connectionContext.connection.id, receiver.name, receiver.address);
                        receiver.onDetached(connectionError || contextError).catch((err) => {
                            error("[%s] An error occurred while reconnecting the receiver '%s' with adress '%s' %O.", connectionContext.connection.id, receiver.name, receiver.address, err);
                        });
                    }
                    else {
                        error("[%s] receiver '%s' with address '%s' is already reconnecting. Hence not " +
                            "calling detached on the receiver.", connectionContext.connection.id, receiver.name, receiver.address);
                    }
                }
            }
        });
        const protocolError = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (context.connection && context.connection.error) {
                error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.connection && context.connection.error);
            }
            if (context.error) {
                error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.error);
            }
        });
        const error$1 = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (context.connection && context.connection.error) {
                error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.connection && context.connection.error);
            }
            if (context.error) {
                error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.error);
            }
        });
        // Add listeners on the connection object.
        connectionContext.connection.on(rheaPromise.ConnectionEvents.connectionOpen, onConnectionOpen);
        connectionContext.connection.on(rheaPromise.ConnectionEvents.disconnected, disconnected);
        connectionContext.connection.on(rheaPromise.ConnectionEvents.protocolError, protocolError);
        connectionContext.connection.on(rheaPromise.ConnectionEvents.error, error$1);
        context("[%s] Created connection context successfully.", connectionContext.connectionId);
        return connectionContext;
    }
    ConnectionContext.create = create;
})(ConnectionContext || (ConnectionContext = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Converts the AMQP message to an EventData.
 * @param msg The AMQP message that needs to be converted to EventData.
 * @ignore
 */
function fromAmqpMessage(msg) {
    const data = {
        body: msg.body
    };
    if (msg.message_annotations) {
        for (const annotationKey of Object.keys(msg.message_annotations)) {
            switch (annotationKey) {
                case coreAmqp.Constants.partitionKey:
                    data.partitionKey = msg.message_annotations[annotationKey];
                    break;
                case coreAmqp.Constants.sequenceNumber:
                    data.sequenceNumber = msg.message_annotations[annotationKey];
                    break;
                case coreAmqp.Constants.enqueuedTime:
                    data.enqueuedTimeUtc = new Date(msg.message_annotations[annotationKey]);
                    break;
                case coreAmqp.Constants.offset:
                    data.offset = msg.message_annotations[annotationKey];
                    break;
                default:
                    if (!data.systemProperties) {
                        data.systemProperties = {};
                    }
                    data.systemProperties[annotationKey] = msg.message_annotations[annotationKey];
                    break;
            }
        }
    }
    if (msg.application_properties) {
        data.properties = msg.application_properties;
    }
    if (msg.delivery_annotations) {
        data.lastEnqueuedOffset = msg.delivery_annotations.last_enqueued_offset;
        data.lastSequenceNumber = msg.delivery_annotations.last_enqueued_sequence_number;
        data.lastEnqueuedTime = new Date(msg.delivery_annotations.last_enqueued_time_utc);
        data.retrievalTime = new Date(msg.delivery_annotations
            .runtime_info_retrieval_time_utc);
    }
    return data;
}
/**
 * Converts an EventData object to an AMQP message.
 * @param data The EventData object that needs to be converted to an AMQP message.
 * @param partitionKey An optional key to determine the partition that this event should land in.
 * @ignore
 */
function toAmqpMessage(data, partitionKey) {
    const msg = {
        body: data.body
    };
    // As per the AMQP 1.0 spec If the message-annotations or delivery-annotations section is omitted,
    // it is equivalent to a message-annotations section containing anempty map of annotations.
    msg.message_annotations = {};
    if (data.properties) {
        msg.application_properties = data.properties;
    }
    if (partitionKey != undefined) {
        msg.message_annotations[coreAmqp.Constants.partitionKey] = partitionKey;
        // Event Hub service cannot route messages to a specific partition based on the partition key
        // if AMQP message header is an empty object. Hence we make sure that header is always present
        // with atleast one property. Setting durable to true, helps us achieve that.
        msg.durable = true;
    }
    return msg;
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * @ignore
 * Logs and throws Error if the current AMQP connection is closed.
 * @param context The ConnectionContext associated with the current AMQP connection.
 */
function throwErrorIfConnectionClosed(context) {
    if (context && context.wasConnectionCloseCalled) {
        const errorMessage = "The underlying AMQP connection is closed.";
        const error$1 = new Error(errorMessage);
        error(`[${context.connectionId}] %O`, error$1);
        throw error$1;
    }
}
/**
 * @internal
 * @ignore
 * Logs and Throws TypeError if given parameter is undefined or null
 * @param connectionId Id of the underlying AMQP connection used for logging
 * @param parameterName Name of the parameter to check
 * @param parameterValue Value of the parameter to check
 */
function throwTypeErrorIfParameterMissing(connectionId, parameterName, parameterValue) {
    if (parameterValue === undefined || parameterValue === null) {
        const error$1 = new TypeError(`Missing parameter "${parameterName}"`);
        error(`[${connectionId}] %O`, error$1);
        throw error$1;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @ignore
 */
const TRACEPARENT_PROPERTY = "Diagnostic-Id";
/**
 * Populates the `EventData` with `SpanContext` info to support trace propagation.
 * Creates and returns a copy of the passed in `EventData` unless the `EventData`
 * has already been instrumented.
 * @param eventData The `EventData` to instrument.
 * @param span The `Span` containing the context to propagate tracing information.
 * @ignore
 */
function instrumentEventData(eventData, span) {
    if (eventData.properties && eventData.properties[TRACEPARENT_PROPERTY]) {
        return eventData;
    }
    // create a copy so the original isn't modified
    eventData = Object.assign({}, eventData, { properties: Object.assign({}, eventData.properties) });
    const traceParent = coreTracing.getTraceParentHeader(span.context());
    if (traceParent) {
        eventData.properties[TRACEPARENT_PROPERTY] = traceParent;
    }
    return eventData;
}
/**
 * Extracts the `SpanContext` from an `EventData` if the context exists.
 * @param eventData An individual `EventData` object.
 */
function extractSpanContextFromEventData(eventData) {
    if (!eventData.properties || !eventData.properties[TRACEPARENT_PROPERTY]) {
        return;
    }
    const diagnosticId = eventData.properties[TRACEPARENT_PROPERTY];
    return coreTracing.extractSpanContextFromTraceParentHeader(diagnosticId);
}

// Copyright (c) Microsoft Corporation. All rights reserved.
function createMessageSpan(parentSpan) {
    const tracer = coreTracing.getTracer();
    const span = tracer.startSpan("Azure.EventHubs.message", {
        kind: coreTracing.SpanKind.INTERNAL,
        parent: parentSpan
    });
    return span;
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Checks if the provided eventDataBatch is an instance of `EventDataBatch`.
 * @param eventDataBatch The instance of `EventDataBatch` to verify.
 * @internal
 * @ignore
 */
function isEventDataBatch(eventDataBatch) {
    return (eventDataBatch &&
        typeof eventDataBatch.tryAdd === "function" &&
        typeof eventDataBatch.count === "number" &&
        typeof eventDataBatch.sizeInBytes === "number");
}
/**
 * A class representing a batch of events which can be passed to the `send` method of a `EventProducer` instance.
 * This batch is ensured to be under the maximum message size supported by Azure Event Hubs service.
 *
 * Use `createBatch()` method on the `EventHubProducer` to create an instance of `EventDataBatch`
 * instead of using `new EventDataBatch()`. You can specify an upper limit for the size of the batch
 * via options when calling `createBatch()`.
 *
 * Use the `tryAdd` function on the EventDataBatch to add events to the batch. This method will return
 * `false` after the upper limit is reached, therefore check the result before calling `tryAdd()` again.
 * @class
 */
class EventDataBatch {
    /**
     * EventDataBatch should not be constructed using `new EventDataBatch()`
     * Use the `createBatch()` method on your `EventHubProducer` instead.
     * @constructor
     * @internal
     * @ignore
     */
    constructor(context, maxSizeInBytes, partitionKey) {
        /**
         * @property Encoded amqp messages.
         */
        this._encodedMessages = [];
        /**
         * List of 'message' span contexts.
         */
        this._spanContexts = [];
        this._context = context;
        this._maxSizeInBytes = maxSizeInBytes;
        this._partitionKey = partitionKey;
        this._sizeInBytes = 0;
        this._count = 0;
    }
    /**
     * @property The partitionKey set during `EventDataBatch` creation. This value is hashed to
     * produce a partition assignment when the producer is created without a `partitionId`
     * @readonly
     */
    get partitionKey() {
        return this._partitionKey;
    }
    /**
     * @property Size of the `EventDataBatch` instance after the events added to it have been
     * encoded into a single AMQP message.
     * @readonly
     */
    get sizeInBytes() {
        return this._sizeInBytes;
    }
    /**
     * @property Number of events in the `EventDataBatch` instance.
     * @readonly
     */
    get count() {
        return this._count;
    }
    /**
     * @property Represents the single AMQP message which is the result of encoding all the events
     * added into the `EventDataBatch` instance.
     *
     * This is not meant for the user to use directly.
     *
     * When the `EventDataBatch` instance is passed to the `send()` method on the `EventHubProducer`,
     * this single batched AMQP message is what gets sent over the wire to the service.
     * @readonly
     */
    get batchMessage() {
        return this._batchMessage;
    }
    /**
     * Gets the "message" span contexts that were created when adding events to the batch.
     * @internal
     * @ignore
     */
    get _messageSpanContexts() {
        return this._spanContexts;
    }
    /**
     * Tries to add an event data to the batch if permitted by the batch's size limit.
     * **NOTE**: Always remember to check the return value of this method, before calling it again
     * for the next event.
     *
     * @param eventData  An individual event data object.
     * @returns A boolean value indicating if the event data has been added to the batch or not.
     */
    tryAdd(eventData, options = {}) {
        throwTypeErrorIfParameterMissing(this._context.connectionId, "eventData", eventData);
        // check if the event has already been instrumented
        const previouslyInstrumented = Boolean(eventData.properties && eventData.properties[TRACEPARENT_PROPERTY]);
        if (!previouslyInstrumented) {
            const messageSpan = createMessageSpan(options.parentSpan);
            eventData = instrumentEventData(eventData, messageSpan);
            this._spanContexts.push(messageSpan.context());
            messageSpan.end();
        }
        // Convert EventData to AmqpMessage.
        const amqpMessage = toAmqpMessage(eventData, this._partitionKey);
        amqpMessage.body = this._context.dataTransformer.encode(eventData.body);
        // Encode every amqp message and then convert every encoded message to amqp data section
        this._encodedMessages.push(rheaPromise.message.encode(amqpMessage));
        const batchMessage = {
            body: rheaPromise.message.data_sections(this._encodedMessages)
        };
        if (amqpMessage.message_annotations) {
            batchMessage.message_annotations = amqpMessage.message_annotations;
        }
        const encodedBatchMessage = rheaPromise.message.encode(batchMessage);
        const currentSize = encodedBatchMessage.length;
        // this._batchMessage will be used for final send operation
        if (currentSize > this._maxSizeInBytes) {
            this._encodedMessages.pop();
            if (!previouslyInstrumented &&
                Boolean(eventData.properties && eventData.properties[TRACEPARENT_PROPERTY])) {
                this._spanContexts.pop();
            }
            return false;
        }
        this._batchMessage = encodedBatchMessage;
        this._sizeInBytes = currentSize;
        this._count++;
        return true;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the EventHubSender that will send event data to EventHub.
 * @class EventHubSender
 * @internal
 * @ignore
 */
class EventHubSender extends LinkEntity {
    /**
     * Creates a new EventHubSender instance.
     * @ignore
     * @constructor
     * @param context The connection context.
     * @param [partitionId] The EventHub partition id to which the sender
     * wants to send the event data.
     */
    constructor(context, partitionId) {
        super(context, {
            name: context.config.getSenderAddress(partitionId),
            partitionId: partitionId
        });
        /**
         * @property senderLock The unqiue lock name per connection that is used to acquire the
         * lock for establishing a sender link by an entity on that connection.
         * @readonly
         */
        this.senderLock = `sender-${v4_1()}`;
        this.address = context.config.getSenderAddress(partitionId);
        this.audience = context.config.getSenderAudience(partitionId);
        this._onAmqpError = (context) => {
            const senderError = context.sender && context.sender.error;
            if (senderError) {
                const err = coreAmqp.translate(senderError);
                error("[%s] An error occurred for sender '%s': %O.", this._context.connectionId, this.name, err);
            }
        };
        this._onSessionError = (context) => {
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const err = coreAmqp.translate(sessionError);
                error("[%s] An error occurred on the session of sender '%s': %O.", this._context.connectionId, this.name, err);
            }
        };
        this._onAmqpClose = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const sender = this._sender || context.sender;
            const senderError = context.sender && context.sender.error;
            if (senderError) {
                error("[%s] 'sender_close' event occurred for sender '%s' with address '%s'. " +
                    "The associated error is: %O", this._context.connectionId, this.name, this.address, senderError);
            }
            if (sender && !sender.isItselfClosed()) {
                if (!this.isConnecting) {
                    error("[%s] 'sender_close' event occurred on the sender '%s' with address '%s' " +
                        "and the sdk did not initiate this. The sender is not reconnecting. Hence, calling " +
                        "detached from the _onAmqpClose() handler.", this._context.connectionId, this.name, this.address);
                    yield this.onDetached(senderError);
                }
                else {
                    error("[%s] 'sender_close' event occurred on the sender '%s' with address '%s' " +
                        "and the sdk did not initate this. Moreover the sender is already re-connecting. " +
                        "Hence not calling detached from the _onAmqpClose() handler.", this._context.connectionId, this.name, this.address);
                }
            }
            else {
                error("[%s] 'sender_close' event occurred on the sender '%s' with address '%s' " +
                    "because the sdk initiated it. Hence not calling detached from the _onAmqpClose" +
                    "() handler.", this._context.connectionId, this.name, this.address);
            }
        });
        this._onSessionClose = (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const sender = this._sender || context.sender;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                error("[%s] 'session_close' event occurred for sender '%s' with address '%s'. " +
                    "The associated error is: %O", this._context.connectionId, this.name, this.address, sessionError);
            }
            if (sender && !sender.isSessionItselfClosed()) {
                if (!this.isConnecting) {
                    error("[%s] 'session_close' event occurred on the session of sender '%s' with " +
                        "address '%s' and the sdk did not initiate this. Hence calling detached from the " +
                        "_onSessionClose() handler.", this._context.connectionId, this.name, this.address);
                    yield this.onDetached(sessionError);
                }
                else {
                    error("[%s] 'session_close' event occurred on the session of sender '%s' with " +
                        "address '%s' and the sdk did not initiate this. Moreover the sender is already " +
                        "re-connecting. Hence not calling detached from the _onSessionClose() handler.", this._context.connectionId, this.name, this.address);
                }
            }
            else {
                error("[%s] 'session_close' event occurred on the session of sender '%s' with address " +
                    "'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose" +
                    "() handler.", this._context.connectionId, this.name, this.address);
            }
        });
    }
    /**
     * Will reconnect the sender link if necessary.
     * @ignore
     * @param [senderError] The sender error if any.
     * @returns Promise<void>.
     */
    onDetached(senderError) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const wasCloseInitiated = this._sender && this._sender.isItselfClosed();
                // Clears the token renewal timer. Closes the link and its session if they are open.
                // Removes the link and its session if they are present in rhea's cache.
                yield this._closeLink(this._sender);
                // We should attempt to reopen only when the sender(sdk) did not initiate the close
                let shouldReopen = false;
                if (senderError && !wasCloseInitiated) {
                    const translatedError = coreAmqp.translate(senderError);
                    if (translatedError.retryable) {
                        shouldReopen = true;
                        error("[%s] close() method of Sender '%s' with address '%s' was not called. There " +
                            "was an accompanying error an it is retryable. This is a candidate for re-establishing " +
                            "the sender link.", this._context.connectionId, this.name, this.address);
                    }
                    else {
                        error("[%s] close() method of Sender '%s' with address '%s' was not called. There " +
                            "was an accompanying error and it is NOT retryable. Hence NOT re-establishing " +
                            "the sender link.", this._context.connectionId, this.name, this.address);
                    }
                }
                else if (!wasCloseInitiated) {
                    shouldReopen = true;
                    error("[%s] close() method of Sender '%s' with address '%s' was not called. There " +
                        "was no accompanying error as well. This is a candidate for re-establishing " +
                        "the sender link.", this._context.connectionId, this.name, this.address);
                }
                else {
                    const state = {
                        wasCloseInitiated: wasCloseInitiated,
                        senderError: senderError,
                        _sender: this._sender
                    };
                    error("[%s] Something went wrong. State of sender '%s' with address '%s' is: %O", this._context.connectionId, this.name, this.address, state);
                }
                if (shouldReopen) {
                    yield coreAmqp.defaultLock.acquire(this.senderLock, () => {
                        const options = this._createSenderOptions(coreAmqp.Constants.defaultOperationTimeoutInMs, true);
                        // shall retry forever at an interval of 15 seconds if the error is a retryable error
                        // else bail out when the error is not retryable or the oepration succeeds.
                        const config = {
                            operation: () => this._init(options),
                            connectionId: this._context.connectionId,
                            operationType: coreAmqp.RetryOperationType.senderLink,
                            connectionHost: this._context.config.host,
                            retryOptions: {
                                maxRetries: coreAmqp.Constants.defaultMaxRetriesForConnection,
                                retryDelayInMs: 15000
                            }
                        };
                        return coreAmqp.retry(config);
                    });
                }
            }
            catch (err) {
                error("[%s] An error occurred while processing onDetached() of Sender '%s' with address " +
                    "'%s': %O", this._context.connectionId, this.name, this.address, err);
            }
        });
    }
    /**
     * Deletes the sender fromt the context. Clears the token renewal timer. Closes the sender link.
     * @ignore
     * @returns Promise<void>
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this._sender) {
                sender("[%s] Closing the Sender for the entity '%s'.", this._context.connectionId, this._context.config.entityPath);
                const senderLink = this._sender;
                this._deleteFromCache();
                yield this._closeLink(senderLink);
            }
        });
    }
    /**
     * Determines whether the AMQP sender link is open. If open then returns true else returns false.
     * @ignore
     * @returns boolean
     */
    isOpen() {
        const result = this._sender && this._sender.isOpen();
        error("[%s] Sender '%s' with address '%s' is open? -> %s", this._context.connectionId, this.name, this.address, result);
        return result;
    }
    /**
     * Returns maximum message size on the AMQP sender link.
     * @param abortSignal An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     * @returns Promise<number>
     * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.
     */
    getMaxMessageSize(options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const abortSignal = options.abortSignal;
            const retryOptions = options.retryOptions || {};
            if (this.isOpen()) {
                return this._sender.maxMessageSize;
            }
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const rejectOnAbort = () => {
                    const desc = `[${this._context.connectionId}] The create batch operation has been cancelled by the user.`;
                    error(desc);
                    const error$1 = new abortController.AbortError(`The create batch operation has been cancelled by the user.`);
                    reject(error$1);
                };
                const onAbort = () => {
                    if (abortSignal) {
                        abortSignal.removeEventListener("abort", onAbort);
                    }
                    rejectOnAbort();
                };
                if (abortSignal) {
                    // the aborter may have been triggered between request attempts
                    // so check if it was triggered and reject if needed.
                    if (abortSignal.aborted) {
                        return rejectOnAbort();
                    }
                    abortSignal.addEventListener("abort", onAbort);
                }
                try {
                    sender("Acquiring lock %s for initializing the session, sender and " +
                        "possibly the connection.", this.senderLock);
                    const senderOptions = this._createSenderOptions(coreAmqp.Constants.defaultOperationTimeoutInMs);
                    yield coreAmqp.defaultLock.acquire(this.senderLock, () => {
                        const config = {
                            operation: () => this._init(senderOptions),
                            connectionId: this._context.connectionId,
                            operationType: coreAmqp.RetryOperationType.senderLink,
                            abortSignal: abortSignal,
                            retryOptions: retryOptions
                        };
                        return coreAmqp.retry(config);
                    });
                    resolve(this._sender.maxMessageSize);
                }
                catch (err) {
                    error("[%s] An error occurred while creating the sender %s", this._context.connectionId, this.name, err);
                    reject(err);
                }
                finally {
                    if (abortSignal) {
                        abortSignal.removeEventListener("abort", onAbort);
                    }
                }
            }));
        });
    }
    /**
     * Send a batch of EventData to the EventHub. The "message_annotations",
     * "application_properties" and "properties" of the first message will be set as that
     * of the envelope (batch message).
     * @ignore
     * @param events  An array of EventData objects to be sent in a Batch message.
     * @param options Options to control the way the events are batched along with request options
     * @return Promise<void>
     */
    send(events, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                // throw an error if partition key and partition id are both defined
                if (options &&
                    typeof options.partitionKey === "string" &&
                    typeof options.partitionId === "string") {
                    const error$1 = new Error("Partition key is not supported when using producers that were created using a partition id.");
                    error("[%s] Partition key is not supported when using producers that were created using a partition id. %O", this._context.connectionId, error$1);
                    throw error$1;
                }
                // throw an error if partition key is different than the one provided in the options.
                if (events instanceof EventDataBatch && options && options.partitionKey) {
                    const error$1 = new Error("Partition key is not supported when sending a batch message. Pass the partition key when creating the batch message instead.");
                    error("[%s] Partition key is not supported when sending a batch message. Pass the partition key when creating the batch message instead. %O", this._context.connectionId, error$1);
                    throw error$1;
                }
                sender("[%s] Sender '%s', trying to send EventData[].", this._context.connectionId, this.name);
                let encodedBatchMessage;
                if (events instanceof EventDataBatch) {
                    encodedBatchMessage = events.batchMessage;
                }
                else {
                    const partitionKey = (options && options.partitionKey) || undefined;
                    const messages = [];
                    // Convert EventData to AmqpMessage.
                    for (let i = 0; i < events.length; i++) {
                        const message = toAmqpMessage(events[i], partitionKey);
                        message.body = this._context.dataTransformer.encode(events[i].body);
                        messages[i] = message;
                    }
                    // Encode every amqp message and then convert every encoded message to amqp data section
                    const batchMessage = {
                        body: rheaPromise.message.data_sections(messages.map(rheaPromise.message.encode))
                    };
                    // Set message_annotations of the first message as
                    // that of the envelope (batch message).
                    if (messages[0].message_annotations) {
                        batchMessage.message_annotations = messages[0].message_annotations;
                    }
                    // Finally encode the envelope (batch message).
                    encodedBatchMessage = rheaPromise.message.encode(batchMessage);
                }
                sender("[%s] Sender '%s', sending encoded batch message.", this._context.connectionId, this.name, encodedBatchMessage);
                return yield this._trySendBatch(encodedBatchMessage, options);
            }
            catch (err) {
                error("An error occurred while sending the batch message %O", err);
                throw err;
            }
        });
    }
    _deleteFromCache() {
        this._sender = undefined;
        delete this._context.senders[this.name];
        error("[%s] Deleted the sender '%s' with address '%s' from the client cache.", this._context.connectionId, this.name, this.address);
    }
    _createSenderOptions(timeoutInMs, newName) {
        if (newName)
            this.name = `${v4_1()}`;
        const srOptions = {
            name: this.name,
            target: {
                address: this.address
            },
            onError: this._onAmqpError,
            onClose: this._onAmqpClose,
            onSessionError: this._onSessionError,
            onSessionClose: this._onSessionClose,
            sendTimeoutInSeconds: timeoutInMs / 1000
        };
        sender("Creating sender with options: %O", srOptions);
        return srOptions;
    }
    /**
     * Tries to send the message to EventHub if there is enough credit to send them
     * and the circular buffer has available space to settle the message after sending them.
     *
     * We have implemented a synchronous send over here in the sense that we shall be waiting
     * for the message to be accepted or rejected and accordingly resolve or reject the promise.
     * @ignore
     * @param message The message to be sent to EventHub.
     * @returns Promise<void>
     */
    _trySendBatch(message, options = {}) {
        const abortSignal = options.abortSignal;
        const retryOptions = options.retryOptions || {};
        const sendEventPromise = () => new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rejectOnAbort = () => {
                const desc = `[${this._context.connectionId}] The send operation on the Sender "${this.name}" with ` +
                    `address "${this.address}" has been cancelled by the user.`;
                error(desc);
                return reject(new abortController.AbortError("The send operation has been cancelled by the user."));
            };
            if (abortSignal && abortSignal.aborted) {
                // operation has been cancelled, so exit quickly
                return rejectOnAbort();
            }
            const removeListeners = () => {
                clearTimeout(waitTimer);
                if (abortSignal) {
                    abortSignal.removeEventListener("abort", onAborted);
                }
            };
            const onAborted = () => {
                removeListeners();
                return rejectOnAbort();
            };
            if (abortSignal) {
                abortSignal.addEventListener("abort", onAborted);
            }
            const actionAfterTimeout = () => {
                removeListeners();
                const desc = `[${this._context.connectionId}] Sender "${this.name}" with ` +
                    `address "${this.address}", was not able to send the message right now, due ` +
                    `to operation timeout.`;
                error(desc);
                const e = {
                    name: "OperationTimeoutError",
                    message: desc
                };
                return reject(coreAmqp.translate(e));
            };
            const waitTimer = setTimeout(actionAfterTimeout, getRetryAttemptTimeoutInMs(options.retryOptions));
            if (!this.isOpen()) {
                sender("Acquiring lock %s for initializing the session, sender and " +
                    "possibly the connection.", this.senderLock);
                try {
                    const senderOptions = this._createSenderOptions(getRetryAttemptTimeoutInMs(options.retryOptions));
                    yield coreAmqp.defaultLock.acquire(this.senderLock, () => {
                        return this._init(senderOptions);
                    });
                }
                catch (err) {
                    removeListeners();
                    err = coreAmqp.translate(err);
                    error("[%s] An error occurred while creating the sender %s", this._context.connectionId, this.name, err);
                    return reject(err);
                }
            }
            sender("[%s] Sender '%s', credit: %d available: %d", this._context.connectionId, this.name, this._sender.credit, this._sender.session.outgoing.available());
            if (this._sender.sendable()) {
                sender("[%s] Sender '%s', sending message with id '%s'.", this._context.connectionId, this.name);
                try {
                    const delivery = yield this._sender.send(message, undefined, 0x80013700);
                    sender("[%s] Sender '%s', sent message with delivery id: %d", this._context.connectionId, this.name, delivery.id);
                    return resolve();
                }
                catch (err) {
                    err = coreAmqp.translate(err.innerError || err);
                    error("[%s] An error occurred while sending the message", this._context.connectionId, err);
                    return reject(err);
                }
                finally {
                    removeListeners();
                }
            }
            else {
                // let us retry to send the message after some time.
                const msg = `[${this._context.connectionId}] Sender "${this.name}", ` +
                    `cannot send the message right now. Please try later.`;
                error(msg);
                const amqpError = {
                    condition: coreAmqp.ErrorNameConditionMapper.SenderBusyError,
                    description: msg
                };
                reject(coreAmqp.translate(amqpError));
            }
        }));
        const config = {
            operation: sendEventPromise,
            connectionId: this._context.connectionId,
            operationType: coreAmqp.RetryOperationType.sendMessage,
            abortSignal: abortSignal,
            retryOptions: retryOptions
        };
        return coreAmqp.retry(config);
    }
    /**
     * Initializes the sender session on the connection.
     * @ignore
     * @returns
     */
    _init(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                // isOpen isConnecting  Should establish
                // true     false          No
                // true     true           No
                // false    true           No
                // false    false          Yes
                if (!this.isOpen() && !this.isConnecting) {
                    error("[%s] The sender '%s' with address '%s' is not open and is not currently " +
                        "establishing itself. Hence let's try to connect.", this._context.connectionId, this.name, this.address);
                    this.isConnecting = true;
                    yield this._negotiateClaim();
                    error("[%s] Trying to create sender '%s'...", this._context.connectionId, this.name);
                    this._sender = yield this._context.connection.createAwaitableSender(options);
                    this.isConnecting = false;
                    error("[%s] Sender '%s' with address '%s' has established itself.", this._context.connectionId, this.name, this.address);
                    this._sender.setMaxListeners(1000);
                    error("[%s] Promise to create the sender resolved. Created sender with name: %s", this._context.connectionId, this.name);
                    error("[%s] Sender '%s' created with sender options: %O", this._context.connectionId, this.name, options);
                    // It is possible for someone to close the sender and then start it again.
                    // Thus make sure that the sender is present in the client cache.
                    if (!this._context.senders[this.name])
                        this._context.senders[this.name] = this;
                    yield this._ensureTokenRenewal();
                }
                else {
                    error("[%s] The sender '%s' with address '%s' is open -> %s and is connecting " +
                        "-> %s. Hence not reconnecting.", this._context.connectionId, this.name, this.address, this.isOpen(), this.isConnecting);
                }
            }
            catch (err) {
                this.isConnecting = false;
                err = coreAmqp.translate(err);
                error("[%s] An error occurred while creating the sender %s", this._context.connectionId, this.name, err);
                throw err;
            }
        });
    }
    /**
     * Creates a new sender to the given event hub, and optionally to a given partition if it is
     * not present in the context or returns the one present in the context.
     * @ignore
     * @static
     * @param [partitionId] Partition ID to which it will send event data.
     * @returns
     */
    static create(context, partitionId) {
        const ehSender = new EventHubSender(context, partitionId);
        if (!context.senders[ehSender.name]) {
            context.senders[ehSender.name] = ehSender;
        }
        return context.senders[ehSender.name];
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * A producer responsible for sending events to an Event Hub.
 * To create a producer use the `createProducer()` method on your `EventHubClient`.
 * You can pass the below in the `options` when creating a producer.
 * - `partitionId`  : The identifier of the partition that the producer can be bound to.
 * - `retryOptions` : The retry options used to govern retry attempts when an issue is encountered while sending events.
 * A simple usage can be `{ "maxRetries": 4 }`.
 *
 * If `partitionId` is specified when creating a producer, all event data sent using the producer
 * will be sent to the specified partition.
 * Otherwise, they are automatically routed to an available partition by the Event Hubs service.
 *
 * Automatic routing of partitions is recommended because:
 *  - The sending of events will be highly available.
 *  - The event data will be evenly distributed among all available partitions.
 *
 * @class
 */
class EventHubProducer {
    /**
     * EventHubProducer should not be constructed using `new EventHubProduer()`
     * Use the `createProducer()` method on your `EventHubClient` instead.
     * @private
     * @constructor
     * @internal
     * @ignore
     */
    constructor(eventHubName, endpoint, context, options) {
        /**
         * @property Denotes if close() was called on this sender
         */
        this._isClosed = false;
        this._context = context;
        this._senderOptions = options || {};
        const partitionId = this._senderOptions.partitionId != undefined
            ? String(this._senderOptions.partitionId)
            : undefined;
        this._eventHubSender = EventHubSender.create(this._context, partitionId);
        this._eventHubName = eventHubName;
        this._endpoint = endpoint;
    }
    /**
     * @property Returns `true` if either the producer or the client that created it has been closed.
     * @readonly
     */
    get isClosed() {
        return this._isClosed || this._context.wasConnectionCloseCalled;
    }
    /**
     * Creates an instance of `EventDataBatch` to which one can add events until the maximum supported size is reached.
     * The batch can be passed to the `send()` method of the `EventHubProducer` to be sent to Azure Event Hubs.
     * @param options  A set of options to configure the behavior of the batch.
     * - `partitionKey`  : A value that is hashed to produce a partition assignment.
     * Not applicable if the `EventHubProducer` was created using a `partitionId`.
     * - `maxSizeInBytes`: The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.
     * - `abortSignal`   : A signal the request to cancel the send operation.
     * @returns Promise<EventDataBatch>
     */
    createBatch(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            if (!options) {
                options = {};
            }
            // throw an error if partition key and partition id are both defined
            if (typeof options.partitionKey === "string" &&
                typeof this._senderOptions.partitionId === "string") {
                const error$1 = new Error("Creating a batch with partition key is not supported when using producers that were created using a partition id.");
                error("[%s] Creating a batch with partition key is not supported when using producers that were created using a partition id. %O", this._context.connectionId, error$1);
                throw error$1;
            }
            let maxMessageSize = yield this._eventHubSender.getMaxMessageSize({
                retryOptions: this._senderOptions.retryOptions,
                abortSignal: options.abortSignal
            });
            if (options.maxSizeInBytes) {
                if (options.maxSizeInBytes > maxMessageSize) {
                    const error$1 = new Error(`Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link.`);
                    error(`[${this._context.connectionId}] Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link. ${error$1}`);
                    throw error$1;
                }
                maxMessageSize = options.maxSizeInBytes;
            }
            return new EventDataBatch(this._context, maxMessageSize, options.partitionKey);
        });
    }
    /**
     * Send one or more of events to the associated Event Hub.
     *
     * @param eventData  An individual `EventData` object, or an array of `EventData` objects or an
     * instance of `EventDataBatch`.
     * @param options The set of options that can be specified to influence the way in which
     * events are sent to the associated Event Hub.
     * - `partitionKey` : A value that is hashed to produce a partition assignment.
     * Not applicable if the `EventHubProducer` was created using a `partitionId`.
     * - `abortSignal`  : A signal the request to cancel the send operation.
     *
     * @returns Promise<void>
     * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.
     * @throws {MessagingError} Thrown if an error is encountered while sending a message.
     * @throws {TypeError} Thrown if a required parameter is missing.
     * @throws {Error} Thrown if the underlying connection or sender has been closed.
     * @throws {Error} Thrown if a partitionKey is provided when the producer was created with a partitionId.
     * @throws {Error} Thrown if batch was created with partitionKey different than the one provided in the options.
     * Create a new producer using the EventHubClient createProducer method.
     */
    send(eventData, options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._throwIfSenderOrConnectionClosed();
            throwTypeErrorIfParameterMissing(this._context.connectionId, "eventData", eventData);
            if (Array.isArray(eventData) && eventData.length === 0) {
                error(`[${this._context.connectionId}] Empty array was passed. No events to send.`);
                return;
            }
            if (eventData instanceof EventDataBatch && eventData.count === 0) {
                error(`[${this._context.connectionId}] Empty batch was passsed. No events to send.`);
                return;
            }
            if (!Array.isArray(eventData) && !(eventData instanceof EventDataBatch)) {
                eventData = [eventData];
            }
            // link message span contexts
            let spanContextsToLink = [];
            if (Array.isArray(eventData)) {
                for (let i = 0; i < eventData.length; i++) {
                    const event = eventData[i];
                    if (!event.properties || !event.properties[TRACEPARENT_PROPERTY]) {
                        const messageSpan = createMessageSpan(options.parentSpan);
                        // since these message spans are created from same context as the send span,
                        // these message spans don't need to be linked.
                        // replace the original event with the instrumented one
                        eventData[i] = instrumentEventData(eventData[i], messageSpan);
                        messageSpan.end();
                    }
                }
            }
            else if (isEventDataBatch(eventData)) {
                spanContextsToLink = eventData._messageSpanContexts;
            }
            const sendSpan = this._createSendSpan(options.parentSpan);
            for (const spanContext of spanContextsToLink) {
                sendSpan.addLink(spanContext);
            }
            try {
                const result = yield this._eventHubSender.send(eventData, Object.assign({}, this._senderOptions, options));
                sendSpan.setStatus({ code: coreTracing.CanonicalCode.OK });
                return result;
            }
            catch (err) {
                sendSpan.setStatus({
                    code: coreTracing.CanonicalCode.UNKNOWN,
                    message: err.message
                });
                throw err;
            }
            finally {
                sendSpan.end();
            }
        });
    }
    /**
     * Closes the underlying AMQP sender link.
     * Once closed, the producer cannot be used for any further operations.
     * Use the `createProducer` function on the EventHubClient to instantiate a new EventHubProducer.
     *
     * @returns
     * @throws {Error} Thrown if the underlying connection encounters an error while closing.
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._context.connection && this._context.connection.isOpen() && this._eventHubSender) {
                    yield this._eventHubSender.close();
                    this._eventHubSender = undefined;
                }
                this._isClosed = true;
            }
            catch (err) {
                error("[%s] An error occurred while closing the Sender for %s: %O", this._context.connectionId, this._context.config.entityPath, err);
                throw err;
            }
        });
    }
    _createSendSpan(parentSpan) {
        const tracer = coreTracing.getTracer();
        const span = tracer.startSpan("Azure.EventHubs.send", {
            kind: coreTracing.SpanKind.PRODUCER,
            parent: parentSpan
        });
        span.setAttribute("component", "eventhubs");
        span.setAttribute("message_bus.destination", this._eventHubName);
        span.setAttribute("peer.address", this._endpoint);
        return span;
    }
    _throwIfSenderOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context);
        if (this.isClosed) {
            const errorMessage = `The EventHubProducer for "${this._context.config.entityPath}" has been closed and can no longer be used. ` +
                `Please create a new EventHubProducer using the "createProducer" function on the EventHubClient.`;
            const error$1 = new Error(errorMessage);
            error(`[${this._context.connectionId}] %O`, error$1);
            throw error$1;
        }
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Represents the position of an event in an Event Hub partition, typically used in the creation of
 * an `EventHubConsumer` to specify the position in the partition to begin receiving events from.
 *
 * Make use of the below static helpers to create an instance of `EventPosition`
 * - `fromOffset()`
 * - `fromSequenceNumber()`
 * - `fromEnqueuedTime()`
 * - `earliest()`
 * - `latest()`
 * @class
 */
class EventPosition {
    /**
     * Instead of constructing an event position using `new Event Position()`, make use of the below static helpers
     * - `fromOffset()`
     * - `fromSequenceNumber()`
     * - `fromEnqueuedTime()`
     * - `earliest()`
     * - `latest()`
     *
     * @constructor
     * @internal
     * @ignore
     * @param options
     */
    constructor(options) {
        /**
         * @property Indicates if the specified offset is inclusive of the event which it identifies.
         * This information is only relevent if the event position was identified by an offset or sequence number.
         * Default value: `false`.
         */
        this.isInclusive = false;
        if (options) {
            this.offset = options.offset;
            this.enqueuedTime = options.enqueuedTime;
            this.sequenceNumber = options.sequenceNumber;
            this.isInclusive = options.isInclusive || false;
        }
    }
    /**
     * Gets an instance of `EventPosition` corresponding to the event in the partition at the provided offset.
     *
     * @param offset The offset of an event with respect to its relative position in the partition.
     * @param isInclusive If true, the specified event is included;
     * otherwise the next event is returned.
     * Default: `false`.
     * @returns EventPosition
     */
    static fromOffset(offset, isInclusive) {
        if (typeof offset !== "number" && typeof offset !== "string") {
            throw new Error(`Invalid offset "${offset}" provided to "fromOffset" method.`);
        }
        return new EventPosition({ offset: offset, isInclusive: isInclusive });
    }
    /**
     * Gets an instance of `EventPosition` corresponding to the event in the partition having a specified sequence number associated with it.
     *
     * @param sequenceNumber The sequence number assigned to an event when it was enqueued in the partition.
     * @param isInclusive If true, event with the `sequenceNumber` is included;
     * otherwise the next event in sequence will be received.
     * Default `false`.
     * @returns EventPosition
     */
    static fromSequenceNumber(sequenceNumber, isInclusive) {
        if (sequenceNumber == undefined) {
            throw new Error('Missing parameter "sequenceNumber"');
        }
        if (typeof sequenceNumber !== "number") {
            throw new Error('The parameter "sequenceNumber" should be of type "number"');
        }
        return new EventPosition({ sequenceNumber: sequenceNumber, isInclusive: isInclusive });
    }
    /**
     * Gets an instance of `EventPosition` corresponding to a specific date and time within the partition to begin seeking an event;
     * the event enqueued after the requested `enqueuedTime` will become the current position.
     *
     * @param enqueuedTime The date and time, in UTC, from which the next available event should be chosen.
     * @returns EventPosition
     */
    static fromEnqueuedTime(enqueuedTime) {
        if (typeof enqueuedTime !== "number" && !(enqueuedTime instanceof Date)) {
            throw new Error(`Invalid enqueuedTime "${enqueuedTime}" provided to "fromEnqueuedTime" method.`);
        }
        return new EventPosition({ enqueuedTime: enqueuedTime });
    }
    /**
     * Gets an instance of `EventPosition` corresponding to the location of the the first event present in the partition.
     * Use this position to begin receiving from the first event that was enqueued in the partition
     * which has not expired due to the retention policy.
     * @returns EventPosition
     */
    static earliest() {
        return EventPosition.fromOffset(EventPosition.startOfStream);
    }
    /**
     * Gets an instance of `EventPosition` corresponding to the end of the partition, where no more events are currently enqueued.
     * Use this position to begin receiving from the next event to be enqueued in the partion after an ``EventHubConsumer``
     * is created with this position.
     * @returns EventPosition
     */
    static latest() {
        return new EventPosition({ offset: EventPosition.endOfStream });
    }
}
/**
 * @property The token that represents the beginning event in the stream of a partition: `-1`.
 * @static
 * @readonly
 * @ignore
 */
EventPosition.startOfStream = -1;
/**
 * @property The token that represents the last event in the stream of a partition: `"@latest"`.
 * @static
 * @readonly
 * @ignore
 */
EventPosition.endOfStream = "@latest";
/**
 * @internal
 * @ignore
 * Gets the expression to be set as the filter clause when creating the receiver
 * @return {string} filterExpression
 */
function getEventPositionFilter(eventPosition) {
    let result;
    // order of preference
    if (eventPosition.offset != undefined) {
        result = eventPosition.isInclusive
            ? `${coreAmqp.Constants.offsetAnnotation} >= '${eventPosition.offset}'`
            : `${coreAmqp.Constants.offsetAnnotation} > '${eventPosition.offset}'`;
    }
    else if (eventPosition.sequenceNumber != undefined) {
        result = eventPosition.isInclusive
            ? `${coreAmqp.Constants.sequenceNumberAnnotation} >= '${eventPosition.sequenceNumber}'`
            : `${coreAmqp.Constants.sequenceNumberAnnotation} > '${eventPosition.sequenceNumber}'`;
    }
    else if (eventPosition.enqueuedTime != undefined) {
        const time = eventPosition.enqueuedTime instanceof Date
            ? eventPosition.enqueuedTime.getTime()
            : eventPosition.enqueuedTime;
        result = `${coreAmqp.Constants.enqueuedTimeAnnotation} > '${time}'`;
    }
    if (!result) {
        throw coreAmqp.translate({
            condition: coreAmqp.ErrorNameConditionMapper.ArgumentError,
            description: "No starting position was set in the EventPosition."
        });
    }
    return result;
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the EventHubReceiver that will receive event data from EventHub.
 * @class EventHubReceiver
 * @internal
 * @ignore
 */
class EventHubReceiver extends LinkEntity {
    /**
     * Instantiates a receiver that can be used to receive events over an AMQP receiver link in
     * either batching or streaming mode.
     * @ignore
     * @constructor
     * @param context        The connection context corresponding to the EventHubClient instance
     * @param consumerGroup  The consumer group from which the receiver should receive events from.
     * @param partitionId    The Partition ID from which to receive.
     * @param eventPosition  The position in the stream from where to start receiving events.
     * @param [options]      Receiver options.
     */
    constructor(context, consumerGroup, partitionId, eventPosition, options = {}) {
        super(context, {
            partitionId: partitionId,
            name: context.config.getReceiverAddress(partitionId, consumerGroup)
        });
        /**
         * @property _checkpoint The sequence number of the most recently received AMQP message.
         * @private
         */
        this._checkpoint = -1;
        /**
         * @property _internalQueue A queue of events that were received from the AMQP link but not consumed externally by `EventHubConsumer`
         * @private
         */
        this._internalQueue = [];
        /**
         * @property _usingInternalQueue Indicates that events in the internal queue are being processed to be consumed by `EventHubConsumer`
         * @private
         */
        this._usingInternalQueue = false;
        /**
         * @property _isReceivingMessages Indicates if messages are being received from this receiver.
         * @private
         */
        this._isReceivingMessages = false;
        /**
         * @property _isStreaming Indicated if messages are being received in streaming mode.
         * @private
         */
        this._isStreaming = false;
        this.consumerGroup = consumerGroup;
        this.address = context.config.getReceiverAddress(partitionId, this.consumerGroup);
        this.audience = context.config.getReceiverAudience(partitionId, this.consumerGroup);
        this.ownerLevel = options.ownerLevel;
        this.eventPosition = eventPosition;
        this.options = options;
        this.runtimeInfo = {};
    }
    /**
     * @property Returns sequenceNumber of the last event received from the service. This will not match the
     * last event received by `EventHubConsumer` when the `_internalQueue` is not empty
     * @readonly
     */
    get checkpoint() {
        return this._checkpoint;
    }
    /**
     * @property Indicates if messages are being received from this receiver.
     * @readonly
     */
    get isReceivingMessages() {
        return this._isReceivingMessages;
    }
    _onAmqpMessage(context) {
        if (!context.message) {
            return;
        }
        const data = fromAmqpMessage(context.message);
        const receivedEventData = {
            body: this._context.dataTransformer.decode(context.message.body),
            properties: data.properties,
            offset: data.offset,
            sequenceNumber: data.sequenceNumber,
            enqueuedTimeUtc: data.enqueuedTimeUtc,
            partitionKey: data.partitionKey,
            systemProperties: data.systemProperties
        };
        this._checkpoint = receivedEventData.sequenceNumber;
        if (this.options.trackLastEnqueuedEventInfo && data) {
            this.runtimeInfo.sequenceNumber = data.lastSequenceNumber;
            this.runtimeInfo.enqueuedTime = data.lastEnqueuedTime;
            this.runtimeInfo.offset = data.lastEnqueuedOffset;
            this.runtimeInfo.retrievalTime = data.retrievalTime;
            receiver("[%s] RuntimeInfo of Receiver '%s' is %O", this._context.connectionId, this.name, this.runtimeInfo);
        }
        // Add to internal queue if
        // - There are no listeners, we are probably getting events due to pending credits
        // - Or Events from internal queue are being processed, so add to it to ensure order of processing is retained
        if (!this._onMessage || this._usingInternalQueue) {
            this._internalQueue.push(receivedEventData);
        }
        else {
            if (this._isStreaming) {
                this._addCredit(1);
            }
            this._onMessage(receivedEventData);
        }
    }
    _onAmqpError(context) {
        const rheaReceiver = this._receiver || context.receiver;
        if (!rheaReceiver) {
            return;
        }
        const amqpError = rheaReceiver.error;
        if (!amqpError) {
            return;
        }
        if (rheaReceiver.isItselfClosed()) {
            error("[%s] The receiver was closed by the user." +
                "Hence not notifying the user's error handler.", this._context.connectionId);
            return;
        }
        if (this._onError) {
            const error$1 = coreAmqp.translate(amqpError);
            error("[%s] An error occurred for Receiver '%s': %O.", this._context.connectionId, this.name, error$1);
            error("[%s] Since the user did not close the receiver " +
                "we let the user know about it by calling the user's error handler.", this._context.connectionId);
            this._onError(error$1);
        }
    }
    _onAmqpSessionError(context) {
        const rheaReceiver = this._receiver || context.receiver;
        if (!rheaReceiver) {
            return;
        }
        const sessionError = context.session && context.session.error;
        if (!sessionError) {
            return;
        }
        if (rheaReceiver.isSessionItselfClosed()) {
            error("[%s] The receiver was closed by the user." +
                "Hence not notifying the user's error handler.", this._context.connectionId);
            return;
        }
        if (this._onError) {
            const error$1 = coreAmqp.translate(sessionError);
            error("[%s] An error occurred on the session for Receiver '%s': %O.", this._context.connectionId, this.name, error$1);
            error("[%s] Since the user did not close the receiver, " +
                "we let the user know about it by calling the user's error handler.", this._context.connectionId);
            this._onError(error$1);
        }
    }
    _onAmqpClose(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rheaReceiver = this._receiver || context.receiver;
            if (!rheaReceiver || rheaReceiver.isItselfClosed()) {
                error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                    "because the sdk initiated it. Hence not calling detached from the _onAmqpClose" +
                    "() handler.", this._context.connectionId, this.name, this.address);
                return;
            }
            const amqpError = rheaReceiver.error;
            if (amqpError) {
                error("[%s] 'receiver_close' event occurred for receiver '%s' with address '%s'. " +
                    "The associated error is: %O", this._context.connectionId, this.name, this.address, amqpError);
            }
            if (!this.isConnecting) {
                error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                    "and the sdk did not initiate this. The receiver is not reconnecting. Hence, calling " +
                    "detached from the _onAmqpClose() handler.", this._context.connectionId, this.name, this.address);
                yield this.onDetached(amqpError);
            }
            else {
                error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                    "and the sdk did not initate this. Moreover the receiver is already re-connecting. " +
                    "Hence not calling detached from the _onAmqpClose() handler.", this._context.connectionId, this.name, this.address);
            }
        });
    }
    _onAmqpSessionClose(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rheaReceiver = this._receiver || context.receiver;
            if (!rheaReceiver || rheaReceiver.isSessionItselfClosed()) {
                error("[%s] 'session_close' event occurred on the session of receiver '%s' with " +
                    "address '%s' and the sdk did not initiate this. Moreover the receiver is already " +
                    "re-connecting. Hence not calling detached from the _onAmqpSessionClose() handler.", this._context.connectionId, this.name, this.address);
                return;
            }
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                error("[%s] 'session_close' event occurred for receiver '%s' with address '%s'. " +
                    "The associated error is: %O", this._context.connectionId, this.name, this.address, sessionError);
            }
            if (!this.isConnecting) {
                error("[%s] 'session_close' event occurred on the session of receiver '%s' with " +
                    "address '%s' and the sdk did not initiate this. Hence calling detached from the " +
                    "_onAmqpSessionClose() handler.", this._context.connectionId, this.name, this.address);
                yield this.onDetached(sessionError);
            }
            else {
                error("[%s] 'session_close' event occurred on the session of receiver '%s' with " +
                    "address '%s' and the sdk did not initiate this. Moreover the receiver is already " +
                    "re-connecting. Hence not calling detached from the _onAmqpSessionClose() handler.", this._context.connectionId, this.name, this.address);
            }
        });
    }
    abort() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const desc = `[${this._context.connectionId}] The receive operation on the Receiver "${this.name}" with ` +
                `address "${this.address}" has been cancelled by the user.`;
            error(desc);
            if (this._onError) {
                const error = new abortController.AbortError("The receive operation has been cancelled by the user.");
                this._onError(error);
            }
            this.clearHandlers();
            yield this.close();
        });
    }
    /**
     * Will reconnect the receiver link if necessary.
     * @ignore
     * @param [receiverError] The receiver error if any.
     * @returns Promise<void>.
     */
    onDetached(receiverError) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const rheaReceiver = this._receiver;
                const wasCloseInitiated = rheaReceiver && rheaReceiver.isItselfClosed();
                // Clears the token renewal timer. Closes the link and its session if they are open.
                // Removes the link and its session if they are present in rhea's cache.
                yield this._closeLink(rheaReceiver);
                // We should attempt to reopen only when the receiver(sdk) did not initiate the close
                let shouldReopen = false;
                if (receiverError && !wasCloseInitiated) {
                    // if there was an error and it is retryable, recreate the link
                    const translatedError = coreAmqp.translate(receiverError);
                    if (translatedError.retryable) {
                        shouldReopen = true;
                        error("[%s] close() method of Receiver '%s' with address '%s' was not called. There " +
                            "was an accompanying error and it is retryable. This is a candidate for re-establishing " +
                            "the receiver link.", this._context.connectionId, this.name, this.address);
                    }
                    else {
                        error("[%s] close() method of Receiver '%s' with address '%s' was not called. There " +
                            "was an accompanying error and it is NOT retryable. Hence NOT re-establishing " +
                            "the receiver link.", this._context.connectionId, this.name, this.address);
                    }
                }
                else if (!wasCloseInitiated) {
                    // there wasn't an error, and the client didn't initialize the close; recreate the link
                    shouldReopen = true;
                    error("[%s] close() method of Receiver '%s' with address '%s' was not called. " +
                        "There was no accompanying error as well. This is a candidate for re-establishing " +
                        "the receiver link.", this._context.connectionId, this.name, this.address);
                }
                else {
                    const state = {
                        wasCloseInitiated: wasCloseInitiated,
                        receiverError: receiverError,
                        _receiver: this._receiver
                    };
                    error("[%s] Something went wrong. State of Receiver '%s' with address '%s' is: %O", this._context.connectionId, this.name, this.address, state);
                }
                if (!shouldReopen) {
                    return;
                }
                const receiverOptions = {
                    onMessage: (context) => this._onAmqpMessage(context),
                    onError: (context) => this._onAmqpError(context),
                    onClose: (context) => this._onAmqpClose(context),
                    onSessionClose: (context) => this._onAmqpSessionClose(context),
                    onSessionError: (context) => this._onAmqpSessionError(context),
                    newName: true // prevents service from sending an error stating that the link is still open
                };
                if (this.checkpoint > -1) {
                    receiverOptions.eventPosition = EventPosition.fromSequenceNumber(this.checkpoint);
                }
                // create RHEA receiver options
                const initOptions = this._createReceiverOptions(receiverOptions);
                // attempt to create the link
                const linkCreationConfig = {
                    connectionId: this._context.connectionId,
                    connectionHost: this._context.config.host,
                    operation: () => this.initialize(initOptions),
                    operationType: coreAmqp.RetryOperationType.receiverLink,
                    retryOptions: {
                        maxRetries: coreAmqp.Constants.defaultMaxRetriesForConnection,
                        retryDelayInMs: 15000
                    }
                };
                yield coreAmqp.retry(linkCreationConfig);
                // if the receiver is in streaming mode we need to add credits again.
                if (this._isStreaming) {
                    this._addCredit(coreAmqp.Constants.defaultPrefetchCount);
                }
            }
            catch (err) {
                error("[%s] An error occurred while processing onDetached() of Receiver '%s' with address " +
                    "'%s': %O", this._context.connectionId, this.name, this.address, err);
            }
        });
    }
    /**
     * Clears the user-provided handlers and updates the receiving messages flag.
     * @ignore
     */
    clearHandlers() {
        if (this._abortSignal && this._onAbort) {
            this._abortSignal.removeEventListener("abort", this._onAbort);
        }
        this._abortSignal = undefined;
        this._onAbort = undefined;
        this._onError = undefined;
        this._onMessage = undefined;
        this._isReceivingMessages = false;
        this._isStreaming = false;
    }
    /**
     * Closes the underlying AMQP receiver.
     * @ignore
     * @returns
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.clearHandlers();
            if (!this._receiver) {
                return;
            }
            const receiverLink = this._receiver;
            this._deleteFromCache();
            yield this._closeLink(receiverLink);
        });
    }
    /**
     * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
     * @ignore
     * @returns boolean
     */
    isOpen() {
        const result = Boolean(this._receiver && this._receiver.isOpen());
        error("[%s] Receiver '%s' with address '%s' is open? -> %s", this._context.connectionId, this.name, this.address, result);
        return result;
    }
    /**
     * Registers the user's onMessage and onError handlers.
     * Sends buffered events from the queue before adding additional credits to the AMQP link.
     * @ignore
     */
    registerHandlers(onMessage, onError, maximumCreditCount, isStreaming, abortSignal, onAbort) {
        this._abortSignal = abortSignal;
        this._onAbort = onAbort;
        this._onError = onError;
        this._onMessage = onMessage;
        this._isStreaming = isStreaming;
        // indicate that messages are being received.
        this._isReceivingMessages = true;
        this._useInternalQueue(onMessage, abortSignal)
            .then((processedEventCount) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this._onMessage !== onMessage) {
                // the original handler has been removed, so no further action required.
                return;
            }
            // check if more messages are required
            if (!isStreaming && maximumCreditCount - processedEventCount <= 0) {
                return;
            }
            if (!this.isOpen()) {
                try {
                    yield this.initialize();
                    if (abortSignal && abortSignal.aborted) {
                        yield this.abort();
                    }
                }
                catch (err) {
                    return this._onError === onError && onError(err);
                }
            }
            else {
                receiver("[%s] Receiver link already present, hence reusing it.", this._context.connectionId);
            }
            // add credits
            const existingCredits = this._receiver ? this._receiver.credit : 0;
            const prcoessedEventCountToExclude = isStreaming ? 0 : processedEventCount;
            const creditsToAdd = Math.max(maximumCreditCount - (existingCredits + prcoessedEventCountToExclude), 0);
            this._addCredit(creditsToAdd);
        }))
            .catch((err) => {
            // something really unexpected happened, so attempt to call user's error handler
            if (this._onError === onError) {
                onError(err);
            }
        });
    }
    _addCredit(credit) {
        if (this._receiver) {
            this._receiver.addCredit(credit);
        }
    }
    _deleteFromCache() {
        this._receiver = undefined;
        delete this._context.receivers[this.name];
        error("[%s] Deleted the receiver '%s' from the client cache.", this._context.connectionId, this.name);
    }
    _useInternalQueue(onMessage, abortSignal) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let processedMessagesCount = 0;
            // allow the event loop to process any blocking code outside
            // this code path before sending any events.
            yield coreAmqp.delay(0);
            this._usingInternalQueue = true;
            while (this._internalQueue.length) {
                if (!this._onMessage) {
                    break;
                }
                if (abortSignal && abortSignal.aborted) {
                    break;
                }
                // These will not be equal if clearHandlers and registerHandlers were called
                // in the same tick of the event loop. If onMessage isn't the currently active
                // handler, it should stop getting messages from the queue.
                if (this._onMessage !== onMessage) {
                    break;
                }
                const eventData = this._internalQueue.splice(0, 1)[0];
                processedMessagesCount++;
                onMessage(eventData);
                // allow the event loop to process any blocking code outside
                // this code path before sending the next event.
                yield coreAmqp.delay(0);
            }
            this._usingInternalQueue = false;
            return processedMessagesCount;
        });
    }
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     * @ignore
     * @returns
     */
    initialize(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.isOpen() && !this.isConnecting) {
                    error("[%s] The receiver '%s' with address '%s' is not open and is not currently " +
                        "establishing itself. Hence let's try to connect.", this._context.connectionId, this.name, this.address);
                    // attempt creating a connection
                    this.isConnecting = true;
                    yield this._negotiateClaim();
                    if (!options) {
                        const receiverOptions = {
                            onClose: (context) => this._onAmqpClose(context),
                            onError: (context) => this._onAmqpError(context),
                            onMessage: (context) => this._onAmqpMessage(context),
                            onSessionClose: (context) => this._onAmqpSessionClose(context),
                            onSessionError: (context) => this._onAmqpSessionError(context)
                        };
                        if (this.checkpoint > -1) {
                            receiverOptions.eventPosition = EventPosition.fromSequenceNumber(this.checkpoint);
                        }
                        options = this._createReceiverOptions(receiverOptions);
                    }
                    error("[%s] Trying to create receiver '%s' with options %O", this._context.connectionId, this.name, options);
                    this._receiver = yield this._context.connection.createReceiver(options);
                    this.isConnecting = false;
                    error("[%s] Receiver '%s' with address '%s' has established itself.", this._context.connectionId, this.name, this.address);
                    receiver("Promise to create the receiver resolved. Created receiver with name: ", this.name);
                    receiver("[%s] Receiver '%s' created with receiver options: %O", this._context.connectionId, this.name, options);
                    // store the underlying link in a cache
                    this._context.receivers[this.name] = this;
                    yield this._ensureTokenRenewal();
                }
                else {
                    error("[%s] The receiver '%s' with address '%s' is open -> %s and is connecting " +
                        "-> %s. Hence not reconnecting.", this._context.connectionId, this.name, this.address, this.isOpen(), this.isConnecting);
                }
            }
            catch (err) {
                this.isConnecting = false;
                const error$1 = coreAmqp.translate(err);
                error("[%s] An error occured while creating the receiver '%s': %O", this._context.connectionId, this.name, error$1);
                throw error$1;
            }
        });
    }
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     * @ignore
     */
    _createReceiverOptions(options) {
        if (options.newName)
            this.name = v4_1();
        const rcvrOptions = {
            name: this.name,
            autoaccept: true,
            source: {
                address: this.address
            },
            credit_window: 0,
            onMessage: options.onMessage || ((context) => this._onAmqpMessage(context)),
            onError: options.onError || ((context) => this._onAmqpError(context)),
            onClose: options.onClose || ((context) => this._onAmqpClose(context)),
            onSessionError: options.onSessionError || ((context) => this._onAmqpSessionError(context)),
            onSessionClose: options.onSessionClose || ((context) => this._onAmqpSessionClose(context))
        };
        if (typeof this.ownerLevel === "number") {
            rcvrOptions.properties = {
                [coreAmqp.Constants.attachEpoch]: rheaPromise.types.wrap_long(this.ownerLevel)
            };
        }
        if (this.options.trackLastEnqueuedEventInfo) {
            rcvrOptions.desired_capabilities = coreAmqp.Constants.enableReceiverRuntimeMetricName;
        }
        const eventPosition = options.eventPosition || this.eventPosition;
        if (eventPosition) {
            // Set filter on the receiver if event position is specified.
            const filterClause = getEventPositionFilter(eventPosition);
            if (filterClause) {
                rcvrOptions.source.filter = {
                    "apache.org:selector-filter:string": rheaPromise.types.wrap_described(filterClause, 0x468c00000004)
                };
            }
        }
        return rcvrOptions;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * A consumer is responsible for reading `EventData` from a specific Event Hub partition
 * in the context of a specific consumer group.
 * To create a consumer use the `createConsumer()` method on your `EventHubClient`.
 *
 * You can pass the below in the `options` when creating a consumer.
 * - `ownerLevel`  : A number indicating that the consumer intends to be an exclusive consumer of events resulting in other
 * consumers to fail if their `ownerLevel` is lower or doesn't exist.
 * - `retryOptions`: The retry options used to govern retry attempts when an issue is encountered while receiving events.
 *
 * Multiple consumers are allowed on the same partition in a consumer group.
 * If there is a need to have an exclusive consumer for a partition in a consumer group,
 * then specify the `ownerLevel` in the `options`.
 * Exclusive consumers were previously referred to as "Epoch Receivers".
 *
 * The consumer can be used to receive messages in a batch using `receiveBatch()` or by registering handlers
 * by using `receive()` or via an async iterable got by using `getEventIterator()`
 * @class
 */
class EventHubConsumer {
    /**
     * EventHubConsumer should not be constructed using `new EventHubConsumer()`
     * Use the `createConsumer()` method on your `EventHubClient` instead.
     * @private
     * @constructor
     * @internal
     * @ignore
     */
    constructor(context, consumerGroup, partitionId, eventPosition, options) {
        /**
         * @property Denotes if close() was called on this receiver
         */
        this._isClosed = false;
        this._context = context;
        this._consumerGroup = consumerGroup;
        this._partitionId = partitionId;
        this._lastEnqueuedEventInfo = {};
        this._receiverOptions = options || {};
        this._retryOptions = this._receiverOptions.retryOptions || {};
        this._baseConsumer = new EventHubReceiver(context, consumerGroup, partitionId, eventPosition, options);
    }
    /**
     * @property The last enqueued event information. This property will only
     * be enabled when `trackLastEnqueuedEventInfo` option is set to true in the
     * `client.createConsumer()` method.
     * @readonly
     */
    get lastEnqueuedEventInfo() {
        return this._lastEnqueuedEventInfo;
    }
    /**
     * @property Returns `true` if the consumer is closed. This can happen either because the consumer
     * itself has been closed or the client that created it has been closed.
     * @readonly
     */
    get isClosed() {
        return this._isClosed || this._context.wasConnectionCloseCalled;
    }
    /**
     * @property The identifier of the Event Hub partition that this consumer is associated with.
     * Events will be read only from this partition.
     * @readonly
     */
    get partitionId() {
        return this._partitionId;
    }
    /**
     * @property The name of the consumer group that this consumer is associated with.
     * Events will be read only in the context of this group.
     * @readonly
     */
    get consumerGroup() {
        return this._consumerGroup;
    }
    /**
     * @property The owner level associated with an exclusive consumer; for a non-exclusive consumer, this value will be null or undefined.
     *
     * When provided, the owner level indicates that a consumer is intended to be the exclusive receiver of events for the
     * requested partition and the associated consumer group.
     * When multiple consumers exist for the same partition/consumer group pair, then the ones with lower or no
     * `ownerLevel` will get a `ReceiverDisconnectedError` during the next attempted receive operation.
     * @readonly
     */
    get ownerLevel() {
        return this._receiverOptions.ownerLevel;
    }
    /**
     * Indicates whether the consumer is currently receiving messages or not.
     * When this returns true, new `receive()` or `receiveBatch()` calls cannot be made.
     */
    get isReceivingMessages() {
        return Boolean(this._baseConsumer && this._baseConsumer.isReceivingMessages);
    }
    /**
     * Starts receiving events from the service and calls the user provided message handler for each event.
     * Returns an object that can be used to query the state of the receiver and to stop receiving events as well.
     *
     * @param onMessage The message handler to receive event data objects.
     * @param onError The error handler for errora that can occur when receiving events.
     * @param abortSignal An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     * @returns ReceiveHandler - An object that provides a mechanism to stop receiving more messages.
     * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.
     * @throws {TypeError} Thrown if a required parameter is missing.
     * @throws {Error} Thrown if the underlying connection or receiver has been closed.
     * Create a new EventHubConsumer using the EventHubClient createConsumer method.
     * @throws {Error} Thrown if the receiver is already receiving messages.
     */
    receive(onMessage, onError, abortSignal) {
        this._throwIfReceiverOrConnectionClosed();
        this._throwIfAlreadyReceiving();
        const baseConsumer = this._baseConsumer;
        if (typeof onMessage !== "function") {
            throw new TypeError("The parameter 'onMessage' must be of type 'function'.");
        }
        if (typeof onError !== "function") {
            throw new TypeError("The parameter 'onError' must be of type 'function'.");
        }
        // return immediately if the abortSignal is already aborted.
        if (abortSignal && abortSignal.aborted) {
            onError(new abortController.AbortError("The receive operation has been cancelled by the user."));
            // close this receiver when user triggers a cancellation.
            this.close().catch(() => { }); // no-op close error handler
            return new ReceiveHandler(baseConsumer);
        }
        const wrappedOnError = (error$1) => {
            // ignore retryable errors
            if (error$1.retryable) {
                return;
            }
            error("[%s] Since the error is not retryable, we let the user know about it by calling the user's error handler.", this._context.connectionId);
            if (error$1.name === "AbortError") {
                // close this receiver when user triggers a cancellation.
                this.close().catch(() => { }); // no-op close error handler
            }
            onError(error$1);
        };
        const onAbort = () => {
            if (this._baseConsumer) {
                this._baseConsumer.abort();
            }
        };
        baseConsumer.registerHandlers(onMessage, wrappedOnError, coreAmqp.Constants.defaultPrefetchCount, true, abortSignal, onAbort);
        if (this._receiverOptions.trackLastEnqueuedEventInfo &&
            this._baseConsumer &&
            this._baseConsumer.runtimeInfo) {
            this._lastEnqueuedEventInfo = this._baseConsumer.runtimeInfo;
        }
        return new ReceiveHandler(baseConsumer);
    }
    /**
     * Returns an async iterable that retrieves events.
     *
     * The async iterable cannot indicate that it is done.
     * When using `for await (let event of consumer.getEventIterator()) {}` to iterate over the events returned
     * by the async iterable, take care to exit the for loop after receiving the
     * desired number of messages, or provide an `AbortSignal` to control when to exit the loop.
     *
     * @param [options] A set of options to apply to an event iterator.
     */
    getEventIterator(options = {}) {
        return tslib_1.__asyncGenerator(this, arguments, function* getEventIterator_1() {
            const maxMessageCount = 1;
            const maxWaitTimeInSeconds = coreAmqp.Constants.defaultOperationTimeoutInMs / 1000;
            while (true) {
                const currentBatch = yield tslib_1.__await(this.receiveBatch(maxMessageCount, maxWaitTimeInSeconds, options.abortSignal));
                if (!currentBatch || !currentBatch.length) {
                    continue;
                }
                yield yield tslib_1.__await(currentBatch[0]);
            }
        });
    }
    /**
     * Returns a promise that resolves to an array of events received from the service.
     *
     * @param maxMessageCount The maximum number of messages to receive.
     * @param maxWaitTimeInSeconds The maximum amount of time to wait to build up the requested message count;
     * If not provided, it defaults to 60 seconds.
     * @param abortSignal An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @returns Promise<ReceivedEventData[]>.
     * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.
     * @throws {MessagingError} Thrown if an error is encountered while receiving a message.
     * @throws {Error} Thrown if the underlying connection or receiver has been closed.
     * Create a new EventHubConsumer using the EventHubClient createConsumer method.
     * @throws {Error} Thrown if the receiver is already receiving messages.
     */
    receiveBatch(maxMessageCount, maxWaitTimeInSeconds = 60, abortSignal) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._throwIfReceiverOrConnectionClosed();
            this._throwIfAlreadyReceiving();
            // store events across multiple retries
            const receivedEvents = [];
            const retrieveEvents = () => {
                return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    // if this consumer was closed, _baseConsumer might be undefined.
                    // resolve the operation's promise with the events collected thus far in case
                    // the promise hasn't already been resolved.
                    if (!this._baseConsumer) {
                        return resolve(receivedEvents);
                    }
                    let timer;
                    const logOnAbort = () => {
                        const baseConsumer = this._baseConsumer;
                        const name = baseConsumer && baseConsumer.name;
                        const address = baseConsumer && baseConsumer.address;
                        const desc = `[${this._context.connectionId}] The request operation on the Receiver "${name}" with ` +
                            `address "${address}" has been cancelled by the user.`;
                        error(desc);
                    };
                    const rejectOnAbort = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        logOnAbort();
                        try {
                            yield this.close();
                        }
                        finally {
                            return reject(new abortController.AbortError("The receive operation has been cancelled by the user."));
                        }
                    });
                    // operation has been cancelled, so exit immediately
                    if (abortSignal && abortSignal.aborted) {
                        return yield rejectOnAbort();
                    }
                    // updates the prefetch count so that the baseConsumer adds
                    // the correct number of credits to receive the same number of events.
                    const prefetchCount = Math.max(maxMessageCount - receivedEvents.length, 0);
                    if (prefetchCount === 0) {
                        return resolve(receivedEvents);
                    }
                    batching("[%s] Receiver '%s', setting the prefetch count to %d.", this._context.connectionId, this._baseConsumer && this._baseConsumer.name, prefetchCount);
                    const cleanUpBeforeReturn = () => {
                        if (this._baseConsumer) {
                            this._baseConsumer.clearHandlers();
                        }
                        clearTimeout(timer);
                    };
                    const onAbort = () => {
                        clearTimeout(timer);
                        rejectOnAbort();
                    };
                    this._baseConsumer.registerHandlers((eventData) => {
                        receivedEvents.push(eventData);
                        if (this._receiverOptions.trackLastEnqueuedEventInfo &&
                            this._baseConsumer &&
                            this._baseConsumer.runtimeInfo) {
                            this._lastEnqueuedEventInfo = this._baseConsumer.runtimeInfo;
                        }
                        // resolve the operation's promise after the requested
                        // number of events are received.
                        if (receivedEvents.length === maxMessageCount) {
                            batching("[%s] Batching Receiver '%s', %d messages received within %d seconds.", this._context.connectionId, this._baseConsumer && this._baseConsumer.name, receivedEvents.length, maxWaitTimeInSeconds);
                            cleanUpBeforeReturn();
                            resolve(receivedEvents);
                        }
                    }, (err) => {
                        cleanUpBeforeReturn();
                        if (err.name === "AbortError") {
                            rejectOnAbort();
                        }
                        else {
                            reject(err);
                        }
                    }, maxMessageCount - receivedEvents.length, false, abortSignal, onAbort);
                    const addTimeout = () => {
                        const msg = "[%s] Setting the wait timer for %d seconds for receiver '%s'.";
                        batching(msg, this._context.connectionId, maxWaitTimeInSeconds, this._baseConsumer && this._baseConsumer.name);
                        // resolve the operation's promise after the requested
                        // max number of seconds have passed.
                        timer = setTimeout(() => {
                            batching("[%s] Batching Receiver '%s', %d messages received when max wait time in seconds %d is over.", this._context.connectionId, this._baseConsumer && this._baseConsumer.name, receivedEvents.length, maxWaitTimeInSeconds);
                            cleanUpBeforeReturn();
                            resolve(receivedEvents);
                        }, maxWaitTimeInSeconds * 1000);
                    };
                    addTimeout();
                    if (abortSignal && !abortSignal.aborted) {
                        abortSignal.addEventListener("abort", onAbort);
                    }
                }));
            };
            const retryOptions = this._retryOptions;
            const config = {
                connectionHost: this._context.config.host,
                connectionId: this._context.connectionId,
                operation: retrieveEvents,
                operationType: coreAmqp.RetryOperationType.receiveMessage,
                abortSignal: abortSignal,
                retryOptions: retryOptions
            };
            return coreAmqp.retry(config);
        });
    }
    /**
     * Closes the underlying AMQP receiver link.
     * Once closed, the consumer cannot be used for any further operations.
     * Use the `createConsumer` function on the EventHubClient to instantiate
     * a new EventHubConsumer.
     *
     * @returns
     * @throws {Error} Thrown if the underlying connection encounters an error while closing.
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._context.connection && this._context.connection.isOpen()) {
                    if (this._baseConsumer) {
                        yield this._baseConsumer.close();
                        this._baseConsumer = void 0;
                    }
                }
            }
            catch (err) {
                throw err;
            }
            finally {
                this._isClosed = true;
            }
        });
    }
    _throwIfAlreadyReceiving() {
        if (this.isReceivingMessages) {
            const errorMessage = `The EventHubConsumer for "${this._context.config.entityPath}" is already receiving messages.`;
            const error$1 = new Error(errorMessage);
            error(`[${this._context.connectionId}] %O`, error$1);
            throw error$1;
        }
    }
    _throwIfReceiverOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context);
        if (!this._baseConsumer || this.isClosed) {
            const errorMessage = `The EventHubConsumer for "${this._context.config.entityPath}" has been closed and can no longer be used. ` +
                `Please create a new EventHubConsumer using the "createConsumer" function on the EventHubClient.`;
            const error$1 = new Error(errorMessage);
            error(`[${this._context.connectionId}] %O`, error$1);
            throw error$1;
        }
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @internal
 * @ignore
 */
function getRetryAttemptTimeoutInMs(retryOptions) {
    const timeoutInMs = retryOptions == undefined ||
        typeof retryOptions.timeoutInMs !== "number" ||
        !isFinite(retryOptions.timeoutInMs) ||
        retryOptions.timeoutInMs < coreAmqp.Constants.defaultOperationTimeoutInMs
        ? coreAmqp.Constants.defaultOperationTimeoutInMs
        : retryOptions.timeoutInMs;
    return timeoutInMs;
}
/**
 * @class
 * The client is the main point of interaction with Azure Event Hubs service.
 * It offers connection to a specific Event Hub within the Event Hubs namespace along with
 * operations for sending event data, receiving events, and inspecting the connected Event Hub.
 *
 * There are multiple ways to create an `EventHubClient`
 * - Use the connection string from the SAS policy created for your Event Hub instance.
 * - Use the connection string from the SAS policy created for your Event Hub namespace,
 * and the name of the Event Hub instance
 * - Use the fully qualified domain name of your Event Hub namespace like `<yournamespace>.servicebus.windows.net`,
 * and a credentials object.
 *
 */
class EventHubClient {
    constructor(hostOrConnectionString, eventHubNameOrOptions, credentialOrOptions, options) {
        let connectionString;
        let config;
        let credential;
        hostOrConnectionString = String(hostOrConnectionString);
        if (!coreAmqp.isTokenCredential(credentialOrOptions)) {
            const parsedCS = coreAmqp.parseConnectionString(hostOrConnectionString);
            if (!(parsedCS.EntityPath ||
                (typeof eventHubNameOrOptions === "string" && eventHubNameOrOptions))) {
                throw new TypeError(`Either provide "eventHubName" or the "connectionString": "${hostOrConnectionString}", ` +
                    `must contain "EntityPath=<your-event-hub-name>".`);
            }
            if (parsedCS.EntityPath &&
                typeof eventHubNameOrOptions === "string" &&
                eventHubNameOrOptions &&
                parsedCS.EntityPath !== eventHubNameOrOptions) {
                throw new TypeError(`The entity path "${parsedCS.EntityPath}" in connectionString: "${hostOrConnectionString}" ` +
                    `doesn't match with eventHubName: "${eventHubNameOrOptions}".`);
            }
            connectionString = hostOrConnectionString;
            if (typeof eventHubNameOrOptions !== "string") {
                // connectionstring and/or options were passed to constructor
                config = coreAmqp.EventHubConnectionConfig.create(connectionString);
                options = eventHubNameOrOptions;
            }
            else {
                // connectionstring, eventHubName and/or options were passed to constructor
                const eventHubName = eventHubNameOrOptions;
                config = coreAmqp.EventHubConnectionConfig.create(connectionString, eventHubName);
                options = credentialOrOptions;
            }
            // Since connectionstring was passed, create a SharedKeyCredential
            credential = new coreAmqp.SharedKeyCredential(config.sharedAccessKeyName, config.sharedAccessKey);
        }
        else {
            // host, eventHubName, a TokenCredential and/or options were passed to constructor
            const eventHubName = eventHubNameOrOptions;
            let host = hostOrConnectionString;
            credential = credentialOrOptions;
            if (!eventHubName) {
                throw new TypeError(`"eventHubName" is missing`);
            }
            if (!host.endsWith("/"))
                host += "/";
            connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;EntityPath=${eventHubName}`;
            config = coreAmqp.EventHubConnectionConfig.create(connectionString);
        }
        coreAmqp.ConnectionConfig.validate(config);
        this._endpoint = config.endpoint;
        this._clientOptions = options || {};
        this._context = ConnectionContext.create(config, credential, this._clientOptions);
    }
    /**
     * @property
     * @readonly
     * The name of the Event Hub instance for which this client is created.
     */
    get eventHubName() {
        return this._context.config.entityPath;
    }
    /**
     * @property
     * @readonly
     * The fully qualified Event Hubs namespace for which this client is created. This is likely to be similar to
     * <yournamespace>.servicebus.windows.net.
     */
    get fullyQualifiedNamespace() {
        return this._context.config.host;
    }
    _createClientSpan(operationName, parentSpan) {
        const tracer = coreTracing.getTracer();
        const span = tracer.startSpan(`Azure.EventHubs.${operationName}`, {
            kind: coreTracing.SpanKind.CLIENT,
            parent: parentSpan
        });
        span.setAttribute("component", "eventhubs");
        span.setAttribute("message_bus.destination", this.eventHubName);
        span.setAttribute("peer.address", this._endpoint);
        return span;
    }
    /**
     * Closes the AMQP connection to the Event Hub instance,
     * returning a promise that will be resolved when disconnection is completed.
     * @returns Promise<void>
     * @throws {Error} Thrown if the underlying connection encounters an error while closing.
     */
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._context.connection.isOpen()) {
                    // Close all the senders.
                    for (const senderName of Object.keys(this._context.senders)) {
                        yield this._context.senders[senderName].close();
                    }
                    // Close all the receivers.
                    for (const receiverName of Object.keys(this._context.receivers)) {
                        yield this._context.receivers[receiverName].close();
                    }
                    // Close the cbs session;
                    yield this._context.cbsSession.close();
                    // Close the management session
                    yield this._context.managementSession.close();
                    yield this._context.connection.close();
                    this._context.wasConnectionCloseCalled = true;
                    client("Closed the amqp connection '%s' on the client.", this._context.connectionId);
                }
            }
            catch (err) {
                err = err instanceof Error ? err : JSON.stringify(err);
                error(`An error occurred while closing the connection "${this._context.connectionId}":\n${err}`);
                throw err;
            }
        });
    }
    /**
     * Creates an Event Hub producer that can send events to the Event Hub.
     * If `partitionId` is specified in the `options`, all event data sent using the producer
     * will be sent to the specified partition.
     * Otherwise, they are automatically routed to an available partition by the Event Hubs service.
     *
     * Automatic routing of partitions is recommended because:
     *  - The sending of events will be highly available.
     *  - The event data will be evenly distributed among all available partitions.
     *
     * @param options The set of options to apply when creating the producer.
     * - `partitionId`  : The identifier of the partition that the producer can be bound to.
     * - `retryOptions` : The retry options used to govern retry attempts when an issue is encountered while sending events.
     * A simple usage can be `{ "maxRetries": 4 }`.
     *
     * @throws {Error} Thrown if the underlying connection has been closed, create a new EventHubClient.
     * @returns EventHubProducer
     */
    createProducer(options) {
        if (!options) {
            options = {};
        }
        if (!options.retryOptions) {
            options.retryOptions = this._clientOptions.retryOptions;
        }
        throwErrorIfConnectionClosed(this._context);
        return new EventHubProducer(this.eventHubName, this._endpoint, this._context, options);
    }
    /**
     * Creates an Event Hub consumer that can receive events from a specific Event Hub partition,
     * in the context of a specific consumer group.
     *
     * Multiple consumers are allowed on the same partition in a consumer group.
     * If there is a need to have an exclusive consumer for a partition in a consumer group,
     * then specify the `ownerLevel` in the `options`.
     * Exclusive consumers were previously referred to as "Epoch Receivers".
     *
     * @param consumerGroup The name of the consumer group this consumer is associated with.
     * Events are read in the context of this group. You can get this information from Azure portal.
     * @param partitionId The identifier of the Event Hub partition from which events will be received.
     * You can get identifiers for all partitions by using the `getPartitionProperties` method on the `EventHubClient`.
     * @param eventPosition The position within the partition where the consumer should begin reading events.
     * The easiest way to create an instance of EventPosition is to use the static helpers on it like
     * - `EventPosition.fromOffset()`
     * - `EventPosition.fromSequenceNumber()`
     * - `EventPosition.fromEnqueuedTime()`
     * - `EventPosition.earliest()`
     * - `EventPosition.latest()`
     * @param options The set of options to apply when creating the consumer.
     * - `ownerLevel`  : A number indicating that the consumer intends to be an exclusive consumer of events resulting in other
     * consumers to fail if their `ownerLevel` is lower or doesn't exist.
     * - `retryOptions`: The retry options used to govern retry attempts when an issue is encountered while receiving events.
     * A simple usage can be `{ "maxRetries": 4 }`.
     *
     * @throws {Error} Thrown if the underlying connection has been closed, create a new EventHubClient.
     * @throws {TypeError} Thrown if a required parameter is missing.
     */
    createConsumer(consumerGroup, partitionId, eventPosition, options) {
        if (!options) {
            options = {};
        }
        if (!options.retryOptions) {
            options.retryOptions = this._clientOptions.retryOptions;
        }
        throwErrorIfConnectionClosed(this._context);
        throwTypeErrorIfParameterMissing(this._context.connectionId, "consumerGroup", consumerGroup);
        throwTypeErrorIfParameterMissing(this._context.connectionId, "partitionId", partitionId);
        throwTypeErrorIfParameterMissing(this._context.connectionId, "eventPosition", eventPosition);
        partitionId = String(partitionId);
        return new EventHubConsumer(this._context, consumerGroup, partitionId, eventPosition, options);
    }
    /**
     * Provides the Event Hub runtime information.
     * @param [options] The set of options to apply to the operation call.
     * @returns A promise that resolves with EventHubProperties.
     * @throws {Error} Thrown if the underlying connection has been closed, create a new EventHubClient.
     * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.
     */
    getProperties(options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            const clientSpan = this._createClientSpan("getProperties", options.parentSpan);
            try {
                const result = yield this._context.managementSession.getHubRuntimeInformation({
                    retryOptions: this._clientOptions.retryOptions,
                    abortSignal: options.abortSignal
                });
                clientSpan.setStatus({ code: coreTracing.CanonicalCode.OK });
                return result;
            }
            catch (err) {
                clientSpan.setStatus({
                    code: coreTracing.CanonicalCode.UNKNOWN,
                    message: err.message
                });
                error("An error occurred while getting the hub runtime information: %O", err);
                throw err;
            }
            finally {
                clientSpan.end();
            }
        });
    }
    /**
     * Provides an array of partitionIds.
     * @param [options] The set of options to apply to the operation call.
     * @returns A promise that resolves with an Array of strings.
     * @throws {Error} Thrown if the underlying connection has been closed, create a new EventHubClient.
     * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.
     */
    getPartitionIds(options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            const clientSpan = this._createClientSpan("getPartitionIds", options.parentSpan);
            try {
                const runtimeInfo = yield this.getProperties(Object.assign({}, options, { parentSpan: clientSpan }));
                clientSpan.setStatus({ code: coreTracing.CanonicalCode.OK });
                return runtimeInfo.partitionIds;
            }
            catch (err) {
                clientSpan.setStatus({
                    code: coreTracing.CanonicalCode.UNKNOWN,
                    message: err.message
                });
                error("An error occurred while getting the partition ids: %O", err);
                throw err;
            }
            finally {
                clientSpan.end();
            }
        });
    }
    /**
     * Provides information about the specified partition.
     * @param partitionId Partition ID for which partition information is required.
     * @param [options] The set of options to apply to the operation call.
     * @returns A promise that resoloves with PartitionProperties.
     * @throws {Error} Thrown if the underlying connection has been closed, create a new EventHubClient.
     * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.
     */
    getPartitionProperties(partitionId, options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throwErrorIfConnectionClosed(this._context);
            throwTypeErrorIfParameterMissing(this._context.connectionId, "partitionId", partitionId);
            partitionId = String(partitionId);
            const clientSpan = this._createClientSpan("getPartitionProperties", options.parentSpan);
            try {
                const result = yield this._context.managementSession.getPartitionProperties(partitionId, {
                    retryOptions: this._clientOptions.retryOptions,
                    abortSignal: options.abortSignal
                });
                clientSpan.setStatus({ code: coreTracing.CanonicalCode.OK });
                return result;
            }
            catch (err) {
                clientSpan.setStatus({
                    code: coreTracing.CanonicalCode.UNKNOWN,
                    message: err.message
                });
                error("An error occurred while getting the partition information: %O", err);
                throw err;
            }
            finally {
                clientSpan.end();
            }
        });
    }
}
/**
 * @property
 * The name of the default consumer group in the Event Hubs service.
 */
EventHubClient.defaultConsumerGroupName = coreAmqp.Constants.defaultConsumerGroup;

// Copyright (c) Microsoft Corporation. All rights reserved.
class PartitionPump {
    constructor(eventHubClient, partitionProcessor, initialEventPosition, options) {
        this._isReceiving = false;
        if (!options)
            options = {};
        this._eventHubClient = eventHubClient;
        this._partitionProcessor = partitionProcessor;
        this._initialEventPosition = initialEventPosition;
        this._processorOptions = options;
        this._abortController = new abortController.AbortController();
    }
    get isReceiving() {
        return this._isReceiving;
    }
    start() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._isReceiving = true;
            try {
                yield this._partitionProcessor.initialize();
            }
            catch (_a) {
                // swallow the error from the user-defined code
            }
            this._receiveEvents(this._partitionProcessor.partitionId);
            partitionPump("Successfully started the receiver.");
        });
    }
    _receiveEvents(partitionId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._receiver = this._eventHubClient.createConsumer(this._partitionProcessor.consumerGroupName, partitionId, this._initialEventPosition, {
                ownerLevel: 0,
                trackLastEnqueuedEventInfo: this._processorOptions.trackLastEnqueuedEventInfo
            });
            while (this._isReceiving) {
                try {
                    const receivedEvents = yield this._receiver.receiveBatch(this._processorOptions.maxBatchSize || 1, this._processorOptions.maxWaitTimeInSeconds, this._abortController.signal);
                    if (this._processorOptions.trackLastEnqueuedEventInfo &&
                        this._receiver.lastEnqueuedEventInfo) {
                        this._partitionProcessor.lastEnqueuedEventInfo = this._receiver.lastEnqueuedEventInfo;
                    }
                    // avoid calling user's processEvents handler if the pump was stopped while receiving events
                    if (!this._isReceiving) {
                        return;
                    }
                    yield this._partitionProcessor.processEvents(receivedEvents);
                }
                catch (err) {
                    // check if this pump is still receiving
                    // it may not be if the EventProcessor was stopped during processEvents
                    if (!this._isReceiving) {
                        // no longer receiving, so close was called from somewhere else
                        return;
                    }
                    // forward error to user's processError and swallow errors they may throw
                    try {
                        yield this._partitionProcessor.processError(err);
                    }
                    catch (err) {
                        error("An error was thrown by user's processError method: ", err);
                    }
                    // close the partition processor if a non-retryable error was encountered
                    if (typeof err !== "object" || !err.retryable) {
                        try {
                            // If the exception indicates that the partition was stolen (i.e some other consumer with same ownerlevel
                            // started consuming the partition), update the closeReason
                            if (err.name === "ReceiverDisconnectedError") {
                                return yield this.stop(exports.CloseReason.OwnershipLost);
                            }
                            // this will close the pump and will break us out of the while loop
                            return yield this.stop(exports.CloseReason.Shutdown);
                        }
                        catch (err) {
                            error(`An error occurred while closing the receiver with reason ${exports.CloseReason.Shutdown}: `, err);
                        }
                    }
                }
            }
        });
    }
    stop(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._isReceiving = false;
            try {
                if (this._receiver) {
                    yield this._receiver.close();
                }
                this._abortController.abort();
                yield this._partitionProcessor.close(reason);
            }
            catch (err) {
                error("An error occurred while closing the receiver.", err);
                throw err;
            }
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * The PumpManager handles the creation and removal of PartitionPumps.
 * It also starts a PartitionPump when it is created, and stops a
 * PartitionPump when it is removed.
 * @ignore
 */
class PumpManager {
    /**
     * @ignore
     */
    constructor(eventProcessorName, eventProcessorOptions = {}) {
        this._partitionIdToPumps = {};
        this._eventProcessorName = eventProcessorName;
        this._options = eventProcessorOptions;
    }
    /**
     * Returns a list of partitionIds that are actively receiving messages.
     * @ignore
     */
    receivingFromPartitions() {
        return Object.keys(this._partitionIdToPumps).filter((id) => {
            const pump = this._partitionIdToPumps[id];
            return Boolean(pump && pump.isReceiving);
        });
    }
    /**
     * Creates and starts a PartitionPump.
     * @param eventHubClient The EventHubClient to forward to the PartitionPump.
     * @param initialEventPosition The EventPosition to forward to the PartitionPump.
     * @param partitionProcessor The PartitionProcessor to forward to the PartitionPump.
     * @param abortSignal Used to cancel pump creation.
     * @ignore
     */
    createPump(eventHubClient, initialEventPosition, partitionProcessor) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const partitionId = partitionProcessor.partitionId;
            // attempt to get an existing pump
            const existingPump = this._partitionIdToPumps[partitionId];
            if (existingPump) {
                if (existingPump.isReceiving) {
                    pumpManager(`[${this._eventProcessorName}] [${partitionId}] The existing pump is running.`);
                    return;
                }
                pumpManager(`[${this._eventProcessorName}] [${partitionId}] The existing pump is not running.`);
                yield this.removePump(partitionId, exports.CloseReason.OwnershipLost);
            }
            pumpManager(`[${this._eventProcessorName}] [${partitionId}] Creating a new pump.`);
            const pump = new PartitionPump(eventHubClient, partitionProcessor, initialEventPosition, this._options);
            try {
                yield pump.start();
                this._partitionIdToPumps[partitionId] = pump;
            }
            catch (err) {
                error(`[${this._eventProcessorName}] [${partitionId}] An error occured while adding/updating a pump: ${err}`);
            }
        });
    }
    /**
     * Stop a PartitionPump and removes it from the internal map.
     * @param partitionId The partitionId to remove the associated PartitionPump from.
     * @param reason The reason for removing the pump.
     * @ignore
     */
    removePump(partitionId, reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const pump = this._partitionIdToPumps[partitionId];
                if (pump) {
                    delete this._partitionIdToPumps[partitionId];
                    pumpManager(`[${this._eventProcessorName}] [${partitionId}] Stopping the pump.`);
                    yield pump.stop(reason);
                }
                else {
                    pumpManager(`[${this._eventProcessorName}] [${partitionId}] No pump was found to remove.`);
                }
            }
            catch (err) {
                error(`[${this._eventProcessorName}] [${partitionId}] An error occured while removing a pump: ${err}`);
            }
        });
    }
    /**
     * Stops all PartitionPumps and removes them from the internal map.
     * @param reason The reason for removing the pump.
     * @ignore
     */
    removeAllPumps(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const partitionIds = Object.keys(this._partitionIdToPumps);
            pumpManager(`[${this._eventProcessorName}] Removing all pumps due to reason ${reason}.`);
            const tasks = [];
            for (const partitionId of partitionIds) {
                const pump = this._partitionIdToPumps[partitionId];
                if (pump) {
                    tasks.push(pump.stop(reason));
                }
            }
            try {
                yield Promise.all(tasks);
            }
            catch (err) {
                error(`[${this._eventProcessorName}] An error occured while removing all pumps: ${err}`);
            }
            finally {
                this._partitionIdToPumps = {};
            }
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * This class is responsible for balancing the load of processing events from all partitions of an Event Hub by
 * distributing the number of partitions uniformly among all the active EventProcessors.
 *
 * This load balancer will retrieve partition ownership details from the PartitionManager to find the number of
 * active EventProcessor. It uses the last modified time to decide if an EventProcessor is active. If a
 * partition ownership entry has not be updated for a specified duration of time, the owner of that partition is
 * considered inactive and the partition is available for other EventProcessors to own.
 * @class PartitionLoadBalancer
 */
class PartitionLoadBalancer {
    /**
     * Creates an instance of PartitionBasedLoadBalancer.
     *
     * @param ownerId The identifier of the Event Processor that owns this load balancer.
     * @param inactiveTimeLimitInMS The time to wait for an update on an ownership record before
     * assuming the owner of the partition is inactive.
     * */
    constructor(ownerId, inactiveTimeLimitInMS) {
        this._ownerId = ownerId;
        this._inactiveTimeLimitInMS = inactiveTimeLimitInMS;
    }
    /*
     * Find the event processor that owns the maximum number of partitions and steal a random partition
     * from it.
     */
    _findPartitionToSteal(ownerPartitionMap) {
        let maxList = [];
        let maxPartitionsOwnedByAnyEventProcessor = Number.MIN_VALUE;
        let ownerId;
        ownerPartitionMap.forEach((ownershipList, ownerId) => {
            if (ownershipList.length > maxPartitionsOwnedByAnyEventProcessor) {
                maxPartitionsOwnedByAnyEventProcessor = ownershipList.length;
                maxList = ownershipList;
            }
        });
        partitionLoadBalancer(`[${this._ownerId}] Owner id ${ownerId} owns ${maxList.length} partitions, stealing a partition from it.`);
        return maxList[Math.floor(Math.random() * maxList.length)].partitionId;
    }
    /*
     * This method is called after determining that the load is not balanced. This method will evaluate
     * if the current event processor should own more partitions. Specifically, this method returns true if the
     * current event processor owns less than the minimum number of partitions or if it owns the minimum number
     * and no other event processor owns lesser number of partitions than this event processor.
     */
    _shouldOwnMorePartitions(minPartitionsPerEventProcessor, partitionIds, ownerPartitionMap) {
        const numberOfPartitionsOwned = ownerPartitionMap.get(this._ownerId).length;
        let sumOfPartitionsOwnedByAnyProcessor = 0;
        for (const ownershipList of ownerPartitionMap.values()) {
            sumOfPartitionsOwnedByAnyProcessor =
                sumOfPartitionsOwnedByAnyProcessor + ownershipList.length;
        }
        return (numberOfPartitionsOwned < minPartitionsPerEventProcessor ||
            (sumOfPartitionsOwnedByAnyProcessor < partitionIds.length &&
                numberOfPartitionsOwned < minPartitionsPerEventProcessor + 1));
    }
    /*
     * When the load is balanced, all active event processors own at least minPartitionsPerEventProcessor
     * and only numberOfEventProcessorsWithAdditionalPartition event processors will own 1 additional
     * partition.
     */
    _isLoadBalanced(minPartitionsPerEventProcessor, numberOfEventProcessorsWithAdditionalPartition, ownerPartitionMap) {
        let count = 0;
        for (const ownershipList of ownerPartitionMap.values()) {
            const numberOfPartitions = ownershipList.length;
            if (numberOfPartitions < minPartitionsPerEventProcessor ||
                numberOfPartitions > minPartitionsPerEventProcessor + 1) {
                return false;
            }
            if (numberOfPartitions === minPartitionsPerEventProcessor + 1) {
                count++;
            }
        }
        return count === numberOfEventProcessorsWithAdditionalPartition;
    }
    /*
     * This method will create a new map of partition id and PartitionOwnership containing only those partitions
     * that are actively owned. All entries in the original map returned by PartitionManager that haven't been
     * modified for a duration of time greater than the allowed inactivity time limit are assumed to be owned by
     * dead event processors. These will not be included in the map returned by this method.
     */
    _removeInactivePartitionOwnerships(partitionOwnershipMap) {
        const activePartitionOwnershipMap = new Map();
        partitionOwnershipMap.forEach((partitionOwnership, partitionId) => {
            var date = new Date();
            if (partitionOwnership.lastModifiedTimeInMS &&
                date.getTime() - partitionOwnership.lastModifiedTimeInMS < this._inactiveTimeLimitInMS &&
                partitionOwnership.ownerId) {
                activePartitionOwnershipMap.set(partitionId, partitionOwnership);
            }
        });
        return activePartitionOwnershipMap;
    }
    /*
     * This method works with the given partition ownership details and Event Hub partitions to evaluate whether the
     * current Event Processor should take on the responsibility of processing more partitions.
     */
    loadBalance(partitionOwnershipMap, partitionsToAdd) {
        //  Remove all partitions ownership that have not been modified within the configured period of time. This means that the previous
        //  event processor that owned the partition is probably down and the partition is now eligible to be
        //  claimed by other event processors.
        const activePartitionOwnershipMap = this._removeInactivePartitionOwnerships(partitionOwnershipMap);
        partitionLoadBalancer(`[${this._ownerId}] Number of active ownership records: ${activePartitionOwnershipMap.size}.`);
        if (activePartitionOwnershipMap.size === 0) {
            // If the active partition ownership map is empty, this is the first time an event processor is
            // running or all Event Processors are down for this Event Hub, consumer group combination. All
            // partitions in this Event Hub are available to claim. Choose a random partition to claim ownership.
            return partitionsToAdd[Math.floor(Math.random() * partitionsToAdd.length)];
        }
        // Create a map of owner id and a list of partitions it owns
        const ownerPartitionMap = new Map();
        for (const activePartitionOwnership of activePartitionOwnershipMap.values()) {
            const partitionOwnershipArray = ownerPartitionMap.get(activePartitionOwnership.ownerId) || [];
            partitionOwnershipArray.push(activePartitionOwnership);
            ownerPartitionMap.set(activePartitionOwnership.ownerId, partitionOwnershipArray);
        }
        // add the current event processor to the map if it doesn't exist
        if (!ownerPartitionMap.has(this._ownerId)) {
            ownerPartitionMap.set(this._ownerId, []);
        }
        partitionLoadBalancer(`[${this._ownerId}] Number of active event processors: ${ownerPartitionMap.size}.`);
        // Find the minimum number of partitions every event processor should own when the load is
        // evenly distributed.
        const minPartitionsPerEventProcessor = Math.floor(partitionsToAdd.length / ownerPartitionMap.size);
        // If the number of partitions in Event Hub is not evenly divisible by number of active event processors,
        // a few Event Processors may own 1 additional partition than the minimum when the load is balanced. Calculate
        // the number of event processors that can own additional partition.
        const numberOfEventProcessorsWithAdditionalPartition = partitionsToAdd.length % ownerPartitionMap.size;
        partitionLoadBalancer(`[${this._ownerId}] Expected minimum number of partitions per event processor: ${minPartitionsPerEventProcessor}, 
      expected number of event processors with additional partition: ${numberOfEventProcessorsWithAdditionalPartition}.`);
        if (this._isLoadBalanced(minPartitionsPerEventProcessor, numberOfEventProcessorsWithAdditionalPartition, ownerPartitionMap)) {
            partitionLoadBalancer(`[${this._ownerId}] Load is balanced.`);
            // If the partitions are evenly distributed among all active event processors, no change required.
            return "";
        }
        if (!this._shouldOwnMorePartitions(minPartitionsPerEventProcessor, partitionsToAdd, ownerPartitionMap)) {
            partitionLoadBalancer(`[${this._ownerId}] This event processor owns ${ownerPartitionMap.get(this._ownerId).length} partitions and shouldn't own more.`);
            // This event processor already has enough partitions and shouldn't own more yet
            return "";
        }
        partitionLoadBalancer(`[${this._ownerId}] Load is unbalanced and this event processor should own more partitions.`);
        // If we have reached this stage, this event processor has to claim/steal ownership of at least 1 more partition
        //  If some partitions are unclaimed, this could be because an event processor is down and
        //  it's partitions are now available for others to own or because event processors are just
        //  starting up and gradually claiming partitions to own or new partitions were added to Event Hub.
        //  Find any partition that is not actively owned and claim it.
        //   OR
        //  Find a partition to steal from another event processor. Pick the event processor that owns the highest
        //  number of partitions.
        const unOwnedPartitionIds = [];
        let partitionToClaim;
        for (const partitionId of partitionsToAdd) {
            if (!activePartitionOwnershipMap.has(partitionId)) {
                unOwnedPartitionIds.push(partitionId);
            }
        }
        if (unOwnedPartitionIds.length === 0) {
            partitionLoadBalancer(`[${this._ownerId}] No unclaimed partitions, stealing from another event processor.`);
            partitionToClaim = this._findPartitionToSteal(ownerPartitionMap);
        }
        else {
            partitionToClaim =
                unOwnedPartitionIds[Math.floor(Math.random() * unOwnedPartitionIds.length)];
        }
        return partitionToClaim;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
(function (CloseReason) {
    /**
     * Ownership of the partition was lost or transitioned to a new processor instance.
     */
    CloseReason["OwnershipLost"] = "OwnershipLost";
    /**
     * The EventProcessor was shutdown.
     */
    CloseReason["Shutdown"] = "Shutdown";
})(exports.CloseReason || (exports.CloseReason = {}));
/**
 * Event Processor based applications consist of one or more instances of EventProcessor which have been
 * configured to consume events from the same Event Hub and consumer group. They balance the
 * workload across different instances by distributing the partitions to be processed among themselves.
 * They also allow the user to track progress when events are processed using checkpoints.
 *
 * A checkpoint is meant to represent the last successfully processed event by the user from a particular
 * partition of a consumer group in an Event Hub instance.
 *
 * You need the below to create an instance of `EventProcessor`
 * - The name of the consumer group from which you want to process events
 * - An instance of `EventHubClient` class that was created for the Event Hub instance.
 * - A user implemented class that extends the `PartitionProcessor` class. To get started, you can use the
 * base class `PartitionProcessor` which simply logs the incoming events. To provide your code to process incoming
 * events, extend this class and override the `processEvents()` method. For example:
 * ```js
 * class SamplePartitionProcessor extends PartitionProcessor {
 *     async processEvents(events) {
 *        // user code to process events here
 *        // Information on the partition being processed is available as properties on the `SamplePartitionProcessor` class
 *        // use `this.updateCheckpoint()` method to update checkpoints as needed
 *     }
 * }
 * ```
 * - An instance of `PartitionManager`. To get started, you can pass an instance of `InMemoryPartitionManager`.
 * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.
 * Implementations of `PartitionManager` can be found on npm by searching for packages with the prefix &commat;azure/eventhub-checkpointstore-.
 *
 * @class EventProcessor
 */
class EventProcessor {
    /**
     * @param consumerGroupName The name of the consumer group from which you want to process events.
     * @param eventHubClient An instance of `EventHubClient` that was created for the Event Hub instance.
     * @param PartitionProcessorClass A user-provided class that extends the `PartitionProcessor` class.
     * This class will be responsible for processing and checkpointing events.
     * @param partitionManager An instance of `PartitionManager`. To get started, you can pass an instance of `InMemoryPartitionManager`.
     * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.
     * @param options A set of options to configure the Event Processor
     * - `maxBatchSize`         : The max size of the batch of events passed each time to user code for processing.
     * - `maxWaitTimeInSeconds` : The maximum amount of time to wait to build up the requested message count before
     * passing the data to user code for processing. If not provided, it defaults to 60 seconds.
     */
    constructor(consumerGroupName, eventHubClient, PartitionProcessorClass, partitionManager, options) {
        this._id = v4_1();
        this._isRunning = false;
        if (!options)
            options = {};
        this._consumerGroupName = consumerGroupName;
        this._eventHubClient = eventHubClient;
        this._partitionProcessorClass = PartitionProcessorClass;
        this._partitionManager = partitionManager;
        this._processorOptions = options;
        this._pumpManager = new PumpManager(this._id, this._processorOptions);
        const inactiveTimeLimitInMS = 60000; // ownership expiration time (1 mintue)
        this._partitionLoadBalancer = new PartitionLoadBalancer(this._id, inactiveTimeLimitInMS);
    }
    /**
     * The unique identifier for the EventProcessor.
     *
     * @return {string}
     */
    get id() {
        return this._id;
    }
    _createPartitionOwnershipRequest(partitionOwnershipMap, partitionIdToClaim) {
        const previousPartitionOwnership = partitionOwnershipMap.get(partitionIdToClaim);
        const partitionOwnership = {
            ownerId: this._id,
            partitionId: partitionIdToClaim,
            fullyQualifiedNamespace: this._eventHubClient.fullyQualifiedNamespace,
            consumerGroupName: this._consumerGroupName,
            eventHubName: this._eventHubClient.eventHubName,
            sequenceNumber: previousPartitionOwnership
                ? previousPartitionOwnership.sequenceNumber
                : undefined,
            offset: previousPartitionOwnership ? previousPartitionOwnership.offset : undefined,
            eTag: previousPartitionOwnership ? previousPartitionOwnership.eTag : undefined,
            ownerLevel: 0
        };
        return partitionOwnership;
    }
    /*
     * Claim ownership of the given partition if it's available
     */
    _claimOwnership(partitionOwnershipMap, partitionIdToClaim) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            partitionLoadBalancer(`[${this._id}] Attempting to claim ownership of partition ${partitionIdToClaim}.`);
            const ownershipRequest = this._createPartitionOwnershipRequest(partitionOwnershipMap, partitionIdToClaim);
            try {
                yield this._partitionManager.claimOwnership([ownershipRequest]);
                partitionLoadBalancer(`[${this._id}] Successfully claimed ownership of partition ${partitionIdToClaim}.`);
                partitionLoadBalancer(`[${this._id}] [${partitionIdToClaim}] Calling user-provided PartitionProcessorFactory.`);
                const partitionProcessor = new this._partitionProcessorClass();
                partitionProcessor.fullyQualifiedNamespace = this._eventHubClient.fullyQualifiedNamespace;
                partitionProcessor.eventHubName = this._eventHubClient.eventHubName;
                partitionProcessor.consumerGroupName = this._consumerGroupName;
                partitionProcessor.partitionId = ownershipRequest.partitionId;
                partitionProcessor.partitionManager = this._partitionManager;
                partitionProcessor.eventProcessorId = this.id;
                const eventPosition = ownershipRequest.sequenceNumber
                    ? EventPosition.fromSequenceNumber(ownershipRequest.sequenceNumber)
                    : EventPosition.earliest();
                yield this._pumpManager.createPump(this._eventHubClient, eventPosition, partitionProcessor);
                partitionLoadBalancer(`[${this._id}] PartitionPump created successfully.`);
            }
            catch (err) {
                error(`[${this.id}] Failed to claim ownership of partition ${ownershipRequest.partitionId}`);
            }
        });
    }
    /**
     * Every loop to this method will result in this EventProcessor owning at most one new partition.
     *
     * The load is considered balanced when no active EventProcessor owns 2 partitions more than any other active
     * EventProcessor. Given that each invocation to this method results in ownership claim of at most one partition,
     * this algorithm converges gradually towards a steady state.
     *
     * When a new partition is claimed, this method is also responsible for starting a partition pump that creates an
     * EventHubConsumer for processing events from that partition.
     */
    _runLoop(abortSignal) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // periodically check if there is any partition not being processed and process it
            const waitIntervalInMs = 10000;
            while (!abortSignal.aborted) {
                try {
                    const partitionOwnershipMap = new Map();
                    // Retrieve current partition ownership details from the datastore.
                    const partitionOwnership = yield this._partitionManager.listOwnership(this._eventHubClient.fullyQualifiedNamespace, this._eventHubClient.eventHubName, this._consumerGroupName);
                    for (const ownership of partitionOwnership) {
                        partitionOwnershipMap.set(ownership.partitionId, ownership);
                    }
                    const partitionIds = yield this._eventHubClient.getPartitionIds();
                    if (abortSignal.aborted) {
                        return;
                    }
                    if (partitionIds.length > 0) {
                        const partitionToClaim = this._partitionLoadBalancer.loadBalance(partitionOwnershipMap, partitionIds);
                        if (partitionToClaim) {
                            yield this._claimOwnership(partitionOwnershipMap, partitionToClaim);
                        }
                    }
                    // sleep
                    eventProcessor(`[${this._id}] Pausing the EventProcessor loop for ${waitIntervalInMs} ms.`);
                    yield coreAmqp.delay(waitIntervalInMs, abortSignal);
                }
                catch (err) {
                    error(`[${this._id}] An error occured within the EventProcessor loop: ${err}`);
                }
            }
        });
    }
    /**
     * Starts the `EventProcessor`. Based on the number of instances of `EventProcessor` that are running for the
     * same consumer group, the partitions are distributed among these instances to process events.
     *
     * For each partition, the user provided `PartitionProcessor` is instantiated.
     *
     * Subsequent calls to start will be ignored if this event processor is already running.
     * Calling `start()` after `stop()` is called will restart this event processor.
     *
     * @return {void}
     */
    start() {
        if (this._isRunning) {
            eventProcessor(`[${this._id}] Attempted to start an already running EventProcessor.`);
            return;
        }
        this._isRunning = true;
        this._abortController = new abortController.AbortController();
        eventProcessor(`[${this._id}] Starting an EventProcessor.`);
        this._loopTask = this._runLoop(this._abortController.signal);
    }
    /**
     * Stops processing events for all partitions owned by this event processor.
     * All `PartitionProcessor` will be shutdown and any open resources will be closed.
     *
     * Subsequent calls to stop will be ignored if the event processor is not running.
     *
     */
    stop() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            eventProcessor(`[${this._id}] Stopping an EventProcessor.`);
            if (this._abortController) {
                // cancel the event processor loop
                this._abortController.abort();
            }
            this._isRunning = false;
            try {
                // remove all existing pumps
                yield this._pumpManager.removeAllPumps(exports.CloseReason.Shutdown);
                // waits for the event processor loop to complete
                // will complete immediately if _loopTask is undefined
                yield this._loopTask;
            }
            catch (err) {
                error(`[${this._id}] An error occured while stopping the EventProcessor: ${err}`);
            }
            finally {
                eventProcessor(`[${this._id}] EventProcessor stopped.`);
            }
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * The `EventProcessor` relies on a `PartitionManager` to store checkpoints and handle partition
 * ownerships. `InMemoryPartitionManager` is simple partition manager that stores checkpoints and
 * partition ownerships in memory of your program.
 *
 * You can use the `InMemoryPartitionManager` to get started with using the `EventProcessor`.
 * But in production, you should choose an implementation of the `PartitionManager` interface that will
 * store the checkpoints and partition ownerships to a durable store instead.
 *
 * @class
 */
class InMemoryPartitionManager {
    constructor() {
        this._partitionOwnershipMap = new Map();
    }
    /**
     * Get the list of all existing partition ownership from the underlying data store. Could return empty
     * results if there are is no existing ownership information.
     *
     * @param fullyQualifiedNamespace The fully qualified Event Hubs namespace. This is likely to be similar to
     * <yournamespace>.servicebus.windows.net.
     * @param eventHubName The event hub name.
     * @param consumerGroupName The consumer group name.
     * @return Partition ownership details of all the partitions that have/had an owner..
     */
    listOwnership(fullyQualifiedNamespace, eventHubName, consumerGroupName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return Array.from(this._partitionOwnershipMap.values());
        });
    }
    /**
     * Claim ownership of a list of partitions. This will return the list of partitions that were owned
     * successfully.
     *
     * @param partitionOwnership The list of partition ownership this instance is claiming to own.
     * @return A list partitions this instance successfully claimed ownership.
     */
    claimOwnership(partitionOwnership) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            for (const ownership of partitionOwnership) {
                if (!this._partitionOwnershipMap.has(ownership.partitionId) ||
                    this._partitionOwnershipMap.get(ownership.partitionId).eTag === ownership.eTag) {
                    ownership.eTag = rheaPromise.generate_uuid();
                    var date = new Date();
                    ownership.lastModifiedTimeInMS = date.getTime();
                    this._partitionOwnershipMap.set(ownership.partitionId, ownership);
                }
            }
            return partitionOwnership;
        });
    }
    /**
     * Updates the checkpoint in the data store for a partition.
     *
     * @param checkpoint The checkpoint.
     * @return The new eTag on successful update
     */
    updateCheckpoint(checkpoint) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const partitionOwnership = this._partitionOwnershipMap.get(checkpoint.partitionId);
            if (partitionOwnership) {
                partitionOwnership.sequenceNumber = checkpoint.sequenceNumber;
                partitionOwnership.offset = checkpoint.offset;
                partitionOwnership.eTag = rheaPromise.generate_uuid();
                return partitionOwnership.eTag;
            }
            return "";
        });
    }
}

/**
 * The `PartitionProcessor` is responsible for processing events received from Event Hubs when using `EventProcessor`
 *
 * The EventProcessor creates a new instance of the PartitionProcessor for each partition of the event hub it starts processing. When you extend the `PartitionProcessor` in order to customize it as you see fit,
 * - Override the `processEvents()` method to add the code to process the received events. This is also a good place to update the checkpoints using the `updateCheckpoint()` method
 * - Optionally override the `processError()` method to handle any error that might have occurred when processing the events.
 * - Optionally override the `initialize()` method to implement any set up related tasks you would want to carry out before starting to receive events from the partition
 * - Optionally override the `close()` method to implement any tear down or clean up tasks you would want to carry out.
 */
class PartitionProcessor {
    constructor() {
        this._eTag = "";
    }
    /**
     * @property Information on the last enqueued event in the partition that is being processed.
     * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventInfo` option is set to true
     * when creating an instance of EventProcessor
     * @readonly
     */
    get lastEnqueuedEventInfo() {
        return this._lastEnqueuedEventInfo;
    }
    /**
     * @property Information on the last enqueued event in the partition that is being processed.
     * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventInfo` option is set to true
     * when creating an instance of EventProcessor
     */
    set lastEnqueuedEventInfo(lastEnqueuedEventInfo) {
        this._lastEnqueuedEventInfo = lastEnqueuedEventInfo;
    }
    /**
     * @property The fully qualified namespace from where the current partition is being processed. It is set by the `EventProcessor`
     * @readonly
     */
    get fullyQualifiedNamespace() {
        return this._fullyQualifiedNamespace;
    }
    /**
     * @property The fully qualified namespace from where the current partition is being processed. It is set by the `EventProcessor`
     */
    set fullyQualifiedNamespace(fullyQualifiedNamespace) {
        if (!this._fullyQualifiedNamespace) {
            this._fullyQualifiedNamespace = fullyQualifiedNamespace;
        }
    }
    /**
     * @property The name of the consumer group from where the current partition is being processed. It is set by the `EventProcessor`
     * @readonly
     */
    get consumerGroupName() {
        return this._consumerGroupName;
    }
    /**
     * @property The name of the consumer group from where the current partition is being processed. It is set by the `EventProcessor`
     */
    set consumerGroupName(consumerGroupName) {
        if (!this._consumerGroupName) {
            this._consumerGroupName = consumerGroupName;
        }
    }
    /**
     * @property The name of the event hub to which the current partition belongs. It is set by the `EventProcessor`
     * @readonly
     */
    get eventHubName() {
        return this._eventHubName;
    }
    /**
     * @property The name of the event hub to which the current partition belongs. It is set by the `EventProcessor`
     */
    set eventHubName(eventHubName) {
        if (!this._eventHubName) {
            this._eventHubName = eventHubName;
        }
    }
    /**
     * @property The identifier of the Event Hub partition that is being processed. It is set by the `EventProcessor`
     * @readonly
     */
    get partitionId() {
        return this._partitionId;
    }
    /**
     * @property The identifier of the Event Hub partition that is being processed. It is set by the `EventProcessor`
     */
    set partitionId(partitionId) {
        if (!this._partitionId) {
            this._partitionId = partitionId;
        }
    }
    /**
     * @property The unique identifier of the `EventProcessor` that has spawned the current instance of `PartitionProcessor`. This is set by the `EventProcessor`
     */
    set eventProcessorId(eventProcessorId) {
        if (!this._eventProcessorId) {
            this._eventProcessorId = eventProcessorId;
        }
    }
    /**
     * @property The Partition Manager used for checkpointing events. This is set by the `EventProcessor`
     */
    set partitionManager(partitionManager) {
        if (!this._partitionManager) {
            this._partitionManager = partitionManager;
        }
    }
    /**
     * This method is called when the `EventProcessor` takes ownership of a new partition and before any
     * events are received.
     *
     * @return {Promise<void>}
     */
    initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { });
    }
    /**
     * This method is called before the partition processor is closed by the EventProcessor.
     *
     * @param reason The reason for closing this partition processor.
     * @return {Promise<void>}
     */
    close(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { });
    }
    /**
     * This method is called when new events are received.
     *
     * This is also a good place to update checkpoints as appropriate.
     *
     * @param events The received events to be processed.
     * @return {Promise<void>}
     */
    processEvents(events) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { });
    }
    /**
     * This method is called when an error occurs while receiving events from Event Hubs.
     *
     * @param error The error to be processed.
     * @return {Promise<void>}
     */
    processError(error) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { });
    }
    updateCheckpoint(eventDataOrSequenceNumber, offset) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const checkpoint = {
                fullyQualifiedNamespace: this._fullyQualifiedNamespace,
                eventHubName: this._eventHubName,
                consumerGroupName: this._consumerGroupName,
                ownerId: this._eventProcessorId,
                partitionId: this._partitionId,
                sequenceNumber: typeof eventDataOrSequenceNumber === "number"
                    ? eventDataOrSequenceNumber
                    : eventDataOrSequenceNumber.sequenceNumber,
                offset: typeof offset === "number"
                    ? offset
                    : eventDataOrSequenceNumber.offset,
                eTag: this._eTag
            };
            this._eTag = yield this._partitionManager.updateCheckpoint(checkpoint);
        });
    }
}

Object.defineProperty(exports, 'DefaultDataTransformer', {
    enumerable: true,
    get: function () {
        return coreAmqp.DefaultDataTransformer;
    }
});
Object.defineProperty(exports, 'MessagingError', {
    enumerable: true,
    get: function () {
        return coreAmqp.MessagingError;
    }
});
Object.defineProperty(exports, 'TokenType', {
    enumerable: true,
    get: function () {
        return coreAmqp.TokenType;
    }
});
Object.defineProperty(exports, 'delay', {
    enumerable: true,
    get: function () {
        return coreAmqp.delay;
    }
});
exports.EventDataBatch = EventDataBatch;
exports.EventHubClient = EventHubClient;
exports.EventHubConsumer = EventHubConsumer;
exports.EventHubProducer = EventHubProducer;
exports.EventPosition = EventPosition;
exports.EventProcessor = EventProcessor;
exports.InMemoryPartitionManager = InMemoryPartitionManager;
exports.PartitionProcessor = PartitionProcessor;
exports.ReceiveHandler = ReceiveHandler;
exports.extractSpanContextFromEventData = extractSpanContextFromEventData;
//# sourceMappingURL=index.js.map
