/// <reference types="node" />
import { AbortSignalLike } from '@azure/abort-controller';
import { AmqpError } from 'rhea-promise';
import { AwaitableSender } from 'rhea-promise';
import { ConnectionContextBase } from '@azure/core-amqp';
import { DataTransformer } from '@azure/core-amqp';
import { DefaultDataTransformer } from '@azure/core-amqp';
import { delay } from '@azure/core-amqp';
import { Dictionary } from 'rhea-promise';
import { EventHubConnectionConfig } from '@azure/core-amqp';
import { MessagingError } from '@azure/core-amqp';
import { Receiver } from 'rhea-promise';
import { ReceiverOptions } from 'rhea-promise';
import { RetryOptions } from '@azure/core-amqp';
import { SharedKeyCredential } from '@azure/core-amqp';
import { Span } from '@azure/core-tracing';
import { SpanContext } from '@azure/core-tracing';
import { TokenCredential } from '@azure/core-amqp';
import { TokenType } from '@azure/core-amqp';
import { WebSocketImpl } from 'rhea-promise';

/**
 * The set of options to configure request cancellation.
 * - `abortSignal` : A signal used to cancel an asynchronous operation.
 */
export declare interface AbortSignalOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}

/**
 * The set of options to configure the `createBatch` operation on the `EventProducer`.
 * - `partitionKey`  : A value that is hashed to produce a partition assignment.
 * Not applicable if the `EventHubProducer` was created using a `partitionId`.
 * - `maxSizeInBytes`: The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.
 * - `abortSignal`   : A signal the request to cancel the send operation.
 *
 * Example usage:
 * ```js
 * {
 *     partitionKey: 'foo',
 *     maxSizeInBytes: 1024 * 1024 // 1 MB
 * }
 * ```
 */
export declare interface BatchOptions {
    /**
     * @property
     * A value that is hashed to produce a partition assignment.
     * It guarantees that messages with the same partitionKey end up in the same partition.
     * Specifying this will throw an error if the producer was created using a `paritionId`.
     */
    partitionKey?: string;
    /**
     * @property
     * The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.
     */
    maxSizeInBytes?: number;
    /**
     * @property
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}

/**
 * A checkpoint is meant to represent the last successfully processed event by the user from a particular
 * partition of a consumer group in an Event Hub instance.
 *
 * When the `updateCheckpoint()` method on the `PartitionProcessor` class is called by the user, a
 * `Checkpoint` is created internally. It is then stored in the storage solution implemented by the
 * `PartitionManager` chosen by the user when creating an `EventProcessor`.
 *
 * Users are never expected to interact with `Checkpoint` directly. This interface exists to support the
 * internal workings of `EventProcessor` and `PartitionManager`.
 **/
export declare interface Checkpoint {
    /**
     * @property The fully qualified Event Hubs namespace. This is likely to be similar to
     * <yournamespace>.servicebus.windows.net
     */
    fullyQualifiedNamespace: string;
    /**
     * @property The event hub name
     */
    eventHubName: string;
    /**
     * @property The consumer group name
     */
    consumerGroupName: string;
    /**
     * @property The unique identifier of the event processor
     */
    ownerId: string;
    /**
     * @property The identifier of the Event Hub partition
     */
    partitionId: string;
    /**
     * @property The sequence number of the event
     */
    sequenceNumber: number;
    /**
     * @property The offset of the event.
     */
    offset: number;
    /**
     * @property The unique identifier for the operation
     */
    eTag: string;
}

/**
 * An enum representing the different reasons for an `EventProcessor` to stop processing
 * events from a partition in a consumer group of an Event Hub instance.
 */
export declare enum CloseReason {
    /**
     * Ownership of the partition was lost or transitioned to a new processor instance.
     */
    OwnershipLost = "OwnershipLost",
    /**
     * The EventProcessor was shutdown.
     */
    Shutdown = "Shutdown"
}

/* Excluded from this release type: ConnectionContext */

/* Excluded from this release type: ConnectionContextOptions */
export { DataTransformer }
export { DefaultDataTransformer }
export { delay }

/**
 * `EventData` is the interface that describes the event data to be sent to Event Hub.
 * A simple instance can be `{ body: "your-data" }`.
 * @interface
 */
export declare interface EventData {
    /**
     * @property The message body that needs to be sent.
     */
    body: any;
    /**
     * @property Set of key value pairs that can be used to set properties specific to user application.
     */
    properties?: {
        [key: string]: any;
    };
}

/**
 * A class representing a batch of events which can be passed to the `send` method of a `EventProducer` instance.
 * This batch is ensured to be under the maximum message size supported by Azure Event Hubs service.
 *
 * Use `createBatch()` method on the `EventHubProducer` to create an instance of `EventDataBatch`
 * instead of using `new EventDataBatch()`. You can specify an upper limit for the size of the batch
 * via options when calling `createBatch()`.
 *
 * Use the `tryAdd` function on the EventDataBatch to add events to the batch. This method will return
 * `false` after the upper limit is reached, therefore check the result before calling `tryAdd()` again.
 * @class
 */
export declare class EventDataBatch {
    /**
     * @property Describes the amqp connection context for the Client.
     */
    private _context;
    /**
     * @property A value that is hashed to produce a partition assignment.
     * It guarantees that messages with the same partitionKey end up in the same partition.
     * Specifying this will throw an error if the producer was created using a `paritionId`.
     */
    private _partitionKey?;
    /**
     * @property The maximum size allowed for the batch.
     */
    private readonly _maxSizeInBytes;
    /**
     * @property Current size of the batch in bytes.
     */
    private _sizeInBytes;
    /**
     * @property Encoded amqp messages.
     */
    private _encodedMessages;
    /**
     * @property Number of events in the batch.
     */
    private _count;
    /**
     * @property Encoded batch message.
     */
    private _batchMessage;
    /**
     * List of 'message' span contexts.
     */
    private _spanContexts;
    /* Excluded from this release type: __constructor */
    /**
     * @property The partitionKey set during `EventDataBatch` creation. This value is hashed to
     * produce a partition assignment when the producer is created without a `partitionId`
     * @readonly
     */
    readonly partitionKey: string | undefined;
    /**
     * @property Size of the `EventDataBatch` instance after the events added to it have been
     * encoded into a single AMQP message.
     * @readonly
     */
    readonly sizeInBytes: number;
    /**
     * @property Number of events in the `EventDataBatch` instance.
     * @readonly
     */
    readonly count: number;
    /**
     * @property Represents the single AMQP message which is the result of encoding all the events
     * added into the `EventDataBatch` instance.
     *
     * This is not meant for the user to use directly.
     *
     * When the `EventDataBatch` instance is passed to the `send()` method on the `EventHubProducer`,
     * this single batched AMQP message is what gets sent over the wire to the service.
     * @readonly
     */
    readonly batchMessage: Buffer | undefined;
    /* Excluded from this release type: _messageSpanContexts */
    /**
     * Tries to add an event data to the batch if permitted by the batch's size limit.
     * **NOTE**: Always remember to check the return value of this method, before calling it again
     * for the next event.
     *
     * @param eventData  An individual event data object.
     * @returns A boolean value indicating if the event data has been added to the batch or not.
     */
    tryAdd(eventData: EventData, options?: TryAddOptions): boolean;
}

/**
 * @class
 * The client is the main point of interaction with Azure Event Hubs service.
 * It offers connection to a specific Event Hub within the Event Hubs namespace along with
 * operations for sending event data, receiving events, and inspecting the connected Event Hub.
 *
 * There are multiple ways to create an `EventHubClient`
 * - Use the connection string from the SAS policy created for your Event Hub instance.
 * - Use the connection string from the SAS policy created for your Event Hub namespace,
 * and the name of the Event Hub instance
 * - Use the fully qualified domain name of your Event Hub namespace like `<yournamespace>.servicebus.windows.net`,
 * and a credentials object.
 *
 */
export declare class EventHubClient {
    /**
     * Describes the amqp connection context for the eventhub client.
     */
    private _context;
    /**
     * The options passed by the user when creating the EventHubClient instance.
     */
    private _clientOptions;
    /**
     * The Service Bus endpoint.
     */
    private _endpoint;
    /**
     * @property
     * @readonly
     * The name of the Event Hub instance for which this client is created.
     */
    readonly eventHubName: string;
    /**
     * @property
     * @readonly
     * The fully qualified Event Hubs namespace for which this client is created. This is likely to be similar to
     * <yournamespace>.servicebus.windows.net.
     */
    readonly fullyQualifiedNamespace: string;
    /**
     * @constructor
     * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.
     * It is expected that the shared key properties and the Event Hub path are contained in this connection string.
     * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.
     * @param options - A set of options to apply when configuring the client.
     * - `dataTransformer`: A set of `encode`/`decode` methods to be used to encode an event before sending to service
     * and to decode the event received from the service
     * - `userAgent`      : A string to append to the built in user agent string that is passed as a connection property
     * to the service.
     * - `websocket`      : The WebSocket constructor used to create an AMQP connection if you choose to make the connection
     * over a WebSocket.
     * - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection
     * over a WebSocket.
     * - `retryOptions`   : The retry options for all the operations on the client/producer/consumer.
     * A simple usage can be `{ "maxRetries": 4 }`.
     */
    constructor(connectionString: string, options?: EventHubClientOptions);
    /**
     * @constructor
     * @param connectionString - The connection string to use for connecting to the Event Hubs namespace;
     * it is expected that the shared key properties are contained in this connection string, but not the Event Hub path,
     * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.
     * @param eventHubName - The path of the specific Event Hub to connect the client to.
     * @param options - A set of options to apply when configuring the client.
     * - `dataTransformer`: A set of `encode`/`decode` methods to be used to encode an event before sending to service
     * and to decode the event received from the service
     * - `userAgent`      : A string to append to the built in user agent string that is passed as a connection property
     * to the service.
     * - `websocket`      : The WebSocket constructor used to create an AMQP connection if you choose to make the connection
     * over a WebSocket.
     * - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection
     * over a WebSocket.
     * - `retryOptions`   : The retry options for all the operations on the client/producer/consumer.
     * A simple usage can be `{ "maxRetries": 4 }`.
     */
    constructor(connectionString: string, eventHubName: string, options?: EventHubClientOptions);
    /**
     * @constructor
     * @param host - The fully qualified host name for the Event Hubs namespace. This is likely to be similar to
     * <yournamespace>.servicebus.windows.net
     * @param eventHubName - The path of the specific Event Hub to connect the client to.
     * @param credential - SharedKeyCredential object or your credential that implements the TokenCredential interface.
     * @param options - A set of options to apply when configuring the client.
     * - `dataTransformer`: A set of `encode`/`decode` methods to be used to encode an event before sending to service
     * and to decode the event received from the service
     * - `userAgent`      : A string to append to the built in user agent string that is passed as a connection property
     * to the service.
     * - `websocket`      : The WebSocket constructor used to create an AMQP connection if you choose to make the connection
     * over a WebSocket.
     * - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection
     * over a WebSocket.
     * - `retryOptions`   : The retry options for all the operations on the client/producer/consumer.
     * A simple usage can be `{ "maxRetries": 4 }`.
     */
    constructor(host: string, eventHubName: string, credential: TokenCredential, options?: EventHubClientOptions);
    private _createClientSpan;
    /**
     * Closes the AMQP connection to the Event Hub instance,
     * returning a promise that will be resolved when disconnection is completed.
     * @returns Promise<void>
     * @throws {Error} Thrown if the underlying connection encounters an error while closing.
     */
    close(): Promise<void>;
    /**
     * Creates an Event Hub producer that can send events to the Event Hub.
     * If `partitionId` is specified in the `options`, all event data sent using the producer
     * will be sent to the specified partition.
     * Otherwise, they are automatically routed to an available partition by the Event Hubs service.
     *
     * Automatic routing of partitions is recommended because:
     *  - The sending of events will be highly available.
     *  - The event data will be evenly distributed among all available partitions.
     *
     * @param options The set of options to apply when creating the producer.
     * - `partitionId`  : The identifier of the partition that the producer can be bound to.
     * - `retryOptions` : The retry options used to govern retry attempts when an issue is encountered while sending events.
     * A simple usage can be `{ "maxRetries": 4 }`.
     *
     * @throws {Error} Thrown if the underlying connection has been closed, create a new EventHubClient.
     * @returns EventHubProducer
     */
    createProducer(options?: EventHubProducerOptions): EventHubProducer;
    /**
     * Creates an Event Hub consumer that can receive events from a specific Event Hub partition,
     * in the context of a specific consumer group.
     *
     * Multiple consumers are allowed on the same partition in a consumer group.
     * If there is a need to have an exclusive consumer for a partition in a consumer group,
     * then specify the `ownerLevel` in the `options`.
     * Exclusive consumers were previously referred to as "Epoch Receivers".
     *
     * @param consumerGroup The name of the consumer group this consumer is associated with.
     * Events are read in the context of this group. You can get this information from Azure portal.
     * @param partitionId The identifier of the Event Hub partition from which events will be received.
     * You can get identifiers for all partitions by using the `getPartitionProperties` method on the `EventHubClient`.
     * @param eventPosition The position within the partition where the consumer should begin reading events.
     * The easiest way to create an instance of EventPosition is to use the static helpers on it like
     * - `EventPosition.fromOffset()`
     * - `EventPosition.fromSequenceNumber()`
     * - `EventPosition.fromEnqueuedTime()`
     * - `EventPosition.earliest()`
     * - `EventPosition.latest()`
     * @param options The set of options to apply when creating the consumer.
     * - `ownerLevel`  : A number indicating that the consumer intends to be an exclusive consumer of events resulting in other
     * consumers to fail if their `ownerLevel` is lower or doesn't exist.
     * - `retryOptions`: The retry options used to govern retry attempts when an issue is encountered while receiving events.
     * A simple usage can be `{ "maxRetries": 4 }`.
     *
     * @throws {Error} Thrown if the underlying connection has been closed, create a new EventHubClient.
     * @throws {TypeError} Thrown if a required parameter is missing.
     */
    createConsumer(consumerGroup: string, partitionId: string, eventPosition: EventPosition, options?: EventHubConsumerOptions): EventHubConsumer;
    /**
     * Provides the Event Hub runtime information.
     * @param [options] The set of options to apply to the operation call.
     * @returns A promise that resolves with EventHubProperties.
     * @throws {Error} Thrown if the underlying connection has been closed, create a new EventHubClient.
     * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.
     */
    getProperties(options?: GetPropertiesOptions): Promise<EventHubProperties>;
    /**
     * Provides an array of partitionIds.
     * @param [options] The set of options to apply to the operation call.
     * @returns A promise that resolves with an Array of strings.
     * @throws {Error} Thrown if the underlying connection has been closed, create a new EventHubClient.
     * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.
     */
    getPartitionIds(options?: GetPartitionIdsOptions): Promise<Array<string>>;
    /**
     * Provides information about the specified partition.
     * @param partitionId Partition ID for which partition information is required.
     * @param [options] The set of options to apply to the operation call.
     * @returns A promise that resoloves with PartitionProperties.
     * @throws {Error} Thrown if the underlying connection has been closed, create a new EventHubClient.
     * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.
     */
    getPartitionProperties(partitionId: string, options?: GetPartitionPropertiesOptions): Promise<PartitionProperties>;
    /**
     * @property
     * The name of the default consumer group in the Event Hubs service.
     */
    static defaultConsumerGroupName: string;
}

/**
 * Describes the options that can be provided while creating the EventHubClient.
 * - `dataTransformer`: A set of `encode`/`decode` methods to be used to encode an event before sending to service
 * and to decode the event received from the service
 * - `userAgent`      : A string to append to the built in user agent string that is passed as a connection property
 * to the service.
 * - `websocket`      : The WebSocket constructor used to create an AMQP connection if you choose to make the connection
 * over a WebSocket.
 * - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection
 * over a WebSocket.
 * - `retryOptions`   : The retry options for all the operations on the client/producer/consumer.
 * A simple usage can be `{ "maxRetries": 4 }`.
 *
 * Example usage:
 * ```js
 * {
 *     retryOptions: {
 *         maxRetries: 4
 *     }
 * }
 * ```
 * @interface ClientOptions
 */
export declare interface EventHubClientOptions {
    /**
     * @property
     * The data transformer that will be used to encode and decode the sent and received messages respectively.
     * If not provided then the `DefaultDataTransformer` is used which has the below `encode` & `decode` features
     * - `encode`:
     *    - If event body is a Buffer, then the event is sent without any data transformation
     *    - Else, JSON.stringfy() is run on the body, and then converted to Buffer before sending the event
     *    - If JSON.stringify() fails at this point, the send operation fails too.
     * - `decode`
     *    - The body receivied via the AMQP protocol is always of type Buffer
     *    - UTF-8 encoding is used to convert Buffer to string, and then JSON.parse() is run on it to get the event body
     *    - If the JSON.parse() fails at this point, then the originally received Buffer object is returned in the event body.
     */
    dataTransformer?: DataTransformer;
    /**
     * @property
     * The user agent that will be appended to the built in user agent string that is passed as a
     * connection property to the Event Hubs service.
     */
    userAgent?: string;
    /**
     * @property
     * The WebSocket constructor used to create an AMQP connection over a WebSocket.
     * This option should be provided in the below scenarios:
     * - The TCP port 5671 which is what is used by the AMQP connection to Event Hubs is blocked in your environment.
     * - Your application needs to be run behind a proxy server
     * - Your application needs to run in the browser and you want to provide your own choice of Websocket implementation
     * instead of the built-in WebSocket in the browser.
     */
    webSocket?: WebSocketImpl;
    /**
     * @property
     * Options to be passed to the WebSocket constructor when the underlying `rhea` library instantiates
     * the WebSocket.
     */
    webSocketConstructorOptions?: any;
    /**
     * @property
     * The retry options for all the operations on the client/producer/consumer.
     * This can be overridden by the retry options set on the producer and consumer.
     */
    retryOptions?: RetryOptions;
}

/**
 * A consumer is responsible for reading `EventData` from a specific Event Hub partition
 * in the context of a specific consumer group.
 * To create a consumer use the `createConsumer()` method on your `EventHubClient`.
 *
 * You can pass the below in the `options` when creating a consumer.
 * - `ownerLevel`  : A number indicating that the consumer intends to be an exclusive consumer of events resulting in other
 * consumers to fail if their `ownerLevel` is lower or doesn't exist.
 * - `retryOptions`: The retry options used to govern retry attempts when an issue is encountered while receiving events.
 *
 * Multiple consumers are allowed on the same partition in a consumer group.
 * If there is a need to have an exclusive consumer for a partition in a consumer group,
 * then specify the `ownerLevel` in the `options`.
 * Exclusive consumers were previously referred to as "Epoch Receivers".
 *
 * The consumer can be used to receive messages in a batch using `receiveBatch()` or by registering handlers
 * by using `receive()` or via an async iterable got by using `getEventIterator()`
 * @class
 */
export declare class EventHubConsumer {
    private _baseConsumer?;
    /**
     * @property Describes the amqp connection context for the QueueClient.
     */
    private _context;
    /**
     * @property The consumer group from which the receiver should receive events from.
     */
    private _consumerGroup;
    /**
     * @property Denotes if close() was called on this receiver
     */
    private _isClosed;
    /**
     * @property The identifier of the Event Hub partition that this consumer is associated with.
     * Events will be read only from this partition.
     */
    private _partitionId;
    /**
     * @property The set of options to configure the behavior of an EventHubConsumer.
     */
    private _receiverOptions;
    /**
     * @property The set of retry options to configure the receiveBatch operation.
     */
    private _retryOptions;
    /**
     * @property A set of information about the last enqueued event of a partition.
     */
    private _lastEnqueuedEventInfo;
    /**
     * @property The last enqueued event information. This property will only
     * be enabled when `trackLastEnqueuedEventInfo` option is set to true in the
     * `client.createConsumer()` method.
     * @readonly
     */
    readonly lastEnqueuedEventInfo: LastEnqueuedEventInfo;
    /**
     * @property Returns `true` if the consumer is closed. This can happen either because the consumer
     * itself has been closed or the client that created it has been closed.
     * @readonly
     */
    readonly isClosed: boolean;
    /**
     * @property The identifier of the Event Hub partition that this consumer is associated with.
     * Events will be read only from this partition.
     * @readonly
     */
    readonly partitionId: string;
    /**
     * @property The name of the consumer group that this consumer is associated with.
     * Events will be read only in the context of this group.
     * @readonly
     */
    readonly consumerGroup: string;
    /**
     * @property The owner level associated with an exclusive consumer; for a non-exclusive consumer, this value will be null or undefined.
     *
     * When provided, the owner level indicates that a consumer is intended to be the exclusive receiver of events for the
     * requested partition and the associated consumer group.
     * When multiple consumers exist for the same partition/consumer group pair, then the ones with lower or no
     * `ownerLevel` will get a `ReceiverDisconnectedError` during the next attempted receive operation.
     * @readonly
     */
    readonly ownerLevel: number | undefined;
    /**
     * Indicates whether the consumer is currently receiving messages or not.
     * When this returns true, new `receive()` or `receiveBatch()` calls cannot be made.
     */
    readonly isReceivingMessages: boolean;
    /* Excluded from this release type: __constructor */
    /**
     * Starts receiving events from the service and calls the user provided message handler for each event.
     * Returns an object that can be used to query the state of the receiver and to stop receiving events as well.
     *
     * @param onMessage The message handler to receive event data objects.
     * @param onError The error handler for errora that can occur when receiving events.
     * @param abortSignal An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     * @returns ReceiveHandler - An object that provides a mechanism to stop receiving more messages.
     * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.
     * @throws {TypeError} Thrown if a required parameter is missing.
     * @throws {Error} Thrown if the underlying connection or receiver has been closed.
     * Create a new EventHubConsumer using the EventHubClient createConsumer method.
     * @throws {Error} Thrown if the receiver is already receiving messages.
     */
    receive(onMessage: OnMessage, onError: OnError, abortSignal?: AbortSignalLike): ReceiveHandler;
    /**
     * Returns an async iterable that retrieves events.
     *
     * The async iterable cannot indicate that it is done.
     * When using `for await (let event of consumer.getEventIterator()) {}` to iterate over the events returned
     * by the async iterable, take care to exit the for loop after receiving the
     * desired number of messages, or provide an `AbortSignal` to control when to exit the loop.
     *
     * @param [options] A set of options to apply to an event iterator.
     */
    getEventIterator(options?: EventIteratorOptions): AsyncIterableIterator<ReceivedEventData>;
    /**
     * Returns a promise that resolves to an array of events received from the service.
     *
     * @param maxMessageCount The maximum number of messages to receive.
     * @param maxWaitTimeInSeconds The maximum amount of time to wait to build up the requested message count;
     * If not provided, it defaults to 60 seconds.
     * @param abortSignal An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     *
     * @returns Promise<ReceivedEventData[]>.
     * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.
     * @throws {MessagingError} Thrown if an error is encountered while receiving a message.
     * @throws {Error} Thrown if the underlying connection or receiver has been closed.
     * Create a new EventHubConsumer using the EventHubClient createConsumer method.
     * @throws {Error} Thrown if the receiver is already receiving messages.
     */
    receiveBatch(maxMessageCount: number, maxWaitTimeInSeconds?: number, abortSignal?: AbortSignalLike): Promise<ReceivedEventData[]>;
    /**
     * Closes the underlying AMQP receiver link.
     * Once closed, the consumer cannot be used for any further operations.
     * Use the `createConsumer` function on the EventHubClient to instantiate
     * a new EventHubConsumer.
     *
     * @returns
     * @throws {Error} Thrown if the underlying connection encounters an error while closing.
     */
    close(): Promise<void>;
    private _throwIfAlreadyReceiving;
    private _throwIfReceiverOrConnectionClosed;
}

/**
 * The set of options to configure the behavior of an `EventHubConsumer`.
 * These can be specified when creating the consumer using the `createConsumer` method.
 * - `ownerLevel`  : A number indicating that the consumer intends to be an exclusive consumer of events resulting in other
 * consumers to fail if their `ownerLevel` is lower or doesn't exist.
 * - `retryOptions`: The retry options used to govern retry attempts when an issue is encountered while receiving events.
 * A simple usage can be `{ "maxRetries": 4 }`.
 *
 * Example usage:
 * ```js
 * {
 *     retryOptions: {
 *         maxRetries: 4
 *     },
 *     trackLastEnqueuedEventInfo: false
 * }
 * ```
 */
export declare interface EventHubConsumerOptions {
    /**
     * @property
     * The owner level associated with an exclusive consumer.
     *
     * When provided, the owner level indicates that a consumer is intended to be the exclusive receiver of events for the
     * requested partition and the associated consumer group.
     * When multiple consumers exist for the same partition/consumer group pair, then the ones with lower or no
     * `ownerLevel` will get a `ReceiverDisconnectedError` during the next attempted receive operation.
     */
    ownerLevel?: number;
    /**
     * @property
     * The retry options used to govern retry attempts when an issue is encountered while receiving events.
     * If no value is provided here, the retry options set when creating the `EventHubClient` is used.
     */
    retryOptions?: RetryOptions;
    /**
     * @property
     * Indicates whether or not the consumer should request information on the last enqueued event on its
     * associated partition, and track that information as events are received.
  
     * When information about the partition's last enqueued event is being tracked, each event received
     * from the Event Hubs service will carry metadata about the partition that it otherwise would not. This results in a small amount of
     * additional network bandwidth consumption that is generally a favorable trade-off when considered
     * against periodically making requests for partition properties using the Event Hub client.
     */
    trackLastEnqueuedEventInfo?: boolean;
}

/**
 * A producer responsible for sending events to an Event Hub.
 * To create a producer use the `createProducer()` method on your `EventHubClient`.
 * You can pass the below in the `options` when creating a producer.
 * - `partitionId`  : The identifier of the partition that the producer can be bound to.
 * - `retryOptions` : The retry options used to govern retry attempts when an issue is encountered while sending events.
 * A simple usage can be `{ "maxRetries": 4 }`.
 *
 * If `partitionId` is specified when creating a producer, all event data sent using the producer
 * will be sent to the specified partition.
 * Otherwise, they are automatically routed to an available partition by the Event Hubs service.
 *
 * Automatic routing of partitions is recommended because:
 *  - The sending of events will be highly available.
 *  - The event data will be evenly distributed among all available partitions.
 *
 * @class
 */
export declare class EventHubProducer {
    /**
     * @property Describes the amqp connection context for the Client.
     */
    private _context;
    /**
     * @property Denotes if close() was called on this sender
     */
    private _isClosed;
    private _senderOptions;
    private _eventHubSender;
    private _eventHubName;
    private _endpoint;
    /**
     * @property Returns `true` if either the producer or the client that created it has been closed.
     * @readonly
     */
    readonly isClosed: boolean;
    /* Excluded from this release type: __constructor */
    /**
     * Creates an instance of `EventDataBatch` to which one can add events until the maximum supported size is reached.
     * The batch can be passed to the `send()` method of the `EventHubProducer` to be sent to Azure Event Hubs.
     * @param options  A set of options to configure the behavior of the batch.
     * - `partitionKey`  : A value that is hashed to produce a partition assignment.
     * Not applicable if the `EventHubProducer` was created using a `partitionId`.
     * - `maxSizeInBytes`: The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.
     * - `abortSignal`   : A signal the request to cancel the send operation.
     * @returns Promise<EventDataBatch>
     */
    createBatch(options?: BatchOptions): Promise<EventDataBatch>;
    /**
     * Send one or more of events to the associated Event Hub.
     *
     * @param eventData  An individual `EventData` object, or an array of `EventData` objects or an
     * instance of `EventDataBatch`.
     * @param options The set of options that can be specified to influence the way in which
     * events are sent to the associated Event Hub.
     * - `partitionKey` : A value that is hashed to produce a partition assignment.
     * Not applicable if the `EventHubProducer` was created using a `partitionId`.
     * - `abortSignal`  : A signal the request to cancel the send operation.
     *
     * @returns Promise<void>
     * @throws {AbortError} Thrown if the operation is cancelled via the abortSignal.
     * @throws {MessagingError} Thrown if an error is encountered while sending a message.
     * @throws {TypeError} Thrown if a required parameter is missing.
     * @throws {Error} Thrown if the underlying connection or sender has been closed.
     * @throws {Error} Thrown if a partitionKey is provided when the producer was created with a partitionId.
     * @throws {Error} Thrown if batch was created with partitionKey different than the one provided in the options.
     * Create a new producer using the EventHubClient createProducer method.
     */
    send(eventData: EventData | EventData[] | EventDataBatch, options?: SendOptions): Promise<void>;
    /**
     * Closes the underlying AMQP sender link.
     * Once closed, the producer cannot be used for any further operations.
     * Use the `createProducer` function on the EventHubClient to instantiate a new EventHubProducer.
     *
     * @returns
     * @throws {Error} Thrown if the underlying connection encounters an error while closing.
     */
    close(): Promise<void>;
    private _createSendSpan;
    private _throwIfSenderOrConnectionClosed;
}

/**
 * The set of options to configure the behavior of an `EventHubProducer`.
 * These can be specified when creating the producer via the `createProducer` method.
 * - `partitionId`  : The string identifier of the partition that the producer can be bound to.
 * - `retryOptions` : The retry options used to govern retry attempts when an issue is encountered while sending events.
 * A simple usage can be `{ "maxRetries": 4 }`.
 */
export declare interface EventHubProducerOptions {
    /**
     * @property
     * The identifier of the partition that the producer will be bound to.
     * If a value is provided, all events sent using the producer will reach the same partition.
     * If no value is provided, the service will determine the partition to which the event will be sent.
     */
    partitionId?: string;
    /**
     * @property
     * The retry options used to govern retry attempts when an issue is encountered while sending events.
     * If no value is provided here, the retry options set when creating the `EventHubClient` is used.
     */
    retryOptions?: RetryOptions;
}

/**
 * Describes the runtime information of an Event Hub.
 * @interface HubRuntimeInformation
 */
export declare interface EventHubProperties {
    /**
     * @property The name of the event hub.
     */
    path: string;
    /**
     * @property The date and time the hub was created in UTC.
     */
    createdAt: Date;
    /**
     * @property The slice of string partition identifiers.
     */
    partitionIds: string[];
}

/* Excluded from this release type: EventHubReceiver */

/* Excluded from this release type: EventHubSender */

/**
 * Options to pass when creating an async iteratable using the `getEventIterator()` method on the
 * `EventHubConsumer`.
 */
export declare interface EventIteratorOptions {
    /**
     * Number of events to fetch at a time in the background
     */
    /**
     * An implementation of the `AbortSignalLike` interface to signal the `EventIterator` to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}

/**
 * Represents the position of an event in an Event Hub partition, typically used in the creation of
 * an `EventHubConsumer` to specify the position in the partition to begin receiving events from.
 *
 * Make use of the below static helpers to create an instance of `EventPosition`
 * - `fromOffset()`
 * - `fromSequenceNumber()`
 * - `fromEnqueuedTime()`
 * - `earliest()`
 * - `latest()`
 * @class
 */
export declare class EventPosition {
    /**
     * @property The token that represents the beginning event in the stream of a partition: `-1`.
     * @static
     * @readonly
     * @ignore
     */
    private static readonly startOfStream;
    /**
     * @property The token that represents the last event in the stream of a partition: `"@latest"`.
     * @static
     * @readonly
     * @ignore
     */
    private static readonly endOfStream;
    /**
     * @property The offset of the event identified by this position.
     * Expected to be undefined if the position is just created from a sequence number or an enqueued time.
     *
     * The offset is the relative position for an event in the context of the partition.
     * The offset should not be considered a stable value.
     * The same offset may refer to a different event as events reach the age limit for
     * retention and are no longer visible within the partition.
     */
    offset?: number | "@latest";
    /**
     * @property Indicates if the specified offset is inclusive of the event which it identifies.
     * This information is only relevent if the event position was identified by an offset or sequence number.
     * Default value: `false`.
     */
    isInclusive: boolean;
    /**
     * @property The enqueued time of the event identified by this position.
     * Expected to be undefined if the position is just created from a sequence number or an offset.
     */
    enqueuedTime?: Date | number;
    /**
     * @property The sequence number of the event identified by this poistion.
     * Expected to be undefined if the position is just created from an offset or enqueued time.
     */
    sequenceNumber?: number;
    /* Excluded from this release type: __constructor */
    /**
     * Gets an instance of `EventPosition` corresponding to the event in the partition at the provided offset.
     *
     * @param offset The offset of an event with respect to its relative position in the partition.
     * @param isInclusive If true, the specified event is included;
     * otherwise the next event is returned.
     * Default: `false`.
     * @returns EventPosition
     */
    static fromOffset(offset: number, isInclusive?: boolean): EventPosition;
    /**
     * Gets an instance of `EventPosition` corresponding to the event in the partition having a specified sequence number associated with it.
     *
     * @param sequenceNumber The sequence number assigned to an event when it was enqueued in the partition.
     * @param isInclusive If true, event with the `sequenceNumber` is included;
     * otherwise the next event in sequence will be received.
     * Default `false`.
     * @returns EventPosition
     */
    static fromSequenceNumber(sequenceNumber: number, isInclusive?: boolean): EventPosition;
    /**
     * Gets an instance of `EventPosition` corresponding to a specific date and time within the partition to begin seeking an event;
     * the event enqueued after the requested `enqueuedTime` will become the current position.
     *
     * @param enqueuedTime The date and time, in UTC, from which the next available event should be chosen.
     * @returns EventPosition
     */
    static fromEnqueuedTime(enqueuedTime: Date | number): EventPosition;
    /**
     * Gets an instance of `EventPosition` corresponding to the location of the the first event present in the partition.
     * Use this position to begin receiving from the first event that was enqueued in the partition
     * which has not expired due to the retention policy.
     * @returns EventPosition
     */
    static earliest(): EventPosition;
    /**
     * Gets an instance of `EventPosition` corresponding to the end of the partition, where no more events are currently enqueued.
     * Use this position to begin receiving from the next event to be enqueued in the partion after an ``EventHubConsumer``
     * is created with this position.
     * @returns EventPosition
     */
    static latest(): EventPosition;
}

/* Excluded from this release type: EventPositionOptions */

/**
 * Event Processor based applications consist of one or more instances of EventProcessor which have been
 * configured to consume events from the same Event Hub and consumer group. They balance the
 * workload across different instances by distributing the partitions to be processed among themselves.
 * They also allow the user to track progress when events are processed using checkpoints.
 *
 * A checkpoint is meant to represent the last successfully processed event by the user from a particular
 * partition of a consumer group in an Event Hub instance.
 *
 * You need the below to create an instance of `EventProcessor`
 * - The name of the consumer group from which you want to process events
 * - An instance of `EventHubClient` class that was created for the Event Hub instance.
 * - A user implemented class that extends the `PartitionProcessor` class. To get started, you can use the
 * base class `PartitionProcessor` which simply logs the incoming events. To provide your code to process incoming
 * events, extend this class and override the `processEvents()` method. For example:
 * ```js
 * class SamplePartitionProcessor extends PartitionProcessor {
 *     async processEvents(events) {
 *        // user code to process events here
 *        // Information on the partition being processed is available as properties on the `SamplePartitionProcessor` class
 *        // use `this.updateCheckpoint()` method to update checkpoints as needed
 *     }
 * }
 * ```
 * - An instance of `PartitionManager`. To get started, you can pass an instance of `InMemoryPartitionManager`.
 * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.
 * Implementations of `PartitionManager` can be found on npm by searching for packages with the prefix &commat;azure/eventhub-checkpointstore-.
 *
 * @class EventProcessor
 */
export declare class EventProcessor {
    private _consumerGroupName;
    private _eventHubClient;
    private _partitionProcessorClass;
    private _processorOptions;
    private _pumpManager;
    private _id;
    private _isRunning;
    private _loopTask?;
    private _abortController?;
    private _partitionManager;
    private _partitionLoadBalancer;
    /**
     * @param consumerGroupName The name of the consumer group from which you want to process events.
     * @param eventHubClient An instance of `EventHubClient` that was created for the Event Hub instance.
     * @param PartitionProcessorClass A user-provided class that extends the `PartitionProcessor` class.
     * This class will be responsible for processing and checkpointing events.
     * @param partitionManager An instance of `PartitionManager`. To get started, you can pass an instance of `InMemoryPartitionManager`.
     * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.
     * @param options A set of options to configure the Event Processor
     * - `maxBatchSize`         : The max size of the batch of events passed each time to user code for processing.
     * - `maxWaitTimeInSeconds` : The maximum amount of time to wait to build up the requested message count before
     * passing the data to user code for processing. If not provided, it defaults to 60 seconds.
     */
    constructor(consumerGroupName: string, eventHubClient: EventHubClient, PartitionProcessorClass: typeof PartitionProcessor, partitionManager: PartitionManager, options?: EventProcessorOptions);
    /**
     * The unique identifier for the EventProcessor.
     *
     * @return {string}
     */
    readonly id: string;
    private _createPartitionOwnershipRequest;
    private _claimOwnership;
    /**
     * Every loop to this method will result in this EventProcessor owning at most one new partition.
     *
     * The load is considered balanced when no active EventProcessor owns 2 partitions more than any other active
     * EventProcessor. Given that each invocation to this method results in ownership claim of at most one partition,
     * this algorithm converges gradually towards a steady state.
     *
     * When a new partition is claimed, this method is also responsible for starting a partition pump that creates an
     * EventHubConsumer for processing events from that partition.
     */
    private _runLoop;
    /**
     * Starts the `EventProcessor`. Based on the number of instances of `EventProcessor` that are running for the
     * same consumer group, the partitions are distributed among these instances to process events.
     *
     * For each partition, the user provided `PartitionProcessor` is instantiated.
     *
     * Subsequent calls to start will be ignored if this event processor is already running.
     * Calling `start()` after `stop()` is called will restart this event processor.
     *
     * @return {void}
     */
    start(): void;
    /**
     * Stops processing events for all partitions owned by this event processor.
     * All `PartitionProcessor` will be shutdown and any open resources will be closed.
     *
     * Subsequent calls to stop will be ignored if the event processor is not running.
     *
     */
    stop(): Promise<void>;
}

/**
 * A set of options to pass to the constructor of `EventProcessor`.
 * You can specify
 * - `maxBatchSize`: The max size of the batch of events passed each time to user code for processing.
 * - `maxWaitTimeInSeconds`: The maximum amount of time to wait to build up the requested message count before
 * passing the data to user code for processing. If not provided, it defaults to 60 seconds.
 *
 * Example usage with default values:
 * ```ts
 * {
 *     maxBatchSize: 1,
 *     maxWaitTimeInSeconds: 60
 * }
 * ```
 */
export declare interface EventProcessorOptions {
    /**
     * The max size of the batch of events passed each time to user code for processing.
     */
    maxBatchSize?: number;
    /**
     * The maximum amount of time to wait to build up the requested message count before
     * passing the data to user code for processing. If not provided, it defaults to 60 seconds.
     */
    maxWaitTimeInSeconds?: number;
    /**
     * @property
     * Indicates whether or not the consumer should request information on the last enqueued event on its
     * associated partition, and track that information as events are received.
  
     * When information about the partition's last enqueued event is being tracked, each event received
     * from the Event Hubs service will carry metadata about the partition that it otherwise would not. This results in a small amount of
     * additional network bandwidth consumption that is generally a favorable trade-off when considered
     * against periodically making requests for partition properties using the Event Hub client.
     */
    trackLastEnqueuedEventInfo?: boolean;
}

/**
 * Extracts the `SpanContext` from an `EventData` if the context exists.
 * @param eventData An individual `EventData` object.
 */
export declare function extractSpanContextFromEventData(eventData: EventData): SpanContext | undefined;

/**
 * The set of options to configure the behavior of `getPartitionIds`.
 * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
 * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.
 */
export declare interface GetPartitionIdsOptions extends AbortSignalOptions, ParentSpanOptions {
}

/**
 * The set of options to configure the behavior of `getPartitionProperties`.
 * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
 * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.
 */
export declare interface GetPartitionPropertiesOptions extends AbortSignalOptions, ParentSpanOptions {
}

/**
 * The set of options to configure the behavior of `getProperties`.
 * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
 * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.
 */
export declare interface GetPropertiesOptions extends AbortSignalOptions, ParentSpanOptions {
}

/**
 * The `EventProcessor` relies on a `PartitionManager` to store checkpoints and handle partition
 * ownerships. `InMemoryPartitionManager` is simple partition manager that stores checkpoints and
 * partition ownerships in memory of your program.
 *
 * You can use the `InMemoryPartitionManager` to get started with using the `EventProcessor`.
 * But in production, you should choose an implementation of the `PartitionManager` interface that will
 * store the checkpoints and partition ownerships to a durable store instead.
 *
 * @class
 */
export declare class InMemoryPartitionManager implements PartitionManager {
    private _partitionOwnershipMap;
    /**
     * Get the list of all existing partition ownership from the underlying data store. Could return empty
     * results if there are is no existing ownership information.
     *
     * @param fullyQualifiedNamespace The fully qualified Event Hubs namespace. This is likely to be similar to
     * <yournamespace>.servicebus.windows.net.
     * @param eventHubName The event hub name.
     * @param consumerGroupName The consumer group name.
     * @return Partition ownership details of all the partitions that have/had an owner..
     */
    listOwnership(fullyQualifiedNamespace: string, eventHubName: string, consumerGroupName: string): Promise<PartitionOwnership[]>;
    /**
     * Claim ownership of a list of partitions. This will return the list of partitions that were owned
     * successfully.
     *
     * @param partitionOwnership The list of partition ownership this instance is claiming to own.
     * @return A list partitions this instance successfully claimed ownership.
     */
    claimOwnership(partitionOwnership: PartitionOwnership[]): Promise<PartitionOwnership[]>;
    /**
     * Updates the checkpoint in the data store for a partition.
     *
     * @param checkpoint The checkpoint.
     * @return The new eTag on successful update
     */
    updateCheckpoint(checkpoint: Checkpoint): Promise<string>;
}

/**
 * A set of information about the last enqueued event of a partition, as observed by the consumer as
 * events are received from the Event Hubs service
 * @interface LastEnqueuedEventInfo
 */
export declare interface LastEnqueuedEventInfo {
    /**
     * @property The sequence number of the event that was last enqueued into the Event Hub partition from which
     * this event was received.
     */
    sequenceNumber?: number;
    /**
     * @property The date and time, in UTC, that the last event was enqueued into the Event Hub partition from
     * which this event was received.
     */
    enqueuedTime?: Date;
    /**
     * @property The offset of the event that was last enqueued into the Event Hub partition from which
     * this event was received.
     */
    offset?: string;
    /**
     * @property The date and time, in UTC, that the last event was retrieved from the Event Hub partition.
     */
    retrievalTime?: Date;
}

/* Excluded from this release type: LinkEntity */

/**
 * @ignore
 */
declare interface LinkEntityOptions {
    /**
     * @property [name] The unique name for the entity. If not provided then a guid will be
     * assigned.
     */
    name?: string;
    /**
     * @property [partitionId] The partitionId associated with the link entity.
     */
    partitionId?: string;
    /**
     * @property address The link entity address in one of the following forms:
     */
    address?: string;
    /**
     * @property audience The link entity token audience in one of the following forms:
     */
    audience?: string;
}

/* Excluded from this release type: ManagementClient */

/* Excluded from this release type: ManagementClientOptions */
export { MessagingError }

/**
 * Describes the abort handler signature.
 */
declare type OnAbort = () => void;

/**
 * Describes the error handler signature.
 */
export declare type OnError = (error: MessagingError | Error) => void;

/**
 * Describes the message handler signature.
 */
export declare type OnMessage = (eventData: ReceivedEventData) => void;

/**
 * The set of options to manually propagate `Span` context for distributed tracing.
 * - `parentSpan` : The `Span` or `SpanContext` for the operation to use as a `parent` when creating its own span.
 */
export declare interface ParentSpanOptions {
    /**
     * The `Span` or `SpanContext` to use as the `parent` of any spans created while calling operations that make a request to the service.
     */
    parentSpan?: Span | SpanContext;
}

/**
 * A Partition manager stores and retrieves partition ownership information and checkpoint details
 * for each partition in a given consumer group of an event hub instance.
 *
 * Users are not meant to implement an `PartitionManager`.
 * Users are expected to choose existing implementations of this interface, instantiate it, and pass
 * it to the constructor of `EventProcessor`.
 *
 * To get started, you can use the `InMemoryPartitionManager` which will store the relevant information in memory.
 * But in production, you should choose an implementation of the `PartitionManager` interface that will
 * store the checkpoints and partition ownerships to a durable store instead.
 *
 * Implementations of `PartitionManager` can be found on npm by searching for packages with the prefix &commat;azure/eventhub-checkpointstore-.
 */
export declare interface PartitionManager {
    /**
     * Called to get the list of all existing partition ownership from the underlying data store. Could return empty
     * results if there are is no existing ownership information.
     *
     * @param fullyQualifiedNamespace The fully qualified Event Hubs namespace. This is likely to be similar to
     * <yournamespace>.servicebus.windows.net.
     * @param eventHubName The event hub name.
     * @param consumerGroupName The consumer group name.
     * @return A list of partition ownership details of all the partitions that have/had an owner.
     */
    listOwnership(fullyQualifiedNamespace: string, eventHubName: string, consumerGroupName: string): Promise<PartitionOwnership[]>;
    /**
     * Called to claim ownership of a list of partitions. This will return the list of partitions that were owned
     * successfully.
     *
     * @param partitionOwnership The list of partition ownership this instance is claiming to own.
     * @return A list of partitions this instance successfully claimed ownership.
     */
    claimOwnership(partitionOwnership: PartitionOwnership[]): Promise<PartitionOwnership[]>;
    /**
     * Updates the checkpoint in the data store for a partition.
     *
     * @param checkpoint The checkpoint.
     * @return The new eTag on successful update.
     */
    updateCheckpoint(checkpoint: Checkpoint): Promise<string>;
}

/**
 * An interface representing the details on which instance of a `EventProcessor` owns processing
 * of a given partition from a consumer group of an Event Hub instance.
 *
 * **Note**: This is used internally by the `EventProcessor` and user never has to create it directly.
 */
export declare interface PartitionOwnership {
    /**
     * @property The fully qualified Event Hubs namespace. This is likely to be similar to
     * <yournamespace>.servicebus.windows.net
     */
    fullyQualifiedNamespace: string;
    /**
     * @property The event hub name
     */
    eventHubName: string;
    /**
     * @property The consumer group name
     */
    consumerGroupName: string;
    /**
     * @property The unique identifier of the event processor.
     */
    ownerId: string;
    /**
     * @property The identifier of the Event Hub partition
     */
    partitionId: string;
    /**
     * @property
     * The owner level
     */
    ownerLevel: number;
    /**
     * @property The offset of the event.
     */
    offset?: number;
    /**
     * @property The sequence number of the event.
     */
    sequenceNumber?: number;
    /**
     * @property The last modified time.
     */
    lastModifiedTimeInMS?: number;
    /**
     * @property The unique identifier for the operation.
     */
    eTag?: string;
}

/**
 * The `PartitionProcessor` is responsible for processing events received from Event Hubs when using `EventProcessor`
 *
 * The EventProcessor creates a new instance of the PartitionProcessor for each partition of the event hub it starts processing. When you extend the `PartitionProcessor` in order to customize it as you see fit,
 * - Override the `processEvents()` method to add the code to process the received events. This is also a good place to update the checkpoints using the `updateCheckpoint()` method
 * - Optionally override the `processError()` method to handle any error that might have occurred when processing the events.
 * - Optionally override the `initialize()` method to implement any set up related tasks you would want to carry out before starting to receive events from the partition
 * - Optionally override the `close()` method to implement any tear down or clean up tasks you would want to carry out.
 */
export declare class PartitionProcessor {
    private _partitionManager;
    private _consumerGroupName;
    private _fullyQualifiedNamespace;
    private _eventHubName;
    private _eventProcessorId;
    private _partitionId;
    private _eTag;
    private _lastEnqueuedEventInfo;
    /**
     * @property Information on the last enqueued event in the partition that is being processed.
     * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventInfo` option is set to true
     * when creating an instance of EventProcessor
     * @readonly
     */
    /**
    * @property Information on the last enqueued event in the partition that is being processed.
    * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventInfo` option is set to true
    * when creating an instance of EventProcessor
    */
    lastEnqueuedEventInfo: LastEnqueuedEventInfo;
    /**
     * @property The fully qualified namespace from where the current partition is being processed. It is set by the `EventProcessor`
     * @readonly
     */
    /**
    * @property The fully qualified namespace from where the current partition is being processed. It is set by the `EventProcessor`
    */
    fullyQualifiedNamespace: string;
    /**
     * @property The name of the consumer group from where the current partition is being processed. It is set by the `EventProcessor`
     * @readonly
     */
    /**
    * @property The name of the consumer group from where the current partition is being processed. It is set by the `EventProcessor`
    */
    consumerGroupName: string;
    /**
     * @property The name of the event hub to which the current partition belongs. It is set by the `EventProcessor`
     * @readonly
     */
    /**
    * @property The name of the event hub to which the current partition belongs. It is set by the `EventProcessor`
    */
    eventHubName: string;
    /**
     * @property The identifier of the Event Hub partition that is being processed. It is set by the `EventProcessor`
     * @readonly
     */
    /**
    * @property The identifier of the Event Hub partition that is being processed. It is set by the `EventProcessor`
    */
    partitionId: string;
    /**
     * @property The unique identifier of the `EventProcessor` that has spawned the current instance of `PartitionProcessor`. This is set by the `EventProcessor`
     */
    eventProcessorId: string;
    /**
     * @property The Partition Manager used for checkpointing events. This is set by the `EventProcessor`
     */
    partitionManager: PartitionManager;
    /**
     * This method is called when the `EventProcessor` takes ownership of a new partition and before any
     * events are received.
     *
     * @return {Promise<void>}
     */
    initialize(): Promise<void>;
    /**
     * This method is called before the partition processor is closed by the EventProcessor.
     *
     * @param reason The reason for closing this partition processor.
     * @return {Promise<void>}
     */
    close(reason: CloseReason): Promise<void>;
    /**
     * This method is called when new events are received.
     *
     * This is also a good place to update checkpoints as appropriate.
     *
     * @param events The received events to be processed.
     * @return {Promise<void>}
     */
    processEvents(events: ReceivedEventData[]): Promise<void>;
    /**
     * This method is called when an error occurs while receiving events from Event Hubs.
     *
     * @param error The error to be processed.
     * @return {Promise<void>}
     */
    processError(error: Error): Promise<void>;
    /**
     * Updates the checkpoint using the event data.
     *
     * A checkpoint is meant to represent the last successfully processed event by the user from a particular
     * partition of a consumer group in an Event Hub instance.
     *
     * @param eventData The event that you want to update the checkpoint with.
     * @return Promise<void>
     */
    updateCheckpoint(eventData: ReceivedEventData): Promise<void>;
    /**
     * Updates the checkpoint using the given offset and sequence number.
     *
     * A checkpoint is meant to represent the last successfully processed event by the user from a particular
     * partition of a consumer group in an Event Hub instance.
     *
     * @param sequenceNumber The sequence number of the event that you want to update the checkpoint with.
     * @param offset The offset of the event that you want to update the checkpoint with.
     * @return  Promise<void>.
     */
    updateCheckpoint(sequenceNumber: number, offset: number): Promise<void>;
}

/**
 * Describes the runtime information of an EventHub Partition.
 * @interface PartitionProperties
 */
export declare interface PartitionProperties {
    /**
     * @property The name of the Event Hub.
     */
    eventHubName: string;
    /**
     * @property Identifier of the partition within the Event Hub.
     */
    partitionId: string;
    /**
     * @property The starting sequence number of the partition's message log.
     */
    beginningSequenceNumber: number;
    /**
     * @property The last sequence number of the partition's message log.
     */
    lastEnqueuedSequenceNumber: number;
    /**
     * @property The offset of the last enqueued message in the partition's message log.
     */
    lastEnqueuedOffset: number;
    /**
     * @property The time of the last enqueued message in the partition's message log in UTC.
     */
    lastEnqueuedTimeUtc: Date;
}

/**
 * Describes the structure of an event received from Event Hub.
 */
export declare interface ReceivedEventData {
    /**
     * @property The message body that needs to be sent or is received.
     */
    body: any;
    /**
     * @property The application specific properties.
     */
    properties?: {
        [key: string]: any;
    };
    /**
     * @property The enqueued time of the event.
     */
    enqueuedTimeUtc: Date;
    /**
     * @property When specified Event Hub will hash this to a partitionId.
     * It guarantees that messages end up in a specific partition on the event hub.
     */
    partitionKey: string | null;
    /**
     * @property The offset of the event.
     */
    offset: number;
    /**
     * @property The sequence number of the event.
     */
    sequenceNumber: number;
    /**
     * @property The properties set by the service.
     */
    systemProperties?: {
        [key: string]: any;
    };
}

/**
 * Describes the receive handler object that is returned from the receive() method with handlers.
 * The ReceiveHandler is used to stop receiving more messages.
 * @class ReceiveHandler
 */
export declare class ReceiveHandler {
    /**
     * @property _receiver  The underlying EventHubReceiver.
     * @private
     */
    private _receiver;
    /* Excluded from this release type: __constructor */
    /**
     * @property The partitionId from which the handler is receiving events.
     * @readonly
     */
    readonly partitionId: string | undefined;
    /**
     * @property The consumer group from which the handler is receiving events.
     * @readonly
     */
    readonly consumerGroup: string | undefined;
    /**
     * @property Indicates whether the receiver is connected/open.
     * `true` - is open; `false` otherwise.
     * @readonly
     */
    readonly isReceiverOpen: boolean;
    /**
     * Stops the underlying EventHubReceiver from receiving more messages.
     * @returns Promise<void>
     * @throws {Error} Thrown if the underlying connection encounters an error while closing.
     */
    stop(): Promise<void>;
}
export { RetryOptions }

/**
 * The set of options to configure the `send` operation on the `EventHubProducer`.
 * - `partitionKey` : A value that is hashed to produce a partition assignment.
 * - `abortSignal`  : A signal used to cancel the send operation.
 *
 * Example usage:
 * ```js
 * {
 *     partitionKey: 'foo'
 * }
 * ```
 */
export declare interface SendOptions {
    /**
     * @property
     * A value that is hashed to produce a partition assignment.
     * It guarantees that messages with the same partitionKey end up in the same partition.
     * Specifying this will throw an error if the producer was created using a `paritionId`.
     */
    partitionKey?: string | null;
    /**
     * @property
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * The `Span` or `SpanContext` to use as the `parent` of any spans created while sending events.
     */
    parentSpan?: Span | SpanContext;
}
export { TokenCredential }
export { TokenType }

/**
 * The set of options to configure the behavior of `tryAdd`.
 * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.
 */
export declare interface TryAddOptions {
    /**
     * The `Span` or `SpanContext` to use as the `parent` of any spans created while adding events.
     */
    parentSpan?: Span | SpanContext;
}
export { WebSocketImpl }

export { }
