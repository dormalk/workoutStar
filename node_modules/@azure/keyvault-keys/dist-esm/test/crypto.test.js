// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { __awaiter, __generator } from "tslib";
import * as assert from "assert";
import { createHash, publicEncrypt } from "crypto";
import * as constants from "constants";
import { isNode } from "@azure/core-http";
import { CryptographyClient } from "../src";
import { convertJWKtoPEM } from "../src/cryptographyClient";
import { authenticate } from "./utils/testAuthentication";
import { isRecording } from "./utils/recorderUtils";
import { stringToUint8Array, uint8ArrayToString } from "./utils/crypto";
describe("CryptographyClient (all decrypts happen remotely)", function () {
    var client;
    var testClient;
    var cryptoClient;
    var recorder;
    var credential;
    var keyName;
    var keyVaultKey;
    var keySuffix;
    before(function () {
        return __awaiter(this, void 0, void 0, function () {
            var authentication;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, authenticate(this)];
                    case 1:
                        authentication = _a.sent();
                        client = authentication.client;
                        recorder = authentication.recorder;
                        testClient = authentication.testClient;
                        credential = authentication.credential;
                        keySuffix = authentication.keySuffix;
                        keyName = testClient.formatName("cryptography-client-test" + keySuffix);
                        return [4 /*yield*/, client.createKey(keyName, "RSA")];
                    case 2:
                        keyVaultKey = _a.sent();
                        cryptoClient = new CryptographyClient(keyVaultKey.id, credential);
                        return [2 /*return*/];
                }
            });
        });
    });
    after(function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 1:
                        _a.sent();
                        recorder.stop();
                        return [2 /*return*/];
                }
            });
        });
    });
    // The tests follow
    if (isRecording) {
        it("encrypt & decrypt with RSA1_5", function () {
            return __awaiter(this, void 0, void 0, function () {
                var text, encryptResult, decryptResult, decryptedText;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            text = this.test.title;
                            return [4 /*yield*/, cryptoClient.encrypt("RSA1_5", stringToUint8Array(text))];
                        case 1:
                            encryptResult = _a.sent();
                            return [4 /*yield*/, cryptoClient.decrypt("RSA1_5", encryptResult.result)];
                        case 2:
                            decryptResult = _a.sent();
                            decryptedText = uint8ArrayToString(decryptResult.result);
                            assert.equal(text, decryptedText);
                            return [2 /*return*/];
                    }
                });
            });
        });
        if (isNode) {
            it("manually encrypt locally and decrypt remotely, both with RSA1_5", function () {
                return __awaiter(this, void 0, void 0, function () {
                    var text, keyPEM, padded, encrypted, decryptResult, decryptedText;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                text = this.test.title;
                                keyPEM = convertJWKtoPEM(keyVaultKey.key);
                                padded = { key: keyPEM, padding: constants.RSA_PKCS1_PADDING };
                                encrypted = publicEncrypt(padded, Buffer.from(text));
                                return [4 /*yield*/, cryptoClient.decrypt("RSA1_5", encrypted)];
                            case 1:
                                decryptResult = _a.sent();
                                decryptedText = uint8ArrayToString(decryptResult.result);
                                assert.equal(text, decryptedText);
                                return [2 /*return*/];
                        }
                    });
                });
            });
        }
        it("encrypt & decrypt with RSA-OAEP", function () {
            return __awaiter(this, void 0, void 0, function () {
                var text, encryptResult, decryptResult, decryptedText;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            text = this.test.title;
                            return [4 /*yield*/, cryptoClient.encrypt("RSA-OAEP", stringToUint8Array(text))];
                        case 1:
                            encryptResult = _a.sent();
                            return [4 /*yield*/, cryptoClient.decrypt("RSA-OAEP", encryptResult.result)];
                        case 2:
                            decryptResult = _a.sent();
                            decryptedText = uint8ArrayToString(decryptResult.result);
                            assert.equal(text, decryptedText);
                            return [2 /*return*/];
                    }
                });
            });
        });
        if (isNode) {
            it("manually encrypt locally and decrypt remotely, both with RSA-OAEP", function () {
                return __awaiter(this, void 0, void 0, function () {
                    var text, keyPEM, encrypted, decryptResult, decryptedText;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                text = this.test.title;
                                keyPEM = convertJWKtoPEM(keyVaultKey.key);
                                encrypted = publicEncrypt(keyPEM, Buffer.from(text));
                                return [4 /*yield*/, cryptoClient.decrypt("RSA-OAEP", encrypted)];
                            case 1:
                                decryptResult = _a.sent();
                                decryptedText = uint8ArrayToString(decryptResult.result);
                                assert.equal(text, decryptedText);
                                return [2 /*return*/];
                        }
                    });
                });
            });
        }
    }
    if (isNode) {
        it("sign and verify with RS256", function () {
            return __awaiter(this, void 0, void 0, function () {
                var signatureValue, hash, digest, signature, verifyResult;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            signatureValue = this.test.title;
                            hash = createHash("sha256");
                            hash.update(signatureValue);
                            digest = hash.digest();
                            return [4 /*yield*/, cryptoClient.sign("RS256", digest)];
                        case 1:
                            signature = _a.sent();
                            return [4 /*yield*/, cryptoClient.verify("RS256", digest, signature.result)];
                        case 2:
                            verifyResult = _a.sent();
                            assert.ok(verifyResult);
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    if (isRecording) {
        it("wrap and unwrap with rsa1_5", function () {
            return __awaiter(this, void 0, void 0, function () {
                var text, wrapped, unwrappedResult, unwrappedText;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            text = "arepa";
                            return [4 /*yield*/, cryptoClient.wrapKey("RSA1_5", stringToUint8Array(text))];
                        case 1:
                            wrapped = _a.sent();
                            return [4 /*yield*/, cryptoClient.unwrapKey("RSA1_5", wrapped.result)];
                        case 2:
                            unwrappedResult = _a.sent();
                            unwrappedText = uint8ArrayToString(unwrappedResult.result);
                            assert.equal(text, unwrappedText);
                            return [2 /*return*/];
                    }
                });
            });
        });
        it("wrap and unwrap with RSA-OAEP", function () {
            return __awaiter(this, void 0, void 0, function () {
                var text, wrapped, unwrappedResult, unwrappedText;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            text = this.test.title;
                            return [4 /*yield*/, cryptoClient.wrapKey("RSA-OAEP", stringToUint8Array(text))];
                        case 1:
                            wrapped = _a.sent();
                            return [4 /*yield*/, cryptoClient.unwrapKey("RSA-OAEP", wrapped.result)];
                        case 2:
                            unwrappedResult = _a.sent();
                            unwrappedText = uint8ArrayToString(unwrappedResult.result);
                            assert.equal(text, unwrappedText);
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
});
//# sourceMappingURL=crypto.test.js.map