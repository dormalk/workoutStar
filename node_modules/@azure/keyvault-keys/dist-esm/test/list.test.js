// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { __asyncValues, __awaiter, __generator } from "tslib";
import * as assert from "assert";
import { isNode } from "@azure/core-http";
import { isPlayingBack, testPollerProperties } from "./utils/recorderUtils";
import { retry } from "./utils/recorderUtils";
import { env } from "@azure/test-utils-recorder";
import { authenticate } from "./utils/testAuthentication";
import { assertThrowsAbortError } from "./utils/utils.common";
describe("Keys client - list keys in various ways", function () {
    var keyPrefix = "recover" + (env.KEY_NAME || "KeyName");
    var keySuffix;
    var client;
    var testClient;
    var recorder;
    before(function () {
        return __awaiter(this, void 0, void 0, function () {
            var authentication;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, authenticate(this)];
                    case 1:
                        authentication = _a.sent();
                        keySuffix = authentication.keySuffix;
                        client = authentication.client;
                        testClient = authentication.testClient;
                        recorder = authentication.recorder;
                        return [2 /*return*/];
                }
            });
        });
    });
    after(function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                recorder.stop();
                return [2 /*return*/];
            });
        });
    });
    // The tests follow
    it("can purge all keys", function () {
        var e_1, _a, e_2, _b;
        return __awaiter(this, void 0, void 0, function () {
            var _c, _d, properties, e_3, e_1_1, _e, _f, deletedKey, e_4, e_2_1;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        _g.trys.push([0, 8, 9, 14]);
                        _c = __asyncValues(client.listPropertiesOfKeys());
                        _g.label = 1;
                    case 1: return [4 /*yield*/, _c.next()];
                    case 2:
                        if (!(_d = _g.sent(), !_d.done)) return [3 /*break*/, 7];
                        properties = _d.value;
                        _g.label = 3;
                    case 3:
                        _g.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, testClient.flushKey(properties.name)];
                    case 4:
                        _g.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        e_3 = _g.sent();
                        return [3 /*break*/, 6];
                    case 6: return [3 /*break*/, 1];
                    case 7: return [3 /*break*/, 14];
                    case 8:
                        e_1_1 = _g.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 14];
                    case 9:
                        _g.trys.push([9, , 12, 13]);
                        if (!(_d && !_d.done && (_a = _c.return))) return [3 /*break*/, 11];
                        return [4 /*yield*/, _a.call(_c)];
                    case 10:
                        _g.sent();
                        _g.label = 11;
                    case 11: return [3 /*break*/, 13];
                    case 12:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 13: return [7 /*endfinally*/];
                    case 14:
                        _g.trys.push([14, 22, 23, 28]);
                        _e = __asyncValues(client.listDeletedKeys());
                        _g.label = 15;
                    case 15: return [4 /*yield*/, _e.next()];
                    case 16:
                        if (!(_f = _g.sent(), !_f.done)) return [3 /*break*/, 21];
                        deletedKey = _f.value;
                        _g.label = 17;
                    case 17:
                        _g.trys.push([17, 19, , 20]);
                        return [4 /*yield*/, testClient.purgeKey(deletedKey.name)];
                    case 18:
                        _g.sent();
                        return [3 /*break*/, 20];
                    case 19:
                        e_4 = _g.sent();
                        return [3 /*break*/, 20];
                    case 20: return [3 /*break*/, 15];
                    case 21: return [3 /*break*/, 28];
                    case 22:
                        e_2_1 = _g.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 28];
                    case 23:
                        _g.trys.push([23, , 26, 27]);
                        if (!(_f && !_f.done && (_b = _e.return))) return [3 /*break*/, 25];
                        return [4 /*yield*/, _b.call(_e)];
                    case 24:
                        _g.sent();
                        _g.label = 25;
                    case 25: return [3 /*break*/, 27];
                    case 26:
                        if (e_2) throw e_2.error;
                        return [7 /*endfinally*/];
                    case 27: return [7 /*endfinally*/];
                    case 28: return [2 /*return*/];
                }
            });
        });
    });
    it("can get the versions of a key", function () {
        var e_5, _a;
        return __awaiter(this, void 0, void 0, function () {
            var keyName, totalVersions, _b, _c, version, e_5_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        return [4 /*yield*/, client.createKey(keyName, "RSA")];
                    case 1:
                        _d.sent();
                        totalVersions = 0;
                        _d.label = 2;
                    case 2:
                        _d.trys.push([2, 7, 8, 13]);
                        _b = __asyncValues(client.listPropertiesOfKeyVersions(keyName));
                        _d.label = 3;
                    case 3: return [4 /*yield*/, _b.next()];
                    case 4:
                        if (!(_c = _d.sent(), !_c.done)) return [3 /*break*/, 6];
                        version = _c.value;
                        assert.equal(version.name, keyName, "Unexpected key name in result from listPropertiesOfKeyVersions().");
                        totalVersions += 1;
                        _d.label = 5;
                    case 5: return [3 /*break*/, 3];
                    case 6: return [3 /*break*/, 13];
                    case 7:
                        e_5_1 = _d.sent();
                        e_5 = { error: e_5_1 };
                        return [3 /*break*/, 13];
                    case 8:
                        _d.trys.push([8, , 11, 12]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 10];
                        return [4 /*yield*/, _a.call(_b)];
                    case 9:
                        _d.sent();
                        _d.label = 10;
                    case 10: return [3 /*break*/, 12];
                    case 11:
                        if (e_5) throw e_5.error;
                        return [7 /*endfinally*/];
                    case 12: return [7 /*endfinally*/];
                    case 13:
                        assert.equal(totalVersions, 1, "Unexpected total versions for key " + keyName);
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 14:
                        _d.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can get the versions of a key with requestOptions timeout", function () {
            return __awaiter(this, void 0, void 0, function () {
                var iter;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            iter = client.listPropertiesOfKeyVersions("doesntmatter", {
                                requestOptions: { timeout: 1 }
                            });
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, iter.next()];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("can get the versions of a key (paged)", function () {
        var e_6, _a;
        return __awaiter(this, void 0, void 0, function () {
            var keyName, totalVersions, _b, _c, page, _i, page_1, version, e_6_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        return [4 /*yield*/, client.createKey(keyName, "RSA")];
                    case 1:
                        _d.sent();
                        totalVersions = 0;
                        _d.label = 2;
                    case 2:
                        _d.trys.push([2, 7, 8, 13]);
                        _b = __asyncValues(client.listPropertiesOfKeyVersions(keyName).byPage());
                        _d.label = 3;
                    case 3: return [4 /*yield*/, _b.next()];
                    case 4:
                        if (!(_c = _d.sent(), !_c.done)) return [3 /*break*/, 6];
                        page = _c.value;
                        for (_i = 0, page_1 = page; _i < page_1.length; _i++) {
                            version = page_1[_i];
                            assert.equal(version.name, keyName, "Unexpected key name in result from listPropertiesOfKeyVersions().");
                            totalVersions += 1;
                        }
                        _d.label = 5;
                    case 5: return [3 /*break*/, 3];
                    case 6: return [3 /*break*/, 13];
                    case 7:
                        e_6_1 = _d.sent();
                        e_6 = { error: e_6_1 };
                        return [3 /*break*/, 13];
                    case 8:
                        _d.trys.push([8, , 11, 12]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 10];
                        return [4 /*yield*/, _a.call(_b)];
                    case 9:
                        _d.sent();
                        _d.label = 10;
                    case 10: return [3 /*break*/, 12];
                    case 11:
                        if (e_6) throw e_6.error;
                        return [7 /*endfinally*/];
                    case 12: return [7 /*endfinally*/];
                    case 13:
                        assert.equal(totalVersions, 1, "Unexpected total versions for key " + keyName);
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 14:
                        _d.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("list 0 versions of a non-existing key", function () {
        var e_7, _a;
        return __awaiter(this, void 0, void 0, function () {
            var keyName, totalVersions, _b, _c, version, e_7_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        totalVersions = 0;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 6, 7, 12]);
                        _b = __asyncValues(client.listPropertiesOfKeyVersions(keyName));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, _b.next()];
                    case 3:
                        if (!(_c = _d.sent(), !_c.done)) return [3 /*break*/, 5];
                        version = _c.value;
                        assert.equal(version.name, keyName, "Unexpected key name in result from listPropertiesOfKeyVersions().");
                        totalVersions += 1;
                        _d.label = 4;
                    case 4: return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 12];
                    case 6:
                        e_7_1 = _d.sent();
                        e_7 = { error: e_7_1 };
                        return [3 /*break*/, 12];
                    case 7:
                        _d.trys.push([7, , 10, 11]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 9];
                        return [4 /*yield*/, _a.call(_b)];
                    case 8:
                        _d.sent();
                        _d.label = 9;
                    case 9: return [3 /*break*/, 11];
                    case 10:
                        if (e_7) throw e_7.error;
                        return [7 /*endfinally*/];
                    case 11: return [7 /*endfinally*/];
                    case 12:
                        assert.equal(totalVersions, 0, "Unexpected total versions for key " + keyName);
                        return [2 /*return*/];
                }
            });
        });
    });
    it("list 0 versions of a non-existing key (paged)", function () {
        var e_8, _a;
        return __awaiter(this, void 0, void 0, function () {
            var keyName, totalVersions, _b, _c, page, _i, page_2, version, e_8_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        totalVersions = 0;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 6, 7, 12]);
                        _b = __asyncValues(client.listPropertiesOfKeyVersions(keyName).byPage());
                        _d.label = 2;
                    case 2: return [4 /*yield*/, _b.next()];
                    case 3:
                        if (!(_c = _d.sent(), !_c.done)) return [3 /*break*/, 5];
                        page = _c.value;
                        for (_i = 0, page_2 = page; _i < page_2.length; _i++) {
                            version = page_2[_i];
                            assert.equal(version.name, keyName, "Unexpected key name in result from listPropertiesOfKeyVersions().");
                            totalVersions += 1;
                        }
                        _d.label = 4;
                    case 4: return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 12];
                    case 6:
                        e_8_1 = _d.sent();
                        e_8 = { error: e_8_1 };
                        return [3 /*break*/, 12];
                    case 7:
                        _d.trys.push([7, , 10, 11]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 9];
                        return [4 /*yield*/, _a.call(_b)];
                    case 8:
                        _d.sent();
                        _d.label = 9;
                    case 9: return [3 /*break*/, 11];
                    case 10:
                        if (e_8) throw e_8.error;
                        return [7 /*endfinally*/];
                    case 11: return [7 /*endfinally*/];
                    case 12:
                        assert.equal(totalVersions, 0, "Unexpected total versions for key " + keyName);
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can get several inserted keys", function () {
        var e_9, _a;
        return __awaiter(this, void 0, void 0, function () {
            var keyName, keyNames, _i, keyNames_1, name_1, found, _b, _c, properties, e_9_1, _d, keyNames_2, name_2;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        keyNames = [keyName + "-0", keyName + "-1"];
                        _i = 0, keyNames_1 = keyNames;
                        _e.label = 1;
                    case 1:
                        if (!(_i < keyNames_1.length)) return [3 /*break*/, 4];
                        name_1 = keyNames_1[_i];
                        return [4 /*yield*/, client.createKey(name_1, "RSA")];
                    case 2:
                        _e.sent();
                        _e.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        found = 0;
                        _e.label = 5;
                    case 5:
                        _e.trys.push([5, 10, 11, 16]);
                        _b = __asyncValues(client.listPropertiesOfKeys());
                        _e.label = 6;
                    case 6: return [4 /*yield*/, _b.next()];
                    case 7:
                        if (!(_c = _e.sent(), !_c.done)) return [3 /*break*/, 9];
                        properties = _c.value;
                        // The vault might contain more keys than the ones we inserted.
                        if (!keyNames.includes(properties.name))
                            return [3 /*break*/, 8];
                        found += 1;
                        _e.label = 8;
                    case 8: return [3 /*break*/, 6];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_9_1 = _e.sent();
                        e_9 = { error: e_9_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _e.trys.push([11, , 14, 15]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, _a.call(_b)];
                    case 12:
                        _e.sent();
                        _e.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_9) throw e_9.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16:
                        assert.equal(found, 2, "Unexpected number of keys found by getKeys.");
                        _d = 0, keyNames_2 = keyNames;
                        _e.label = 17;
                    case 17:
                        if (!(_d < keyNames_2.length)) return [3 /*break*/, 20];
                        name_2 = keyNames_2[_d];
                        return [4 /*yield*/, testClient.flushKey(name_2)];
                    case 18:
                        _e.sent();
                        _e.label = 19;
                    case 19:
                        _d++;
                        return [3 /*break*/, 17];
                    case 20: return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can get several inserted keys with requestOptions timeout", function () {
            return __awaiter(this, void 0, void 0, function () {
                var iter;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            iter = client.listPropertiesOfKeys({ requestOptions: { timeout: 1 } });
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, iter.next()];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("can get several inserted keys (paged)", function () {
        var e_10, _a;
        return __awaiter(this, void 0, void 0, function () {
            var keyName, keyNames, _i, keyNames_3, name_3, found, _b, _c, page, _d, page_3, properties, e_10_1, _e, keyNames_4, name_4;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        keyNames = [keyName + "-0", keyName + "-1"];
                        _i = 0, keyNames_3 = keyNames;
                        _f.label = 1;
                    case 1:
                        if (!(_i < keyNames_3.length)) return [3 /*break*/, 4];
                        name_3 = keyNames_3[_i];
                        return [4 /*yield*/, client.createKey(name_3, "RSA")];
                    case 2:
                        _f.sent();
                        _f.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        found = 0;
                        _f.label = 5;
                    case 5:
                        _f.trys.push([5, 10, 11, 16]);
                        _b = __asyncValues(client.listPropertiesOfKeys().byPage());
                        _f.label = 6;
                    case 6: return [4 /*yield*/, _b.next()];
                    case 7:
                        if (!(_c = _f.sent(), !_c.done)) return [3 /*break*/, 9];
                        page = _c.value;
                        for (_d = 0, page_3 = page; _d < page_3.length; _d++) {
                            properties = page_3[_d];
                            // The vault might contain more keys than the ones we inserted.
                            if (!keyNames.includes(properties.name))
                                continue;
                            found += 1;
                        }
                        _f.label = 8;
                    case 8: return [3 /*break*/, 6];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_10_1 = _f.sent();
                        e_10 = { error: e_10_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _f.trys.push([11, , 14, 15]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, _a.call(_b)];
                    case 12:
                        _f.sent();
                        _f.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_10) throw e_10.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16:
                        assert.equal(found, 2, "Unexpected number of keys found by getKeys.");
                        _e = 0, keyNames_4 = keyNames;
                        _f.label = 17;
                    case 17:
                        if (!(_e < keyNames_4.length)) return [3 /*break*/, 20];
                        name_4 = keyNames_4[_e];
                        return [4 /*yield*/, testClient.flushKey(name_4)];
                    case 18:
                        _f.sent();
                        _f.label = 19;
                    case 19:
                        _e++;
                        return [3 /*break*/, 17];
                    case 20: return [2 /*return*/];
                }
            });
        });
    });
    it("list deleted keys", function () {
        var e_11, _a;
        return __awaiter(this, void 0, void 0, function () {
            var keyName, keyNames, _i, keyNames_5, name_5, _b, keyNames_6, name_6, poller, _loop_1, _c, keyNames_7, name_7, found, _d, _e, deletedKey, e_11_1, _f, keyNames_8, name_8;
            var _this = this;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        keyNames = [keyName + "-0", keyName + "-1"];
                        _i = 0, keyNames_5 = keyNames;
                        _g.label = 1;
                    case 1:
                        if (!(_i < keyNames_5.length)) return [3 /*break*/, 4];
                        name_5 = keyNames_5[_i];
                        return [4 /*yield*/, client.createKey(name_5, "RSA")];
                    case 2:
                        _g.sent();
                        _g.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        _b = 0, keyNames_6 = keyNames;
                        _g.label = 5;
                    case 5:
                        if (!(_b < keyNames_6.length)) return [3 /*break*/, 9];
                        name_6 = keyNames_6[_b];
                        return [4 /*yield*/, client.beginDeleteKey(name_6, testPollerProperties)];
                    case 6:
                        poller = _g.sent();
                        return [4 /*yield*/, poller.pollUntilDone()];
                    case 7:
                        _g.sent();
                        _g.label = 8;
                    case 8:
                        _b++;
                        return [3 /*break*/, 5];
                    case 9:
                        _loop_1 = function (name_7) {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, retry(function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                            return [2 /*return*/, client.getDeletedKey(name_7)];
                                        }); }); })];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        };
                        _c = 0, keyNames_7 = keyNames;
                        _g.label = 10;
                    case 10:
                        if (!(_c < keyNames_7.length)) return [3 /*break*/, 13];
                        name_7 = keyNames_7[_c];
                        return [5 /*yield**/, _loop_1(name_7)];
                    case 11:
                        _g.sent();
                        _g.label = 12;
                    case 12:
                        _c++;
                        return [3 /*break*/, 10];
                    case 13:
                        found = 0;
                        _g.label = 14;
                    case 14:
                        _g.trys.push([14, 19, 20, 25]);
                        _d = __asyncValues(client.listDeletedKeys());
                        _g.label = 15;
                    case 15: return [4 /*yield*/, _d.next()];
                    case 16:
                        if (!(_e = _g.sent(), !_e.done)) return [3 /*break*/, 18];
                        deletedKey = _e.value;
                        // The vault might contain more keys than the ones we inserted.
                        if (!keyNames.includes(deletedKey.name))
                            return [3 /*break*/, 17];
                        found += 1;
                        _g.label = 17;
                    case 17: return [3 /*break*/, 15];
                    case 18: return [3 /*break*/, 25];
                    case 19:
                        e_11_1 = _g.sent();
                        e_11 = { error: e_11_1 };
                        return [3 /*break*/, 25];
                    case 20:
                        _g.trys.push([20, , 23, 24]);
                        if (!(_e && !_e.done && (_a = _d.return))) return [3 /*break*/, 22];
                        return [4 /*yield*/, _a.call(_d)];
                    case 21:
                        _g.sent();
                        _g.label = 22;
                    case 22: return [3 /*break*/, 24];
                    case 23:
                        if (e_11) throw e_11.error;
                        return [7 /*endfinally*/];
                    case 24: return [7 /*endfinally*/];
                    case 25:
                        assert.equal(found, 2, "Unexpected number of keys found by listDeletedKeys.");
                        _f = 0, keyNames_8 = keyNames;
                        _g.label = 26;
                    case 26:
                        if (!(_f < keyNames_8.length)) return [3 /*break*/, 29];
                        name_8 = keyNames_8[_f];
                        return [4 /*yield*/, testClient.purgeKey(name_8)];
                    case 27:
                        _g.sent();
                        _g.label = 28;
                    case 28:
                        _f++;
                        return [3 /*break*/, 26];
                    case 29: return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("list deleted keys with requestOptions timeout", function () {
            return __awaiter(this, void 0, void 0, function () {
                var iter;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            iter = client.listDeletedKeys({ requestOptions: { timeout: 1 } });
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, iter.next()];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("list deleted keys (paged)", function () {
        var e_12, _a;
        return __awaiter(this, void 0, void 0, function () {
            var keyName, keyNames, _i, keyNames_9, name_9, _b, keyNames_10, name_10, poller, _loop_2, _c, keyNames_11, name_11, found, _d, _e, page, _f, page_4, deletedKey, e_12_1, _g, keyNames_12, name_12;
            var _this = this;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        keyNames = [keyName + "-0", keyName + "-1"];
                        _i = 0, keyNames_9 = keyNames;
                        _h.label = 1;
                    case 1:
                        if (!(_i < keyNames_9.length)) return [3 /*break*/, 4];
                        name_9 = keyNames_9[_i];
                        return [4 /*yield*/, client.createKey(name_9, "RSA")];
                    case 2:
                        _h.sent();
                        _h.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        _b = 0, keyNames_10 = keyNames;
                        _h.label = 5;
                    case 5:
                        if (!(_b < keyNames_10.length)) return [3 /*break*/, 9];
                        name_10 = keyNames_10[_b];
                        return [4 /*yield*/, client.beginDeleteKey(name_10, testPollerProperties)];
                    case 6:
                        poller = _h.sent();
                        return [4 /*yield*/, poller.pollUntilDone()];
                    case 7:
                        _h.sent();
                        _h.label = 8;
                    case 8:
                        _b++;
                        return [3 /*break*/, 5];
                    case 9:
                        _loop_2 = function (name_11) {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, retry(function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                            return [2 /*return*/, client.getDeletedKey(name_11)];
                                        }); }); })];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        };
                        _c = 0, keyNames_11 = keyNames;
                        _h.label = 10;
                    case 10:
                        if (!(_c < keyNames_11.length)) return [3 /*break*/, 13];
                        name_11 = keyNames_11[_c];
                        return [5 /*yield**/, _loop_2(name_11)];
                    case 11:
                        _h.sent();
                        _h.label = 12;
                    case 12:
                        _c++;
                        return [3 /*break*/, 10];
                    case 13:
                        found = 0;
                        _h.label = 14;
                    case 14:
                        _h.trys.push([14, 19, 20, 25]);
                        _d = __asyncValues(client.listDeletedKeys().byPage());
                        _h.label = 15;
                    case 15: return [4 /*yield*/, _d.next()];
                    case 16:
                        if (!(_e = _h.sent(), !_e.done)) return [3 /*break*/, 18];
                        page = _e.value;
                        for (_f = 0, page_4 = page; _f < page_4.length; _f++) {
                            deletedKey = page_4[_f];
                            // The vault might contain more keys than the ones we inserted.
                            if (!keyNames.includes(deletedKey.name))
                                continue;
                            found += 1;
                        }
                        _h.label = 17;
                    case 17: return [3 /*break*/, 15];
                    case 18: return [3 /*break*/, 25];
                    case 19:
                        e_12_1 = _h.sent();
                        e_12 = { error: e_12_1 };
                        return [3 /*break*/, 25];
                    case 20:
                        _h.trys.push([20, , 23, 24]);
                        if (!(_e && !_e.done && (_a = _d.return))) return [3 /*break*/, 22];
                        return [4 /*yield*/, _a.call(_d)];
                    case 21:
                        _h.sent();
                        _h.label = 22;
                    case 22: return [3 /*break*/, 24];
                    case 23:
                        if (e_12) throw e_12.error;
                        return [7 /*endfinally*/];
                    case 24: return [7 /*endfinally*/];
                    case 25:
                        assert.equal(found, 2, "Unexpected number of keys found by listDeletedKeys.");
                        _g = 0, keyNames_12 = keyNames;
                        _h.label = 26;
                    case 26:
                        if (!(_g < keyNames_12.length)) return [3 /*break*/, 29];
                        name_12 = keyNames_12[_g];
                        return [4 /*yield*/, testClient.purgeKey(name_12)];
                    case 27:
                        _h.sent();
                        _h.label = 28;
                    case 28:
                        _g++;
                        return [3 /*break*/, 26];
                    case 29: return [2 /*return*/];
                }
            });
        });
    });
});
//# sourceMappingURL=list.test.js.map