// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { __assign, __awaiter, __generator } from "tslib";
import * as assert from "assert";
import { RestError, isNode } from "@azure/core-http";
import { isPlayingBack, testPollerProperties } from "./utils/recorderUtils";
import { env } from "@azure/test-utils-recorder";
import { authenticate } from "./utils/testAuthentication";
import { AbortController } from "@azure/abort-controller";
import { assertThrowsAbortError } from "./utils/utils.common";
describe("Keys client - create, read, update and delete operations", function () {
    var keyPrefix = "recover" + (env.KEY_NAME || "KeyName");
    var keySuffix;
    var client;
    var testClient;
    var recorder;
    before(function () {
        return __awaiter(this, void 0, void 0, function () {
            var authentication;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, authenticate(this)];
                    case 1:
                        authentication = _a.sent();
                        keySuffix = authentication.keySuffix;
                        client = authentication.client;
                        testClient = authentication.testClient;
                        recorder = authentication.recorder;
                        return [2 /*return*/];
                }
            });
        });
    });
    after(function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                recorder.stop();
                return [2 /*return*/];
            });
        });
    });
    // The tests follow
    it("can create a key while giving a manual type", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        return [4 /*yield*/, client.createKey(keyName, "RSA")];
                    case 1:
                        result = _a.sent();
                        assert.equal(result.name, keyName, "Unexpected key name in result from createKey().");
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    // If this test is not skipped in the browser's playback, no other test will be played back.
    // This is a bug related to the browser features of the recorder.
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can abort creating a key", function () {
            return __awaiter(this, void 0, void 0, function () {
                var keyName, controller;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                            controller = new AbortController();
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    var resultPromise;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                resultPromise = client.createKey(keyName, "RSA", {
                                                    abortSignal: controller.signal
                                                });
                                                controller.abort();
                                                return [4 /*yield*/, resultPromise];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can create a key with requestOptions timeout", function () {
            return __awaiter(this, void 0, void 0, function () {
                var keyName;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, client.createKey(keyName, "RSA", {
                                                    requestOptions: {
                                                        timeout: 1
                                                    }
                                                })];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("cannot create a key with an empty name", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, error, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = "";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, client.createKey(keyName, "RSA")];
                    case 2:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 3:
                        e_1 = _a.sent();
                        error = e_1;
                        return [3 /*break*/, 4];
                    case 4:
                        assert.equal(error.message, "\"keyName\" with value \"\" should satisfy the constraint \"Pattern\": /^[0-9a-zA-Z-]+$/.", "Unexpected error while running createKey with an empty string as the name.");
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can create a RSA key", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        return [4 /*yield*/, client.createRsaKey(keyName)];
                    case 1:
                        result = _a.sent();
                        assert.equal(result.name, keyName, "Unexpected key name in result from createKey().");
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can create a RSA key with size", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, options, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        options = {
                            keySize: 2048
                        };
                        return [4 /*yield*/, client.createRsaKey(keyName, options)];
                    case 1:
                        result = _a.sent();
                        assert.equal(result.name, keyName, "Unexpected key name in result from createKey().");
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can create a RSA key with requestOptions timeout", function () {
            return __awaiter(this, void 0, void 0, function () {
                var keyName;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, client.createRsaKey(keyName, {
                                                    requestOptions: {
                                                        timeout: 1
                                                    }
                                                })];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("can create an EC key", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        return [4 /*yield*/, client.createEcKey(keyName)];
                    case 1:
                        result = _a.sent();
                        assert.equal(result.name, keyName, "Unexpected key name in result from createKey().");
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can create an EC key with curve", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, options, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        options = {
                            curve: "P-256"
                        };
                        return [4 /*yield*/, client.createEcKey(keyName, options)];
                    case 1:
                        result = _a.sent();
                        assert.equal(result.name, keyName, "Unexpected key name in result from createKey().");
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can create an EC key with requestOptions timeout", function () {
            return __awaiter(this, void 0, void 0, function () {
                var keyName;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, client.createEcKey(keyName, {
                                                    requestOptions: {
                                                        timeout: 1
                                                    }
                                                })];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("can create a disabled key", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, options, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        options = {
                            enabled: false
                        };
                        return [4 /*yield*/, client.createRsaKey(keyName, options)];
                    case 1:
                        result = _a.sent();
                        assert.equal(result.properties.enabled, false, "Unexpected enabled value from createKey().");
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can create a key with notBefore", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, date, notBefore, options, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        date = new Date("2019-01-01");
                        notBefore = new Date(date.getTime() + 5000);
                        notBefore.setMilliseconds(0);
                        options = { notBefore: notBefore };
                        return [4 /*yield*/, client.createRsaKey(keyName, options)];
                    case 1:
                        result = _a.sent();
                        assert.equal(result.properties.notBefore.getTime(), notBefore.getTime(), "Unexpected notBefore value from createKey().");
                        assert.equal(result.name, keyName, "Unexpected key name in result from createKey().");
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can create a key with expires", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, date, expiresOn, options, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        date = new Date("2019-01-01");
                        expiresOn = new Date(date.getTime() + 5000);
                        expiresOn.setMilliseconds(0);
                        options = { expiresOn: expiresOn };
                        return [4 /*yield*/, client.createRsaKey(keyName, options)];
                    case 1:
                        result = _a.sent();
                        assert.equal(result.properties.expiresOn.getTime(), expiresOn.getTime(), "Unexpected expires value from createKey().");
                        assert.equal(result.name, keyName, "Unexpected key name in result from createKey().");
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can update key", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, version, options, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        return [4 /*yield*/, client.createRsaKey(keyName)];
                    case 1:
                        version = (_a.sent()).properties.version;
                        options = { enabled: false };
                        return [4 /*yield*/, client.updateKeyProperties(keyName, version || "", options)];
                    case 2:
                        result = _a.sent();
                        assert.equal(result.properties.enabled, false, "Unexpected enabled value from updateKey().");
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can update a disabled key", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, createOptions, version, expiresOn, updateOptions, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        createOptions = {
                            enabled: false
                        };
                        return [4 /*yield*/, client.createRsaKey(keyName, createOptions)];
                    case 1:
                        version = (_a.sent()).properties.version;
                        expiresOn = new Date("2019-01-01");
                        expiresOn.setMilliseconds(0);
                        updateOptions = { expiresOn: expiresOn };
                        return [4 /*yield*/, client.updateKeyProperties(keyName, version || "", updateOptions)];
                    case 2:
                        result = _a.sent();
                        assert.equal(result.properties.expiresOn.getTime(), expiresOn.getTime(), "Unexpected expires value after attempting to update a disabled key");
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can update key with requestOptions timeout", function () {
            return __awaiter(this, void 0, void 0, function () {
                var keyName, version, options;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                            return [4 /*yield*/, client.createRsaKey(keyName)];
                        case 1:
                            version = (_a.sent()).properties.version;
                            options = {
                                enabled: false,
                                requestOptions: { timeout: 1 }
                            };
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, client.updateKeyProperties(keyName, version || "", options)];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("can delete a key", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, poller, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        return [4 /*yield*/, client.createKey(keyName, "RSA")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.beginDeleteKey(keyName, testPollerProperties)];
                    case 2:
                        poller = _a.sent();
                        return [4 /*yield*/, poller.pollUntilDone()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        _a.trys.push([4, 6, , 7]);
                        return [4 /*yield*/, client.getKey(keyName)];
                    case 5:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 6:
                        e_2 = _a.sent();
                        if (e_2 instanceof RestError) {
                            assert.equal(e_2.message, "Key not found: " + keyName);
                        }
                        else {
                            throw e_2;
                        }
                        return [3 /*break*/, 7];
                    case 7: return [4 /*yield*/, testClient.purgeKey(keyName)];
                    case 8:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can delete a key with requestOptions timeout", function () {
            return __awaiter(this, void 0, void 0, function () {
                var keyName;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                            return [4 /*yield*/, client.createKey(keyName, "RSA")];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, client.beginDeleteKey(keyName, __assign(__assign({}, testPollerProperties), { requestOptions: {
                                                        timeout: 1
                                                    } }))];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("delete nonexisting key", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, e_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, client.getKey(keyName)];
                    case 2:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 3:
                        e_3 = _a.sent();
                        if (e_3 instanceof RestError) {
                            assert.equal(e_3.message, "Key not found: " + keyName);
                        }
                        else {
                            throw e_3;
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    });
    it("can get a key", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, getResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        return [4 /*yield*/, client.createKey(keyName, "RSA")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.getKey(keyName)];
                    case 2:
                        getResult = _a.sent();
                        assert.equal(getResult.name, keyName, "Unexpected key name in result from getKey().");
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can get a key with requestOptions timeout", function () {
            return __awaiter(this, void 0, void 0, function () {
                var keyName;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                            return [4 /*yield*/, client.createKey(keyName, "RSA")];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, client.getKey(keyName, { requestOptions: { timeout: 1 } })];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("can get a specific version of a key", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, version, options, getResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        return [4 /*yield*/, client.createKey(keyName, "RSA")];
                    case 1:
                        version = (_a.sent()).properties.version;
                        options = { version: version };
                        return [4 /*yield*/, client.getKey(keyName, options)];
                    case 2:
                        getResult = _a.sent();
                        assert.equal(getResult.properties.version, version, "Unexpected key name in result from getKey().");
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can get a deleted key", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, poller, getResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        return [4 /*yield*/, client.createKey(keyName, "RSA")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.beginDeleteKey(keyName, testPollerProperties)];
                    case 2:
                        poller = _a.sent();
                        assert.equal(poller.getResult().name, keyName, "Unexpected key name in result from getKey().");
                        return [4 /*yield*/, poller.pollUntilDone()];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, poller.getResult()];
                    case 4:
                        getResult = _a.sent();
                        assert.equal(getResult.name, keyName, "Unexpected key name in result from getKey().");
                        return [4 /*yield*/, testClient.purgeKey(keyName)];
                    case 5:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can't get a deleted key that doesn't exist", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, error, poller, e_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, client.beginDeleteKey(keyName, testPollerProperties)];
                    case 2:
                        poller = _a.sent();
                        return [4 /*yield*/, poller.pollUntilDone()];
                    case 3:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 4:
                        e_4 = _a.sent();
                        error = e_4;
                        return [3 /*break*/, 5];
                    case 5:
                        assert.equal(error.message, "Key not found: " + keyName, "Unexpected key name in result from getKey().");
                        return [2 /*return*/];
                }
            });
        });
    });
});
//# sourceMappingURL=CRUD.test.js.map