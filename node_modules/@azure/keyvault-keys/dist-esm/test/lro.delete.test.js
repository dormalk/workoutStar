// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { __assign, __awaiter, __generator } from "tslib";
import * as assert from "assert";
import { testPollerProperties } from "./utils/recorderUtils";
import { env } from "@azure/test-utils-recorder";
import { authenticate } from "./utils/testAuthentication";
import { PollerStoppedError } from "@azure/core-lro";
describe("Keys client - Long Running Operations - delete", function () {
    var keyPrefix = "recover" + (env.CERTIFICATE_NAME || "KeyName");
    var keySuffix;
    var client;
    var testClient;
    var recorder;
    beforeEach(function () {
        return __awaiter(this, void 0, void 0, function () {
            var authentication;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, authenticate(this)];
                    case 1:
                        authentication = _a.sent();
                        keySuffix = authentication.keySuffix;
                        client = authentication.client;
                        testClient = authentication.testClient;
                        recorder = authentication.recorder;
                        return [2 /*return*/];
                }
            });
        });
    });
    afterEach(function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                recorder.stop();
                return [2 /*return*/];
            });
        });
    });
    // The tests follow
    it("can wait until a key is deleted", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, poller, deletedKey;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        return [4 /*yield*/, client.createKey(keyName, "RSA")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.beginDeleteKey(keyName, testPollerProperties)];
                    case 2:
                        poller = _a.sent();
                        assert.ok(poller.getOperationState().isStarted);
                        // The pending deleted can be obtained this way:
                        assert.equal(poller.getOperationState().result.name, keyName);
                        return [4 /*yield*/, poller.pollUntilDone()];
                    case 3:
                        deletedKey = _a.sent();
                        assert.equal(deletedKey.name, keyName);
                        assert.ok(poller.getOperationState().isCompleted);
                        // The final key can also be obtained this way:
                        assert.equal(poller.getOperationState().result.name, keyName);
                        return [4 /*yield*/, testClient.purgeKey(keyName)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can resume from a stopped poller", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, poller, serialized, resumePoller, deletedKey;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        return [4 /*yield*/, client.createKey(keyName, "RSA")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.beginDeleteKey(keyName, testPollerProperties)];
                    case 2:
                        poller = _a.sent();
                        assert.ok(poller.getOperationState().isStarted);
                        poller.pollUntilDone().catch(function (e) {
                            assert.ok(e instanceof PollerStoppedError);
                            assert.equal(e.name, "PollerStoppedError");
                            assert.equal(e.message, "This poller is already stopped");
                        });
                        return [4 /*yield*/, poller.poll()];
                    case 3:
                        _a.sent(); // Making sure it has some data
                        poller.stopPolling();
                        assert.ok(poller.isStopped());
                        assert.ok(!poller.getOperationState().isCompleted);
                        serialized = poller.toString();
                        return [4 /*yield*/, client.beginDeleteKey(keyName, __assign({ resumeFrom: serialized }, testPollerProperties))];
                    case 4:
                        resumePoller = _a.sent();
                        assert.ok(resumePoller.getOperationState().isStarted);
                        return [4 /*yield*/, resumePoller.pollUntilDone()];
                    case 5:
                        deletedKey = _a.sent();
                        assert.equal(deletedKey.name, keyName);
                        assert.ok(resumePoller.getOperationState().isCompleted);
                        return [4 /*yield*/, testClient.purgeKey(keyName)];
                    case 6:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
});
//# sourceMappingURL=lro.delete.test.js.map