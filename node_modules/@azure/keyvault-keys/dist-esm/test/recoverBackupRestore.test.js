// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { __awaiter, __generator } from "tslib";
import * as assert from "assert";
import { isNode } from "@azure/core-http";
import { isPlayingBack, testPollerProperties } from "./utils/recorderUtils";
import { retry } from "./utils/recorderUtils";
import { env } from "@azure/test-utils-recorder";
import { authenticate } from "./utils/testAuthentication";
import { assertThrowsAbortError } from "./utils/utils.common";
describe("Keys client - restore keys and recover backups", function () {
    var keyPrefix = "recover" + (env.KEY_NAME || "KeyName");
    var keySuffix;
    var client;
    var testClient;
    var recorder;
    before(function () {
        return __awaiter(this, void 0, void 0, function () {
            var authentication;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, authenticate(this)];
                    case 1:
                        authentication = _a.sent();
                        keySuffix = authentication.keySuffix;
                        client = authentication.client;
                        testClient = authentication.testClient;
                        recorder = authentication.recorder;
                        return [2 /*return*/];
                }
            });
        });
    });
    after(function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                recorder.stop();
                return [2 /*return*/];
            });
        });
    });
    // The tests follow
    it("can recover a deleted key", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, deletePoller, getDeletedResult, recoverPoller, getResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        return [4 /*yield*/, client.createKey(keyName, "RSA")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.beginDeleteKey(keyName, testPollerProperties)];
                    case 2:
                        deletePoller = _a.sent();
                        assert.equal(deletePoller.getResult().name, keyName, "Unexpected key name in result from deletePoller.getResult().");
                        return [4 /*yield*/, deletePoller.pollUntilDone()];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, deletePoller.getResult()];
                    case 4:
                        getDeletedResult = _a.sent();
                        assert.equal(getDeletedResult.name, keyName, "Unexpected key name in result from getKey().");
                        return [4 /*yield*/, client.beginRecoverDeletedKey(keyName, testPollerProperties)];
                    case 5:
                        recoverPoller = _a.sent();
                        return [4 /*yield*/, recoverPoller.pollUntilDone()];
                    case 6:
                        _a.sent();
                        return [4 /*yield*/, client.getKey(keyName)];
                    case 7:
                        getResult = _a.sent();
                        assert.equal(getResult.name, keyName, "Unexpected key name in result from getKey().");
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 8:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("fails if one tries to recover a non-existing deleted key", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, error, recoverPoller, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, client.beginRecoverDeletedKey(keyName, testPollerProperties)];
                    case 2:
                        recoverPoller = _a.sent();
                        return [4 /*yield*/, recoverPoller.pollUntilDone()];
                    case 3:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 4:
                        e_1 = _a.sent();
                        error = e_1;
                        return [3 /*break*/, 5];
                    case 5:
                        assert.equal(error.message, "Key not found: " + keyName);
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can generate a backup of a key", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        return [4 /*yield*/, client.createKey(keyName, "RSA")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.backupKey(keyName)];
                    case 2:
                        result = _a.sent();
                        if (isNode) {
                            assert.equal(Buffer.isBuffer(result), true, "Unexpected return value from backupKey()");
                        }
                        else {
                            assert.equal(result.constructor, Uint8Array, "Unexpected return value from backupKey()");
                        }
                        assert.ok(result.length > 0, "Unexpected length of buffer from backupKey()");
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can generate a backup of a key with requestOptions timeout", function () {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, client.backupKey("doesntmatter", { requestOptions: { timeout: 1 } })];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("fails to generate a backup of a non-existing key", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, error, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, client.backupKey(keyName)];
                    case 2:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 3:
                        e_2 = _a.sent();
                        error = e_2;
                        return [3 /*break*/, 4];
                    case 4:
                        assert.equal(error.message, "Key not found: " + keyName);
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can restore a key with a given backup", function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyName, backup, getResult;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                        return [4 /*yield*/, client.createKey(keyName, "RSA")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.backupKey(keyName)];
                    case 2:
                        backup = _a.sent();
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, retry(function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2 /*return*/, client.restoreKeyBackup(backup)];
                            }); }); })];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, client.getKey(keyName)];
                    case 5:
                        getResult = _a.sent();
                        assert.equal(getResult.name, keyName, "Unexpected key name in result from getKey().");
                        return [4 /*yield*/, testClient.flushKey(keyName)];
                    case 6:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can restore a key with requestOptions timeout", function () {
            return __awaiter(this, void 0, void 0, function () {
                var keyName, backup;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            keyName = testClient.formatName(keyPrefix + "-" + this.test.title + "-" + keySuffix);
                            return [4 /*yield*/, client.createKey(keyName, "RSA")];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, client.backupKey(keyName)];
                        case 2:
                            backup = _a.sent();
                            return [4 /*yield*/, testClient.flushKey(keyName)];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, client.restoreKeyBackup(backup, { requestOptions: { timeout: 1 } })];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 4:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("fails to restore a key with a malformed backup", function () {
        return __awaiter(this, void 0, void 0, function () {
            var backup, error, e_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        backup = new Uint8Array(8693);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, client.restoreKeyBackup(backup)];
                    case 2:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 3:
                        e_3 = _a.sent();
                        error = e_3;
                        return [3 /*break*/, 4];
                    case 4:
                        assert.equal(error.message, "Backup blob contains invalid or corrupt version.", "Unexpected error from restoreKeyBackup()");
                        return [2 /*return*/];
                }
            });
        });
    });
});
//# sourceMappingURL=recoverBackupRestore.test.js.map