import { __assign, __awaiter, __generator } from "tslib";
import { isNode, createPipelineFromOptions, isTokenCredential, signingPolicy, operationOptionsToRequestOptionsBase } from "@azure/core-http";
import { getTracer } from "@azure/core-tracing";
import { logger } from "./log";
import { parseKeyvaultIdentifier } from "./core/utils";
import { SDK_VERSION } from "./core/utils/constants";
import { KeyVaultClient } from "./core/keyVaultClient";
import { challengeBasedAuthenticationPolicy } from "./core/challengeBasedAuthenticationPolicy";
import { createHash as cryptoCreateHash, createVerify, publicEncrypt } from "crypto";
import * as constants from "constants";
// This is part of constructing the autogenerated client. In the future, it should not
// be required. See also: https://github.com/Azure/azure-sdk-for-js/issues/5508
var SERVICE_API_VERSION = "7.0";
/**
 * A client used to perform cryptographic operations with Azure Key Vault keys.
 */
var CryptographyClient = /** @class */ (function () {
    /**
     * Constructs a new instance of the Cryptography client for the given key
     *
     * Example usage:
     * ```ts
     * import { KeyClient, CryptographyClient } from "@azure/keyvault-keys";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;
     * let credentials = new DefaultAzureCredential();
     *
     * let keyClient = new KeyClient(vaultUrl, credentials);
     * let keyVaultKey = await keyClient.getKey("MyKey");
     *
     * let client = new CryptographyClient(keyVaultKey.id, credentials);
     * // or
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * ```
     * @param key The key to use during cryptography tasks.
     * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.
     * @param {PipelineOptions} [pipelineOptions={}] Optional. Pipeline options used to configure Key Vault API requests.
     *                                                         Omit this parameter to use the default pipeline configuration.
     * @memberof CryptographyClient
     */
    function CryptographyClient(key, // keyUrl or KeyVaultKey
    credential, pipelineOptions) {
        if (pipelineOptions === void 0) { pipelineOptions = {}; }
        var libInfo = "azsdk-js-keyvault-keys/" + SDK_VERSION;
        if (pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions.userAgentPrefix !== undefined
                ? pipelineOptions.userAgentOptions.userAgentPrefix + " " + libInfo
                : libInfo;
        }
        else {
            pipelineOptions.userAgentOptions = {
                userAgentPrefix: libInfo
            };
        }
        var authPolicy = isTokenCredential(credential)
            ? challengeBasedAuthenticationPolicy(credential)
            : signingPolicy(credential);
        var internalPipelineOptions = __assign(__assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                logPolicyOptions: {
                    allowedHeaderNames: [
                        "x-ms-keyvault-region",
                        "x-ms-keyvault-network-info",
                        "x-ms-keyvault-service-version"
                    ]
                }
            }
        });
        var pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new KeyVaultClient(credential, SERVICE_API_VERSION, pipeline);
        var parsed;
        if (typeof key === "string") {
            this.key = key;
            parsed = parseKeyvaultIdentifier("keys", this.key);
            this.hasTriedToGetKey = false;
        }
        else if (key.key) {
            this.key = key.key;
            parsed = parseKeyvaultIdentifier("keys", this.key.kid);
            this.hasTriedToGetKey = true;
        }
        else {
            throw new Error("The provided key is malformed as it does not have a value for the `key` property.");
        }
        if (parsed.name == "") {
            throw new Error("Could not find 'name' of key in key URL");
        }
        if (!parsed.version || parsed.version == "") {
            throw new Error("Could not find 'version' of key in key URL");
        }
        if (!parsed.vaultUrl || parsed.vaultUrl == "") {
            throw new Error("Could not find 'vaultUrl' of key in key URL");
        }
        this.vaultUrl = parsed.vaultUrl;
        this.name = parsed.name;
        this.version = parsed.version;
    }
    /**
     * @internal
     * @ignore
     * Retrieves the {@link JsonWebKey} from the Key Vault.
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.getKey();
     * ```
     * @param {GetKeyOptions} [options] Options for retrieving key.
     */
    CryptographyClient.prototype.getKey = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, span, key;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("getKey", requestOptions);
                        if (!(typeof this.key === "string")) return [3 /*break*/, 2];
                        if (!this.name || this.name === "") {
                            throw new Error("getKey requires a key with a name");
                        }
                        return [4 /*yield*/, this.client.getKey(this.vaultUrl, this.name, options && options.version ? options.version : this.version ? this.version : "", this.setParentSpan(span, requestOptions))];
                    case 1:
                        key = _a.sent();
                        return [2 /*return*/, key.key];
                    case 2: return [2 /*return*/, this.key];
                }
            });
        });
    };
    /**
     * Encrypts the given plaintext with the specified cryptography algorithm
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.encrypt("RSA1_5", Buffer.from("My Message"));
     * ```
     * @param {EncryptionAlgorithm} algorithm The algorithm to use.
     * @param {Uint8Array} plaintext The text to encrypt.
     * @param {EncryptOptions} [options] Additional options.
     */
    CryptographyClient.prototype.encrypt = function (algorithm, plaintext, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, span, keyPEM, padded, encrypted, keyPEM, encrypted, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("encrypt", requestOptions);
                        if (!isNode) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.fetchFullKeyIfPossible()];
                    case 1:
                        _a.sent();
                        if (typeof this.key !== "string") {
                            switch (algorithm) {
                                case "RSA1_5": {
                                    if (this.key.kty != "RSA") {
                                        span.end();
                                        throw new Error("Key type does not match algorithm");
                                    }
                                    if (this.key.keyOps && !this.key.keyOps.includes("encrypt")) {
                                        span.end();
                                        throw new Error("Key does not support the encrypt operation");
                                    }
                                    keyPEM = convertJWKtoPEM(this.key);
                                    padded = { key: keyPEM, padding: constants.RSA_PKCS1_PADDING };
                                    encrypted = publicEncrypt(padded, Buffer.from(plaintext));
                                    return [2 /*return*/, { result: encrypted, algorithm: algorithm, keyID: this.key.kid }];
                                }
                                case "RSA-OAEP": {
                                    if (this.key.kty != "RSA") {
                                        span.end();
                                        throw new Error("Key type does not match algorithm");
                                    }
                                    if (this.key.keyOps && !this.key.keyOps.includes("encrypt")) {
                                        span.end();
                                        throw new Error("Key does not support the encrypt operation");
                                    }
                                    keyPEM = convertJWKtoPEM(this.key);
                                    encrypted = publicEncrypt(keyPEM, Buffer.from(plaintext));
                                    return [2 /*return*/, { result: encrypted, algorithm: algorithm, keyID: this.key.kid }];
                                }
                            }
                        }
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, , 4, 5]);
                        return [4 /*yield*/, this.client.encrypt(this.vaultUrl, this.name, this.version, algorithm, plaintext, this.setParentSpan(span, requestOptions))];
                    case 3:
                        result = _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/, { result: result.result, algorithm: algorithm, keyID: this.getKeyID() }];
                }
            });
        });
    };
    /**
     * Decrypts the given ciphertext with the specified cryptography algorithm
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.decrypt("RSA1_5", encryptedBuffer);
     * ```
     * @param {EncryptionAlgorithm} algorithm The algorithm to use.
     * @param {Uint8Array} ciphertext The text to decrypt.
     * @param {EncryptOptions} [options] Additional options.
     */
    CryptographyClient.prototype.decrypt = function (algorithm, ciphertext, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, span, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("decrypt", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.decrypt(this.vaultUrl, this.name, this.version, algorithm, ciphertext, this.setParentSpan(span, requestOptions))];
                    case 2:
                        result = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, { result: result.result, keyID: this.getKeyID(), algorithm: algorithm }];
                }
            });
        });
    };
    /**
     * Wraps the given key using the specified cryptography algorithm
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.wrapKey("RSA1_5", keyToWrap);
     * ```
     * @param {KeyWrapAlgorithm} algorithm The encryption algorithm to use to wrap the given key.
     * @param {Uint8Array} key The key to wrap.
     * @param {EncryptOptions} [options] Additional options.
     */
    CryptographyClient.prototype.wrapKey = function (algorithm, key, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, span, keyPEM, padded, encrypted, keyPEM, encrypted, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("wrapKey", requestOptions);
                        if (!isNode) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.fetchFullKeyIfPossible()];
                    case 1:
                        _a.sent();
                        if (typeof this.key !== "string") {
                            switch (algorithm) {
                                case "RSA1_5": {
                                    if (this.key.kty != "RSA") {
                                        span.end();
                                        throw new Error("Key type does not match algorithm");
                                    }
                                    if (this.key.keyOps && !this.key.keyOps.includes("wrapKey")) {
                                        span.end();
                                        throw new Error("Key does not support the wrapKey operation");
                                    }
                                    keyPEM = convertJWKtoPEM(this.key);
                                    padded = { key: keyPEM, padding: constants.RSA_PKCS1_PADDING };
                                    encrypted = publicEncrypt(padded, Buffer.from(key));
                                    return [2 /*return*/, { result: encrypted, algorithm: algorithm, keyID: this.getKeyID() }];
                                }
                                case "RSA-OAEP": {
                                    if (this.key.kty != "RSA") {
                                        span.end();
                                        throw new Error("Key type does not match algorithm");
                                    }
                                    if (this.key.keyOps && !this.key.keyOps.includes("wrapKey")) {
                                        span.end();
                                        throw new Error("Key does not support the wrapKey operation");
                                    }
                                    keyPEM = convertJWKtoPEM(this.key);
                                    encrypted = publicEncrypt(keyPEM, Buffer.from(key));
                                    return [2 /*return*/, { result: encrypted, algorithm: algorithm, keyID: this.getKeyID() }];
                                }
                            }
                        }
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, , 4, 5]);
                        return [4 /*yield*/, this.client.wrapKey(this.vaultUrl, this.name, this.version, algorithm, key, this.setParentSpan(span, requestOptions))];
                    case 3:
                        result = _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/, { result: result.result, algorithm: algorithm, keyID: this.getKeyID() }];
                }
            });
        });
    };
    /**
     * Unwraps the given wrapped key using the specified cryptography algorithm
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.unwrapKey("RSA1_5", keyToUnwrap);
     * ```
     * @param {KeyWrapAlgorithm} algorithm The decryption algorithm to use to unwrap the key.
     * @param {Uint8Array} encryptedKey The encrypted key to unwrap.
     * @param {EncryptOptions} [options] Additional options.
     */
    CryptographyClient.prototype.unwrapKey = function (algorithm, encryptedKey, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, span, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("unwrapKey", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.unwrapKey(this.vaultUrl, this.name, this.version, algorithm, encryptedKey, this.setParentSpan(span, requestOptions))];
                    case 2:
                        result = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, { result: result.result, keyID: this.getKeyID() }];
                }
            });
        });
    };
    /**
     * Cryptographically sign the digest of a message
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.sign("RS256", digest);
     * ```
     * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use.
     * @param {Uint8Array} digest The digest of the data to sign.
     * @param {EncryptOptions} [options] Additional options.
     */
    CryptographyClient.prototype.sign = function (algorithm, digest, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, span, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("sign", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.sign(this.vaultUrl, this.name, this.version, algorithm, digest, this.setParentSpan(span, requestOptions))];
                    case 2:
                        result = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, { result: result.result, algorithm: algorithm, keyID: this.getKeyID() }];
                }
            });
        });
    };
    /**
     * Verify the signed message digest
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.verify("RS256", signedDigest, signature);
     * ```
     * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use to verify with.
     * @param {Uint8Array} digest The digest to verify.
     * @param {Uint8Array} signature The signature to verify the digest against.
     * @param {EncryptOptions} [options] Additional options.
     */
    CryptographyClient.prototype.verify = function (algorithm, digest, signature, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("verify", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.verify(this.vaultUrl, this.name, this.version, algorithm, digest, signature, this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, { result: response.value ? response.value : false, keyID: this.getKeyID() }];
                }
            });
        });
    };
    /**
     * Cryptographically sign a block of data
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.signData("RS256", message);
     * ```
     * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use.
     * @param {Uint8Array} data The data to sign.
     * @param {EncryptOptions} [options] Additional options.
     */
    CryptographyClient.prototype.signData = function (algorithm, data, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, span, digest, _a, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("signData", requestOptions);
                        _a = algorithm;
                        switch (_a) {
                            case "ES256": return [3 /*break*/, 1];
                            case "ES256K": return [3 /*break*/, 1];
                            case "PS256": return [3 /*break*/, 1];
                            case "RS256": return [3 /*break*/, 1];
                            case "ES384": return [3 /*break*/, 3];
                            case "PS384": return [3 /*break*/, 3];
                            case "RS384": return [3 /*break*/, 3];
                            case "ES512": return [3 /*break*/, 5];
                            case "PS512": return [3 /*break*/, 5];
                            case "RS512": return [3 /*break*/, 5];
                        }
                        return [3 /*break*/, 7];
                    case 1: return [4 /*yield*/, createHash("sha256", data)];
                    case 2:
                        digest = _b.sent();
                        return [3 /*break*/, 8];
                    case 3: return [4 /*yield*/, createHash("sha384", data)];
                    case 4:
                        digest = _b.sent();
                        return [3 /*break*/, 8];
                    case 5: return [4 /*yield*/, createHash("sha512", data)];
                    case 6:
                        digest = _b.sent();
                        return [3 /*break*/, 8];
                    case 7:
                        {
                            throw new Error("Unsupported signature algorithm");
                        }
                        _b.label = 8;
                    case 8:
                        _b.trys.push([8, , 10, 11]);
                        return [4 /*yield*/, this.client.sign(this.vaultUrl, this.name, this.version, algorithm, digest, this.setParentSpan(span, requestOptions))];
                    case 9:
                        result = _b.sent();
                        return [3 /*break*/, 11];
                    case 10:
                        span.end();
                        return [7 /*endfinally*/];
                    case 11: return [2 /*return*/, { result: result.result, algorithm: algorithm, keyID: this.getKeyID() }];
                }
            });
        });
    };
    /**
     * Verify the signed block of data
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.verifyData("RS256", signedMessage, signature);
     * ```
     * @param {KeySignatureAlgorithm} algorithm The algorithm to use to verify with.
     * @param {Uint8Array} data The signed block of data to verify.
     * @param {Uint8Array} signature The signature to verify the block against.
     * @param {EncryptOptions} [options] Additional options.
     */
    CryptographyClient.prototype.verifyData = function (algorithm, data, signature, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, span, keyPEM, verifier, keyPEM, verifier, keyPEM, verifier, digest, _a, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("verifyData", requestOptions);
                        if (!isNode) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.fetchFullKeyIfPossible()];
                    case 1:
                        _b.sent();
                        if (typeof this.key !== "string") {
                            switch (algorithm) {
                                case "RS256": {
                                    if (this.key.kty != "RSA") {
                                        throw new Error("Key type does not match algorithm");
                                    }
                                    if (this.key.keyOps && !this.key.keyOps.includes("verify")) {
                                        throw new Error("Key does not support the verify operation");
                                    }
                                    keyPEM = convertJWKtoPEM(this.key);
                                    verifier = createVerify("SHA256");
                                    verifier.update(Buffer.from(data));
                                    verifier.end();
                                    return [2 /*return*/, {
                                            result: verifier.verify(keyPEM, Buffer.from(signature)),
                                            keyID: this.getKeyID()
                                        }];
                                }
                                case "RS384": {
                                    if (this.key.kty != "RSA") {
                                        throw new Error("Key type does not match algorithm");
                                    }
                                    if (this.key.keyOps && !this.key.keyOps.includes("verify")) {
                                        throw new Error("Key does not support the verify operation");
                                    }
                                    keyPEM = convertJWKtoPEM(this.key);
                                    verifier = createVerify("SHA384");
                                    verifier.update(Buffer.from(data));
                                    verifier.end();
                                    return [2 /*return*/, {
                                            result: verifier.verify(keyPEM, Buffer.from(signature)),
                                            keyID: this.getKeyID()
                                        }];
                                }
                                case "RS512": {
                                    if (this.key.kty != "RSA") {
                                        throw new Error("Key type does not match algorithm");
                                    }
                                    if (this.key.keyOps && !this.key.keyOps.includes("verify")) {
                                        throw new Error("Key does not support the verify operation");
                                    }
                                    keyPEM = convertJWKtoPEM(this.key);
                                    verifier = createVerify("SHA512");
                                    verifier.update(Buffer.from(data));
                                    verifier.end();
                                    return [2 /*return*/, {
                                            result: verifier.verify(keyPEM, Buffer.from(signature)),
                                            keyID: this.getKeyID()
                                        }];
                                }
                            }
                        }
                        _b.label = 2;
                    case 2:
                        _a = algorithm;
                        switch (_a) {
                            case "ES256": return [3 /*break*/, 3];
                            case "ES256K": return [3 /*break*/, 3];
                            case "PS256": return [3 /*break*/, 3];
                            case "RS256": return [3 /*break*/, 3];
                            case "ES384": return [3 /*break*/, 5];
                            case "PS384": return [3 /*break*/, 5];
                            case "RS384": return [3 /*break*/, 5];
                            case "ES512": return [3 /*break*/, 7];
                            case "PS512": return [3 /*break*/, 7];
                            case "RS512": return [3 /*break*/, 7];
                        }
                        return [3 /*break*/, 9];
                    case 3: return [4 /*yield*/, createHash("sha256", data)];
                    case 4:
                        digest = _b.sent();
                        return [3 /*break*/, 10];
                    case 5: return [4 /*yield*/, createHash("sha384", data)];
                    case 6:
                        digest = _b.sent();
                        return [3 /*break*/, 10];
                    case 7: return [4 /*yield*/, createHash("sha512", data)];
                    case 8:
                        digest = _b.sent();
                        return [3 /*break*/, 10];
                    case 9:
                        {
                            throw new Error("Unsupported signature algorithm");
                        }
                        _b.label = 10;
                    case 10:
                        _b.trys.push([10, , 12, 13]);
                        return [4 /*yield*/, this.client.verify(this.vaultUrl, this.name, this.version, algorithm, digest, signature, this.setParentSpan(span, requestOptions))];
                    case 11:
                        result = _b.sent();
                        return [3 /*break*/, 13];
                    case 12:
                        span.end();
                        return [7 /*endfinally*/];
                    case 13: return [2 /*return*/, { result: result.value, keyID: this.getKeyID() }];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Attempts to fetch the key from the service.
     */
    CryptographyClient.prototype.fetchFullKeyIfPossible = function () {
        return __awaiter(this, void 0, void 0, function () {
            var result, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!!this.hasTriedToGetKey) return [3 /*break*/, 5];
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.getKey()];
                    case 2:
                        result = _b.sent();
                        this.key = result;
                        return [3 /*break*/, 4];
                    case 3:
                        _a = _b.sent();
                        return [3 /*break*/, 4];
                    case 4:
                        this.hasTriedToGetKey = true;
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Attempts to retrieve the ID of the key.
     */
    CryptographyClient.prototype.getKeyID = function () {
        var kid;
        if (typeof this.key !== "string") {
            kid = this.key.kid;
        }
        else {
            kid = this.key;
        }
        return kid;
    };
    /**
     * @internal
     * @ignore
     * Creates a span using the tracer that was set by the user.
     * @param {string} methodName The name of the method creating the span.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    CryptographyClient.prototype.createSpan = function (methodName, requestOptions) {
        var tracer = getTracer();
        return tracer.startSpan("CryptographyClient " + methodName, requestOptions && requestOptions.spanOptions);
    };
    /**
     * @internal
     * @ignore
     * Returns updated HTTP options with the given span as the parent of future spans,
     * if applicable.
     * @param {Span} span The span for the current operation.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    CryptographyClient.prototype.setParentSpan = function (span, options) {
        if (options === void 0) { options = {}; }
        if (span.isRecordingEvents()) {
            return __assign(__assign({}, options), { spanOptions: __assign(__assign({}, options.spanOptions), { parent: span }) });
        }
        else {
            return options;
        }
    };
    return CryptographyClient;
}());
export { CryptographyClient };
/**
 * @internal
 * @ignore
 * Encodes a length of a packet in DER format
 */
function encodeLength(length) {
    if (length <= 127) {
        return Uint8Array.of(length);
    }
    else if (length < 256) {
        return Uint8Array.of(0x81, length);
    }
    else if (length < 65536) {
        return Uint8Array.of(0x82, length >> 8, length & 0xff);
    }
    else {
        throw new Error("Unsupported length to encode");
    }
}
/**
 * @internal
 * @ignore
 * Encodes a buffer for DER, as sets the id to the given id
 */
function encodeBuffer(buffer, bufferId) {
    if (buffer.length == 0) {
        return buffer;
    }
    var result = new Uint8Array(buffer);
    // If the high bit is set, prepend a 0
    if ((result[0] & 0x80) === 0x80) {
        var array = new Uint8Array(result.length + 1);
        array[0] = 0;
        array.set(result, 1);
        result = array;
    }
    // Prepend the DER header for this buffer
    var encodedLength = encodeLength(result.length);
    var totalLength = 1 + encodedLength.length + result.length;
    var outputBuffer = new Uint8Array(totalLength);
    outputBuffer[0] = bufferId;
    outputBuffer.set(encodedLength, 1);
    outputBuffer.set(result, 1 + encodedLength.length);
    return outputBuffer;
}
/**
 * @internal
 * @ignore
 * Encode a JWK to PEM format. To do so, it internally repackages the JWK as a DER
 * that is then encoded as a PEM.
 */
export function convertJWKtoPEM(key) {
    if (!key.n || !key.e) {
        throw new Error("Unsupported key format for local operations");
    }
    var encoded_n = encodeBuffer(key.n, 0x2); // INTEGER
    var encoded_e = encodeBuffer(key.e, 0x2); // INTEGER
    var encoded_ne = new Uint8Array(encoded_n.length + encoded_e.length);
    encoded_ne.set(encoded_n, 0);
    encoded_ne.set(encoded_e, encoded_n.length);
    var full_encoded = encodeBuffer(encoded_ne, 0x30); //SEQUENCE
    var buffer = Buffer.from(full_encoded).toString("base64");
    var beginBanner = "-----BEGIN RSA PUBLIC KEY-----\n";
    var endBanner = "-----END RSA PUBLIC KEY-----";
    /*
     Fill in the PEM with 64 character lines as per RFC:
  
     "To represent the encapsulated text of a PEM message, the encoding
     function's output is delimited into text lines (using local
     conventions), with each line except the last containing exactly 64
     printable characters and the final line containing 64 or fewer
     printable characters."
    */
    var outputString = beginBanner;
    var lines = buffer.match(/.{1,64}/g);
    if (lines) {
        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
            var line = lines_1[_i];
            outputString += line;
            outputString += "\n";
        }
    }
    else {
        throw new Error("Could not create correct PEM");
    }
    outputString += endBanner;
    return outputString;
}
/**
 * @internal
 * @ignore
 * Use the platform-local hashing functionality
 */
function createHash(algorithm, data) {
    return __awaiter(this, void 0, void 0, function () {
        var hash, digest, _a, _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (!isNode) return [3 /*break*/, 1];
                    hash = cryptoCreateHash(algorithm);
                    hash.update(Buffer.from(data));
                    digest = hash.digest();
                    return [2 /*return*/, digest];
                case 1:
                    if (!(window && window.crypto && window.crypto.subtle)) return [3 /*break*/, 3];
                    _b = (_a = Buffer).from;
                    return [4 /*yield*/, window.crypto.subtle.digest(algorithm, Buffer.from(data))];
                case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                case 3: throw new Error("Browser does not support cryptography functions");
            }
        });
    });
}
//# sourceMappingURL=cryptographyClient.js.map