// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* eslint @typescript-eslint/member-ordering: 0 */
import { __assign, __asyncGenerator, __asyncValues, __await, __awaiter, __generator, __rest } from "tslib";
import { createPipelineFromOptions, isTokenCredential, operationOptionsToRequestOptionsBase, signingPolicy } from "@azure/core-http";
import { getTracer } from "@azure/core-tracing";
import { logger } from "./log";
import "@azure/core-paging";
import { KeyVaultClient } from "./core/keyVaultClient";
import { SDK_VERSION } from "./core/utils/constants";
import { challengeBasedAuthenticationPolicy } from "./core/challengeBasedAuthenticationPolicy";
import { DeleteKeyPoller } from "./lro/delete/poller";
import { RecoverDeletedKeyPoller } from "./lro/recover/poller";
import { parseKeyvaultIdentifier as parseKeyvaultEntityIdentifier } from "./core/utils";
import { CryptographyClient } from "./cryptographyClient";
export { CryptographyClient, logger };
// This is part of constructing the autogenerated client. In the future, it should not
// be required. See also: https://github.com/Azure/azure-sdk-for-js/issues/5508
var SERVICE_API_VERSION = "7.0";
/**
 * The KeyClient provides methods to manage {@link KeyVaultKey} in the
 * Azure Key Vault. The client supports creating, retrieving, updating,
 * deleting, purging, backing up, restoring and listing KeyVaultKeys. The
 * client also supports listing {@link DeletedKey} for a soft-delete enabled Azure Key
 * Vault.
 */
var KeyClient = /** @class */ (function () {
    /**
     * Creates an instance of KeyClient.
     *
     * Example usage:
     * ```ts
     * import { KeyClient } from "@azure/keyvault-keys";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;
     * let credentials = new DefaultAzureCredential();
     *
     * let client = new KeyClient(vaultUrl, credentials);
     * ```
     * @param {string} vaultUrl the URL of the Key Vault. It should have this shape: https://${your-key-vault-name}.vault.azure.net
     * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.
     * @param {PipelineOptions} [pipelineOptions] Pipeline options used to configure Key Vault API requests. Omit this parameter to use the default pipeline configuration.
     * @memberof KeyClient
     */
    function KeyClient(vaultUrl, credential, pipelineOptions) {
        if (pipelineOptions === void 0) { pipelineOptions = {}; }
        /**
         * @internal
         * @ignore
         * A self reference that bypasses private methods, for the pollers.
         */
        this.pollerClient = {
            recoverDeletedKey: this.recoverDeletedKey.bind(this),
            getKey: this.getKey.bind(this),
            deleteKey: this.deleteKey.bind(this),
            getDeletedKey: this.getDeletedKey.bind(this)
        };
        this.vaultUrl = vaultUrl;
        var libInfo = "azsdk-js-keyvault-keys/" + SDK_VERSION;
        if (pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions.userAgentPrefix !== undefined
                ? pipelineOptions.userAgentOptions.userAgentPrefix + " " + libInfo
                : libInfo;
        }
        else {
            pipelineOptions.userAgentOptions = {
                userAgentPrefix: libInfo
            };
        }
        var authPolicy = isTokenCredential(credential)
            ? challengeBasedAuthenticationPolicy(credential)
            : signingPolicy(credential);
        var internalPipelineOptions = __assign(__assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                logPolicyOptions: {
                    allowedHeaderNames: [
                        "x-ms-keyvault-region",
                        "x-ms-keyvault-network-info",
                        "x-ms-keyvault-service-version"
                    ]
                }
            }
        });
        var pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new KeyVaultClient(credential, SERVICE_API_VERSION, pipeline);
    }
    /**
     * @internal
     * @ignore
     * Sends a delete request for the given KeyVault Key's name to the KeyVault service.
     * Since the KeyVault Key won't be immediately deleted, we have {@link beginDeleteKey}.
     * @param {string} name The name of the KeyVault Key.
     * @param {DeleteKeyOptions} [options] Optional parameters for the underlying HTTP request.
     */
    KeyClient.prototype.deleteKey = function (name, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("deleteKey", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.deleteKey(this.vaultUrl, name, this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Sends a request to recover a deleted KeyVault Key based on the given name.
     * Since the KeyVault Key won't be immediately recover the deleted key, we have {@link beginRecoverDeletedKey}.
     * @param {string} name The name of the KeyVault Key.
     * @param {RecoverDeletedKeyOptions} [options] Optional parameters for the underlying HTTP request.
     */
    KeyClient.prototype.recoverDeletedKey = function (name, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("recoverDeletedKey", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.recoverDeletedKey(this.vaultUrl, name, this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * The create key operation can be used to create any key type in Azure Key Vault. If the named key
     * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create
     * permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * // Create an elliptic-curve key:
     * let result = await client.createKey("MyKey", "EC");
     * ```
     * @summary Creates a new key, stores it, then returns key parameters and properties to the client.
     * @param {string} name The name of the key.
     * @param {JsonWebKeyType} keyType The type of the key. One of the following: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'.
     * @param {CreateKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.createKey = function (name, keyType, options) {
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, enabled, notBefore, expires, remainingOptions, unflattenedOptions, span, response, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 5];
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        enabled = requestOptions.enabled, notBefore = requestOptions.notBefore, expires = requestOptions.expiresOn, remainingOptions = __rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                        unflattenedOptions = __assign(__assign({}, remainingOptions), { keyAttributes: {
                                enabled: enabled,
                                notBefore: notBefore,
                                expires: expires
                            } });
                        span = this.createSpan("createKey", unflattenedOptions);
                        response = void 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.createKey(this.vaultUrl, name, keyType, this.setParentSpan(span, unflattenedOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                    case 5: return [4 /*yield*/, this.client.createKey(this.vaultUrl, name, keyType, options)];
                    case 6:
                        response = _a.sent();
                        return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * The createEcKey method creates a new eliptic curve key in Azure Key Vault. If the named key
     * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create
     * permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let result = await client.createEcKey("MyKey", { curve: "P-256" });
     * ```
     * @summary Creates a new key, stores it, then returns key parameters and properties to the client.
     * @param {string} name The name of the key.
     * @param {CreateEcKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.createEcKey = function (name, options) {
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, enabled, notBefore, expires, remainingOptions, unflattenedOptions, span, response, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 5];
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        enabled = requestOptions.enabled, notBefore = requestOptions.notBefore, expires = requestOptions.expiresOn, remainingOptions = __rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                        unflattenedOptions = __assign(__assign({}, remainingOptions), { keyAttributes: {
                                enabled: enabled,
                                notBefore: notBefore,
                                expires: expires
                            } });
                        span = this.createSpan("createEcKey", unflattenedOptions);
                        response = void 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.createKey(this.vaultUrl, name, options.hsm ? "EC-HSM" : "EC", this.setParentSpan(span, unflattenedOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                    case 5: return [4 /*yield*/, this.client.createKey(this.vaultUrl, name, "EC", options)];
                    case 6:
                        response = _a.sent();
                        return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * The createRSAKey method creates a new RSA key in Azure Key Vault. If the named key
     * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create
     * permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let result = await client.createRsaKey("MyKey", { keySize: 2048 });
     * ```
     * @summary Creates a new key, stores it, then returns key parameters and properties to the client.
     * @param {string} name The name of the key.
     * @param {CreateRsaKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.createRsaKey = function (name, options) {
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, enabled, notBefore, expires, remainingOptions, unflattenedOptions, span, response, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 5];
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        enabled = requestOptions.enabled, notBefore = requestOptions.notBefore, expires = requestOptions.expiresOn, remainingOptions = __rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                        unflattenedOptions = __assign(__assign({}, remainingOptions), { keyAttributes: {
                                enabled: enabled,
                                notBefore: notBefore,
                                expires: expires
                            } });
                        span = this.createSpan("createRsaKey", unflattenedOptions);
                        response = void 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.createKey(this.vaultUrl, name, options.hsm ? "RSA-HSM" : "RSA", this.setParentSpan(span, unflattenedOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                    case 5: return [4 /*yield*/, this.client.createKey(this.vaultUrl, name, "RSA", options)];
                    case 6:
                        response = _a.sent();
                        return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * The import key operation may be used to import any key type into an Azure Key Vault. If the
     * named key already exists, Azure Key Vault creates a new version of the key. This operation
     * requires the keys/import permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * // Key contents in myKeyContents
     * let result = await client.importKey("MyKey", myKeyContents);
     * ```
     * @summary Imports an externally created key, stores it, and returns key parameters and properties
     * to the client.
     * @param {string} name Name for the imported key.
     * @param {JsonWebKey} key The JSON web key.
     * @param {ImportKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.importKey = function (name, key, options) {
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, enabled, notBefore, expires, hsm, remainingOptions, unflattenedOptions, span, response, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 5];
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        enabled = requestOptions.enabled, notBefore = requestOptions.notBefore, expires = requestOptions.expiresOn, hsm = requestOptions.hardwareProtected, remainingOptions = __rest(requestOptions, ["enabled", "notBefore", "expiresOn", "hardwareProtected"]);
                        unflattenedOptions = __assign(__assign({}, remainingOptions), { keyAttributes: {
                                enabled: enabled,
                                notBefore: notBefore,
                                expires: expires,
                                hsm: hsm
                            } });
                        span = this.createSpan("importKey", unflattenedOptions);
                        response = void 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.importKey(this.vaultUrl, name, key, this.setParentSpan(span, unflattenedOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                    case 5: return [4 /*yield*/, this.client.importKey(this.vaultUrl, name, key, options)];
                    case 6:
                        response = _a.sent();
                        return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * The delete operation applies to any key stored in Azure Key Vault. Individual versions
     * of a key can not be deleted, only all versions of a given key at once.
     *
     * This function returns a Long Running Operation poller that allows you to wait indifinetly until the key is deleted.
     *
     * This operation requires the keys/delete permission.
     *
     * Example usage:
     * ```ts
     * const client = new KeyClient(url, credentials);
     * await client.createKey("MyKey", "EC");
     * const poller = await client.beginDeleteKey("MyKey");
     *
     * // Serializing the poller
     * const serialized = poller.toString();
     * // A new poller can be created with:
     * // await client.beginDeleteKey("MyKey", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedKey = await poller.pollUntilDone();
     * console.log(deletedKey);
     * ```
     * @summary Deletes a key from a specified key vault.
     * @param {string} name The name of the key.
     * @param {BeginDeleteKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.beginDeleteKey = function (name, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, poller;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        poller = new DeleteKeyPoller({
                            name: name,
                            client: this.pollerClient,
                            intervalInMs: options.intervalInMs,
                            resumeFrom: options.resumeFrom,
                            requestOptions: requestOptions
                        });
                        // This will initialize the poller's operation (the deletion of the key).
                        return [4 /*yield*/, poller.poll()];
                    case 1:
                        // This will initialize the poller's operation (the deletion of the key).
                        _a.sent();
                        return [2 /*return*/, poller];
                }
            });
        });
    };
    /**
     * The updateKeyProperties method changes specified properties of an existing stored key. Properties that
     * are not specified in the request are left unchanged. The value of a key itself cannot be
     * changed. This operation requires the keys/set permission.
     *
     * Example usage:
     * ```ts
     * let keyName = "MyKey";
     * let client = new KeyClient(url, credentials);
     * let key = await client.getKey(keyName);
     * let result = await client.updateKeyProperties(keyName, key.version, { enabled: false });
     * ```
     * @summary Updates the properties associated with a specified key in a given key vault.
     * @param {string} name The name of the key.
     * @param {string} keyVersion The version of the key.
     * @param {UpdateKeyPropertiesOptions} [options] The optional parameters.
     */
    KeyClient.prototype.updateKeyProperties = function (name, keyVersion, options) {
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, enabled, notBefore, expires, remainingOptions, unflattenedOptions, span, response, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 5];
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        enabled = requestOptions.enabled, notBefore = requestOptions.notBefore, expires = requestOptions.expiresOn, remainingOptions = __rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                        unflattenedOptions = __assign(__assign({}, remainingOptions), { keyAttributes: {
                                enabled: enabled,
                                notBefore: notBefore,
                                expires: expires
                            } });
                        span = this.createSpan("updateKeyProperties", unflattenedOptions);
                        response = void 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.updateKey(this.vaultUrl, name, keyVersion, this.setParentSpan(span, unflattenedOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                    case 5: return [4 /*yield*/, this.client.updateKey(this.vaultUrl, name, keyVersion, options)];
                    case 6:
                        response = _a.sent();
                        return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * The get method gets a specified key and is applicable to any key stored in Azure Key Vault.
     * This operation requires the keys/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let key = await client.getKey("MyKey");
     * ```
     * @summary Get a specified key from a given key vault.
     * @param {string} name The name of the key.
     * @param {GetKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.getKey = function (name, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("getKey", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.getKey(this.vaultUrl, name, options && options.version ? options.version : "", this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * The getDeletedKey method returns the specified deleted key along with its properties.
     * This operation requires the keys/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let key = await client.getDeletedKey("MyDeletedKey");
     * ```
     * @summary Gets the specified deleted key.
     * @param {string} name The name of the key.
     * @param {GetDeletedKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.getDeletedKey = function (name, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var responseOptions, span, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        responseOptions = operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("getDeletedKey", responseOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.getDeletedKey(this.vaultUrl, name, this.setParentSpan(span, responseOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * The purge deleted key operation removes the key permanently, without the possibility of
     * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation
     * requires the keys/purge permission.
     *
     * Example usage:
     * ```ts
     * const client = new KeyClient(url, credentials);
     * const deletePoller = await client.beginDeleteKey("MyKey")
     * await deletePoller.pollUntilDone();
     * await client.purgeDeletedKey("MyKey");
     * ```
     * @summary Permanently deletes the specified key.
     * @param name The name of the key.
     * @param {PurgeDeletedKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.purgeDeletedKey = function (name, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var responseOptions, span;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        responseOptions = operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("purgeDeletedKey", responseOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.purgeDeletedKey(this.vaultUrl, name, this.setParentSpan(span, responseOptions))];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Recovers the deleted key in the specified vault. This operation can only be performed on a
     * soft-delete enabled vault.
     *
     * This function returns a Long Running Operation poller that allows you to wait indifinetly until the deleted key is recovered.
     *
     * This operation requires the keys/recover permission.
     *
     * Example usage:
     * ```ts
     * const client = new KeyClient(url, credentials);
     * await client.createKey("MyKey", "EC");
     * const deletePoller = await client.beginDeleteKey("MyKey");
     * await deletePoller.pollUntilDone();
     * const poller = await client.beginRecoverDeletedKey("MyKey");
     *
     * // Serializing the poller
     * const serialized = poller.toString();
     * // A new poller can be created with:
     * // await client.beginRecoverDeletedKey("MyKey", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const key = await poller.pollUntilDone();
     * console.log(key);
     * ```
     * @summary Recovers the deleted key to the latest version.
     * @param name The name of the deleted key.
     * @param {BeginRecoverDeletedKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.beginRecoverDeletedKey = function (name, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, poller;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        poller = new RecoverDeletedKeyPoller({
                            name: name,
                            client: this.pollerClient,
                            intervalInMs: options.intervalInMs,
                            resumeFrom: options.resumeFrom,
                            requestOptions: requestOptions
                        });
                        // This will initialize the poller's operation (the deletion of the key).
                        return [4 /*yield*/, poller.poll()];
                    case 1:
                        // This will initialize the poller's operation (the deletion of the key).
                        _a.sent();
                        return [2 /*return*/, poller];
                }
            });
        });
    };
    /**
     * Requests that a backup of the specified key be downloaded to the client. All versions of the
     * key will be downloaded. This operation requires the keys/backup permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let backupContents = await client.backupKey("MyKey");
     * ```
     * @summary Backs up the specified key.
     * @param {string} name The name of the key.
     * @param {BackupKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.backupKey = function (name, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("backupKey", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.backupKey(this.vaultUrl, name, this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, response.value];
                }
            });
        });
    };
    /**
     * Restores a backed up key, and all its versions, to a vault. This operation requires the
     * keys/restore permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let backupContents = await client.backupKey("MyKey");
     * // ...
     * let key = await client.restoreKeyBackup(backupContents);
     * ```
     * @summary Restores a backed up key to a vault.
     * @param {Uint8Array} backup The backup blob associated with a key bundle.
     * @param {RestoreKeyBackupOptions} [options] The optional parameters.
     */
    KeyClient.prototype.restoreKeyBackup = function (backup, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("restoreKeyBackup", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.restoreKey(this.vaultUrl, backup, this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listPropertiesOfKeyVersions}.
     * @param {string} name The name of the KeyVault Key.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListPropertiesOfKeyVersionsOptions} [options] Common options for the iterative endpoints.
     */
    KeyClient.prototype.listPropertiesOfKeyVersionsPage = function (name, continuationState, options) {
        return __asyncGenerator(this, arguments, function listPropertiesOfKeyVersionsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = __assign({ maxresults: continuationState.maxPageSize }, options);
                        return [4 /*yield*/, __await(this.client.getKeyVersions(this.vaultUrl, name, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 4];
                        return [4 /*yield*/, __await(currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 10];
                        return [4 /*yield*/, __await(this.client.getKeyVersions(continuationState.continuationToken, name, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 8];
                        return [4 /*yield*/, __await(currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 8: return [3 /*break*/, 10];
                    case 9: return [3 /*break*/, 4];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listPropertiesOfKeyVersions}.
     * @param {string} name The name of the KeyVault Key.
     * @param {ListPropertiesOfKeyVersionsOptions} [options] Common options for the iterative endpoints.
     */
    KeyClient.prototype.listPropertiesOfKeyVersionsAll = function (name, options) {
        return __asyncGenerator(this, arguments, function listPropertiesOfKeyVersionsAll_1() {
            var f, _a, _b, page, _i, page_1, item, e_1_1;
            var e_1, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = __asyncValues(this.listPropertiesOfKeyVersionsPage(name, f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, __await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_1 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_1.length)) return [3 /*break*/, 8];
                        item = page_1[_i];
                        return [4 /*yield*/, __await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, __await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates all versions of the given key in the vault. The full key identifier, properties, and tags are provided
     * in the response. This operation requires the keys/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * for await (const keyProperties of client.listPropertiesOfKeyVersions("MyKey")) {
     *   const key = await client.getKey(keyProperties.name);
     *   console.log("key version: ", key);
     * }
     * ```
     * @param {string} name Name of the key to fetch versions for
     * @param {ListPropertiesOfKeyVersionsOptions} [options] The optional parameters.
     */
    KeyClient.prototype.listPropertiesOfKeyVersions = function (name, options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var requestOptions = operationOptionsToRequestOptionsBase(options);
        var span = this.createSpan("listPropertiesOfKeyVersions", requestOptions);
        var updatedOptions = __assign(__assign({}, requestOptions), this.setParentSpan(span, requestOptions));
        var iter = this.listPropertiesOfKeyVersionsAll(name, updatedOptions);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listPropertiesOfKeyVersionsPage(name, settings, updatedOptions);
            },
            _a;
    };
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listPropertiesOfKeys}.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListPropertiesOfKeysOptions} [options] Common options for the iterative endpoints.
     */
    KeyClient.prototype.listPropertiesOfKeysPage = function (continuationState, options) {
        return __asyncGenerator(this, arguments, function listPropertiesOfKeysPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = __assign({ maxresults: continuationState.maxPageSize }, options);
                        return [4 /*yield*/, __await(this.client.getKeys(this.vaultUrl, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 4];
                        return [4 /*yield*/, __await(currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 10];
                        return [4 /*yield*/, __await(this.client.getKeys(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 8];
                        return [4 /*yield*/, __await(currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 8: return [3 /*break*/, 10];
                    case 9: return [3 /*break*/, 4];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listPropertiesOfKeys}.
     * @param {ListPropertiesOfKeysOptions} [options] Common options for the iterative endpoints.
     */
    KeyClient.prototype.listPropertiesOfKeysAll = function (options) {
        return __asyncGenerator(this, arguments, function listPropertiesOfKeysAll_1() {
            var f, _a, _b, page, _i, page_2, item, e_2_1;
            var e_2, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = __asyncValues(this.listPropertiesOfKeysPage(f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, __await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_2 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_2.length)) return [3 /*break*/, 8];
                        item = page_2[_i];
                        return [4 /*yield*/, __await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_2_1 = _d.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, __await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_2) throw e_2.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates the latest version of all keys in the vault.  The full key identifier and properties are provided
     * in the response. No values are returned for the keys. This operations requires the keys/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * for await (const keyProperties of client.listPropertiesOfKeys()) {
     *   const key = await client.getKey(keyProperties.name);
     *   console.log("key: ", key);
     * }
     * ```
     * @summary List all keys in the vault
     * @param {ListPropertiesOfKeysOptions} [options] The optional parameters.
     */
    KeyClient.prototype.listPropertiesOfKeys = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var requestOptions = operationOptionsToRequestOptionsBase(options);
        var span = this.createSpan("listPropertiesOfKeys", requestOptions);
        var updatedOptions = __assign(__assign({}, requestOptions), this.setParentSpan(span, requestOptions));
        var iter = this.listPropertiesOfKeysAll(updatedOptions);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listPropertiesOfKeysPage(settings, updatedOptions);
            },
            _a;
    };
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listDeletedKeys}.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListDeletedKeysOptions} [options] Common options for the iterative endpoints.
     */
    KeyClient.prototype.listDeletedKeysPage = function (continuationState, options) {
        return __asyncGenerator(this, arguments, function listDeletedKeysPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = __assign({ maxresults: continuationState.maxPageSize }, options);
                        return [4 /*yield*/, __await(this.client.getDeletedKeys(this.vaultUrl, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 4];
                        return [4 /*yield*/, __await(currentSetResponse.value.map(this.getDeletedKeyFromKeyItem))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 10];
                        return [4 /*yield*/, __await(this.client.getDeletedKeys(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 8];
                        return [4 /*yield*/, __await(currentSetResponse.value.map(this.getDeletedKeyFromKeyItem))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 8: return [3 /*break*/, 10];
                    case 9: return [3 /*break*/, 4];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listDeletedKeys}.
     * @param {ListDeletedKeysOptions} [options] Common options for the iterative endpoints.
     */
    KeyClient.prototype.listDeletedKeysAll = function (options) {
        return __asyncGenerator(this, arguments, function listDeletedKeysAll_1() {
            var f, _a, _b, page, _i, page_3, item, e_3_1;
            var e_3, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = __asyncValues(this.listDeletedKeysPage(f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, __await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_3 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_3.length)) return [3 /*break*/, 8];
                        item = page_3[_i];
                        return [4 /*yield*/, __await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_3_1 = _d.sent();
                        e_3 = { error: e_3_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, __await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_3) throw e_3.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates the deleted keys in the vault.  The full key identifier and properties are provided
     * in the response. No values are returned for the keys. This operations requires the keys/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * for await (const deletedKey of client.listDeletedKeys()) {
     *   const deletedKey = await client.getKey(deletedKey.name);
     *   console.log("deleted key: ", deletedKey);
     * }
     * ```
     * @summary List all keys in the vault
     * @param {ListDeletedKeysOptions} [options] The optional parameters.
     */
    KeyClient.prototype.listDeletedKeys = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var requestOptions = operationOptionsToRequestOptionsBase(options);
        var span = this.createSpan("listDeletedKeys", requestOptions);
        var updatedOptions = __assign(__assign({}, options), this.setParentSpan(span, requestOptions));
        var iter = this.listDeletedKeysAll(updatedOptions);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listDeletedKeysPage(settings, updatedOptions);
            },
            _a;
    };
    /**
     * @internal
     * @ignore
     * Shapes the exposed {@link KeyVaultKey} based on either a received key bundle or deleted key bundle.
     */
    KeyClient.prototype.getKeyFromKeyBundle = function (bundle) {
        var keyBundle = bundle;
        var deletedKeyBundle = bundle;
        var parsedId = parseKeyvaultEntityIdentifier("keys", keyBundle.key ? keyBundle.key.kid : undefined);
        var attributes = keyBundle.attributes || {};
        delete keyBundle.attributes;
        var resultObject = {
            key: keyBundle.key,
            id: keyBundle.key ? keyBundle.key.kid : undefined,
            name: parsedId.name,
            keyOperations: keyBundle.key ? keyBundle.key.keyOps : undefined,
            keyType: keyBundle.key ? keyBundle.key.kty : undefined,
            properties: __assign(__assign(__assign({ id: keyBundle.key ? keyBundle.key.kid : undefined, name: parsedId.name, expiresOn: attributes.expires, createdOn: attributes.created, updatedOn: attributes.updated, vaultUrl: parsedId.vaultUrl }, keyBundle), parsedId), attributes)
        };
        if (deletedKeyBundle.deletedDate) {
            resultObject.properties.deletedOn = deletedKeyBundle.deletedDate;
            delete resultObject.properties.deletedDate;
        }
        if (attributes.vaultUrl) {
            delete resultObject.properties.vaultUrl;
        }
        if (attributes.expires) {
            delete resultObject.properties.expires;
        }
        if (attributes.created) {
            delete resultObject.properties.created;
        }
        if (attributes.updated) {
            delete resultObject.properties.updated;
        }
        return resultObject;
    };
    /**
     * @internal
     * @ignore
     * Shapes the exposed {@link DeletedKey} based on a received KeyItem.
     */
    KeyClient.prototype.getDeletedKeyFromKeyItem = function (keyItem) {
        var parsedId = parseKeyvaultEntityIdentifier("keys", keyItem.kid);
        var attributes = keyItem.attributes || {};
        var abstractProperties = __assign(__assign(__assign({ id: keyItem.kid, name: parsedId.name, deletedOn: attributes.deletedDate, expiresOn: attributes.expires, createdOn: attributes.created, updatedOn: attributes.updated }, keyItem), parsedId), keyItem.attributes);
        if (abstractProperties.deletedDate) {
            delete abstractProperties.deletedDate;
        }
        if (abstractProperties.expires) {
            delete abstractProperties.expires;
        }
        if (abstractProperties.created) {
            delete abstractProperties.created;
        }
        if (abstractProperties.updated) {
            delete abstractProperties.updated;
        }
        return {
            key: keyItem,
            id: keyItem.kid,
            name: abstractProperties.name,
            properties: abstractProperties
        };
    };
    /**
     * @internal
     * @ignore
     * Shapes the exposed {@link KeyProperties} based on a received KeyItem.
     */
    KeyClient.prototype.getKeyPropertiesFromKeyItem = function (keyItem) {
        var parsedId = parseKeyvaultEntityIdentifier("keys", keyItem.kid);
        var attributes = keyItem.attributes || {};
        var resultObject = __assign(__assign(__assign({ createdOn: attributes.created, updatedOn: attributes.updated, vaultUrl: parsedId.vaultUrl }, keyItem), parsedId), keyItem.attributes);
        delete resultObject.attributes;
        if (keyItem.attributes.expires) {
            resultObject.expiresOn = keyItem.attributes.expires;
            delete resultObject.expires;
        }
        return resultObject;
    };
    /**
     * @internal
     * @ignore
     * Creates a span using the tracer that was set by the user.
     * @param {string} methodName The name of the method creating the span.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    KeyClient.prototype.createSpan = function (methodName, requestOptions) {
        var tracer = getTracer();
        return tracer.startSpan(methodName, requestOptions && requestOptions.spanOptions);
    };
    /**
     * @internal
     * @ignore
     * Returns updated HTTP options with the given span as the parent of future spans,
     * if applicable.
     * @param {Span} span The span for the current operation.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    KeyClient.prototype.setParentSpan = function (span, options) {
        if (options === void 0) { options = {}; }
        if (span.isRecordingEvents()) {
            return __assign(__assign({}, options), { spanOptions: __assign(__assign({}, options.spanOptions), { parent: span }) });
        }
        else {
            return options;
        }
    };
    return KeyClient;
}());
export { KeyClient };
//# sourceMappingURL=index.js.map