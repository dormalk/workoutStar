/*!
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Azure KeyVault Keys SDK for JavaScript - 4.0.0
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreHttp = require('@azure/core-http');
var coreTracing = require('@azure/core-tracing');
var logger$1 = require('@azure/logger');
require('@azure/core-paging');
var coreLro = require('@azure/core-lro');
var url = require('url');
var crypto = require('crypto');
var constants = require('constants');

// Copyright (c) Microsoft Corporation.
/**
 * The @azure/logger configuration for this package.
 */
var logger = logger$1.createClientLogger("keyvault-keys");

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
var Attributes = {
    serializedName: "Attributes",
    type: {
        name: "Composite",
        className: "Attributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            notBefore: {
                serializedName: "nbf",
                type: {
                    name: "UnixTime"
                }
            },
            expires: {
                serializedName: "exp",
                type: {
                    name: "UnixTime"
                }
            },
            created: {
                readOnly: true,
                serializedName: "created",
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                readOnly: true,
                serializedName: "updated",
                type: {
                    name: "UnixTime"
                }
            }
        }
    }
};
var JsonWebKey = {
    serializedName: "JsonWebKey",
    type: {
        name: "Composite",
        className: "JsonWebKey",
        modelProperties: {
            kid: {
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            kty: {
                serializedName: "kty",
                type: {
                    name: "String"
                }
            },
            keyOps: {
                serializedName: "key_ops",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            n: {
                serializedName: "n",
                type: {
                    name: "Base64Url"
                }
            },
            e: {
                serializedName: "e",
                type: {
                    name: "Base64Url"
                }
            },
            d: {
                serializedName: "d",
                type: {
                    name: "Base64Url"
                }
            },
            dp: {
                serializedName: "dp",
                type: {
                    name: "Base64Url"
                }
            },
            dq: {
                serializedName: "dq",
                type: {
                    name: "Base64Url"
                }
            },
            qi: {
                serializedName: "qi",
                type: {
                    name: "Base64Url"
                }
            },
            p: {
                serializedName: "p",
                type: {
                    name: "Base64Url"
                }
            },
            q: {
                serializedName: "q",
                type: {
                    name: "Base64Url"
                }
            },
            k: {
                serializedName: "k",
                type: {
                    name: "Base64Url"
                }
            },
            t: {
                serializedName: "key_hsm",
                type: {
                    name: "Base64Url"
                }
            },
            crv: {
                serializedName: "crv",
                type: {
                    name: "String"
                }
            },
            x: {
                serializedName: "x",
                type: {
                    name: "Base64Url"
                }
            },
            y: {
                serializedName: "y",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var KeyAttributes = {
    serializedName: "KeyAttributes",
    type: {
        name: "Composite",
        className: "KeyAttributes",
        modelProperties: tslib.__assign(tslib.__assign({}, Attributes.type.modelProperties), { recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            } })
    }
};
var KeyBundle = {
    serializedName: "KeyBundle",
    type: {
        name: "Composite",
        className: "KeyBundle",
        modelProperties: {
            key: {
                serializedName: "key",
                type: {
                    name: "Composite",
                    className: "JsonWebKey"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            managed: {
                readOnly: true,
                serializedName: "managed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var KeyItem = {
    serializedName: "KeyItem",
    type: {
        name: "Composite",
        className: "KeyItem",
        modelProperties: {
            kid: {
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            managed: {
                readOnly: true,
                serializedName: "managed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var DeletedKeyBundle = {
    serializedName: "DeletedKeyBundle",
    type: {
        name: "Composite",
        className: "DeletedKeyBundle",
        modelProperties: tslib.__assign(tslib.__assign({}, KeyBundle.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var DeletedKeyItem = {
    serializedName: "DeletedKeyItem",
    type: {
        name: "Composite",
        className: "DeletedKeyItem",
        modelProperties: tslib.__assign(tslib.__assign({}, KeyItem.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var SecretAttributes = {
    serializedName: "SecretAttributes",
    type: {
        name: "Composite",
        className: "SecretAttributes",
        modelProperties: tslib.__assign(tslib.__assign({}, Attributes.type.modelProperties), { recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            } })
    }
};
var SecretBundle = {
    serializedName: "SecretBundle",
    type: {
        name: "Composite",
        className: "SecretBundle",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            kid: {
                readOnly: true,
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            managed: {
                readOnly: true,
                serializedName: "managed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var SecretItem = {
    serializedName: "SecretItem",
    type: {
        name: "Composite",
        className: "SecretItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            managed: {
                readOnly: true,
                serializedName: "managed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var DeletedSecretBundle = {
    serializedName: "DeletedSecretBundle",
    type: {
        name: "Composite",
        className: "DeletedSecretBundle",
        modelProperties: tslib.__assign(tslib.__assign({}, SecretBundle.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var DeletedSecretItem = {
    serializedName: "DeletedSecretItem",
    type: {
        name: "Composite",
        className: "DeletedSecretItem",
        modelProperties: tslib.__assign(tslib.__assign({}, SecretItem.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var SecretRestoreParameters = {
    serializedName: "SecretRestoreParameters",
    type: {
        name: "Composite",
        className: "SecretRestoreParameters",
        modelProperties: {
            secretBundleBackup: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var StorageRestoreParameters = {
    serializedName: "StorageRestoreParameters",
    type: {
        name: "Composite",
        className: "StorageRestoreParameters",
        modelProperties: {
            storageBundleBackup: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var CertificateAttributes = {
    serializedName: "CertificateAttributes",
    type: {
        name: "Composite",
        className: "CertificateAttributes",
        modelProperties: tslib.__assign(tslib.__assign({}, Attributes.type.modelProperties), { recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            } })
    }
};
var CertificateItem = {
    serializedName: "CertificateItem",
    type: {
        name: "Composite",
        className: "CertificateItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            x509Thumbprint: {
                serializedName: "x5t",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var CertificateIssuerItem = {
    serializedName: "CertificateIssuerItem",
    type: {
        name: "Composite",
        className: "CertificateIssuerItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var KeyProperties = {
    serializedName: "KeyProperties",
    type: {
        name: "Composite",
        className: "KeyProperties",
        modelProperties: {
            exportable: {
                serializedName: "exportable",
                type: {
                    name: "Boolean"
                }
            },
            keyType: {
                serializedName: "kty",
                type: {
                    name: "String"
                }
            },
            keySize: {
                serializedName: "key_size",
                type: {
                    name: "Number"
                }
            },
            reuseKey: {
                serializedName: "reuse_key",
                type: {
                    name: "Boolean"
                }
            },
            curve: {
                serializedName: "crv",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SecretProperties = {
    serializedName: "SecretProperties",
    type: {
        name: "Composite",
        className: "SecretProperties",
        modelProperties: {
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SubjectAlternativeNames = {
    serializedName: "SubjectAlternativeNames",
    type: {
        name: "Composite",
        className: "SubjectAlternativeNames",
        modelProperties: {
            emails: {
                serializedName: "emails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            dnsNames: {
                serializedName: "dns_names",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            upns: {
                serializedName: "upns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var X509CertificateProperties = {
    serializedName: "X509CertificateProperties",
    type: {
        name: "Composite",
        className: "X509CertificateProperties",
        modelProperties: {
            subject: {
                serializedName: "subject",
                type: {
                    name: "String"
                }
            },
            ekus: {
                serializedName: "ekus",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            subjectAlternativeNames: {
                serializedName: "sans",
                type: {
                    name: "Composite",
                    className: "SubjectAlternativeNames"
                }
            },
            keyUsage: {
                serializedName: "key_usage",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            validityInMonths: {
                serializedName: "validity_months",
                constraints: {
                    InclusiveMinimum: 0
                },
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var Trigger = {
    serializedName: "Trigger",
    type: {
        name: "Composite",
        className: "Trigger",
        modelProperties: {
            lifetimePercentage: {
                serializedName: "lifetime_percentage",
                constraints: {
                    InclusiveMaximum: 99,
                    InclusiveMinimum: 1
                },
                type: {
                    name: "Number"
                }
            },
            daysBeforeExpiry: {
                serializedName: "days_before_expiry",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var Action = {
    serializedName: "Action",
    type: {
        name: "Composite",
        className: "Action",
        modelProperties: {
            actionType: {
                serializedName: "action_type",
                type: {
                    name: "Enum",
                    allowedValues: ["EmailContacts", "AutoRenew"]
                }
            }
        }
    }
};
var LifetimeAction = {
    serializedName: "LifetimeAction",
    type: {
        name: "Composite",
        className: "LifetimeAction",
        modelProperties: {
            trigger: {
                serializedName: "trigger",
                type: {
                    name: "Composite",
                    className: "Trigger"
                }
            },
            action: {
                serializedName: "action",
                type: {
                    name: "Composite",
                    className: "Action"
                }
            }
        }
    }
};
var IssuerParameters = {
    serializedName: "IssuerParameters",
    type: {
        name: "Composite",
        className: "IssuerParameters",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            certificateType: {
                serializedName: "cty",
                type: {
                    name: "String"
                }
            },
            certificateTransparency: {
                serializedName: "cert_transparency",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var CertificatePolicy = {
    serializedName: "CertificatePolicy",
    type: {
        name: "Composite",
        className: "CertificatePolicy",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            keyProperties: {
                serializedName: "key_props",
                type: {
                    name: "Composite",
                    className: "KeyProperties"
                }
            },
            secretProperties: {
                serializedName: "secret_props",
                type: {
                    name: "Composite",
                    className: "SecretProperties"
                }
            },
            x509CertificateProperties: {
                serializedName: "x509_props",
                type: {
                    name: "Composite",
                    className: "X509CertificateProperties"
                }
            },
            lifetimeActions: {
                serializedName: "lifetime_actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LifetimeAction"
                        }
                    }
                }
            },
            issuerParameters: {
                serializedName: "issuer",
                type: {
                    name: "Composite",
                    className: "IssuerParameters"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            }
        }
    }
};
var CertificateBundle = {
    serializedName: "CertificateBundle",
    type: {
        name: "Composite",
        className: "CertificateBundle",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            kid: {
                readOnly: true,
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            sid: {
                readOnly: true,
                serializedName: "sid",
                type: {
                    name: "String"
                }
            },
            x509Thumbprint: {
                readOnly: true,
                serializedName: "x5t",
                type: {
                    name: "Base64Url"
                }
            },
            policy: {
                readOnly: true,
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "CertificatePolicy"
                }
            },
            cer: {
                serializedName: "cer",
                type: {
                    name: "ByteArray"
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var DeletedCertificateBundle = {
    serializedName: "DeletedCertificateBundle",
    type: {
        name: "Composite",
        className: "DeletedCertificateBundle",
        modelProperties: tslib.__assign(tslib.__assign({}, CertificateBundle.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var DeletedCertificateItem = {
    serializedName: "DeletedCertificateItem",
    type: {
        name: "Composite",
        className: "DeletedCertificateItem",
        modelProperties: tslib.__assign(tslib.__assign({}, CertificateItem.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var ErrorModel = {
    serializedName: "Error",
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            code: {
                readOnly: true,
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                readOnly: true,
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            innerError: {
                readOnly: true,
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
var CertificateOperation = {
    serializedName: "CertificateOperation",
    type: {
        name: "Composite",
        className: "CertificateOperation",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            issuerParameters: {
                serializedName: "issuer",
                type: {
                    name: "Composite",
                    className: "IssuerParameters"
                }
            },
            csr: {
                serializedName: "csr",
                type: {
                    name: "ByteArray"
                }
            },
            cancellationRequested: {
                serializedName: "cancellation_requested",
                type: {
                    name: "Boolean"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            statusDetails: {
                serializedName: "status_details",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "request_id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var IssuerCredentials = {
    serializedName: "IssuerCredentials",
    type: {
        name: "Composite",
        className: "IssuerCredentials",
        modelProperties: {
            accountId: {
                serializedName: "account_id",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "pwd",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var AdministratorDetails = {
    serializedName: "AdministratorDetails",
    type: {
        name: "Composite",
        className: "AdministratorDetails",
        modelProperties: {
            firstName: {
                serializedName: "first_name",
                type: {
                    name: "String"
                }
            },
            lastName: {
                serializedName: "last_name",
                type: {
                    name: "String"
                }
            },
            emailAddress: {
                serializedName: "email",
                type: {
                    name: "String"
                }
            },
            phone: {
                serializedName: "phone",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var OrganizationDetails = {
    serializedName: "OrganizationDetails",
    type: {
        name: "Composite",
        className: "OrganizationDetails",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            adminDetails: {
                serializedName: "admin_details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AdministratorDetails"
                        }
                    }
                }
            }
        }
    }
};
var IssuerAttributes = {
    serializedName: "IssuerAttributes",
    type: {
        name: "Composite",
        className: "IssuerAttributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            created: {
                readOnly: true,
                serializedName: "created",
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                readOnly: true,
                serializedName: "updated",
                type: {
                    name: "UnixTime"
                }
            }
        }
    }
};
var IssuerBundle = {
    serializedName: "IssuerBundle",
    type: {
        name: "Composite",
        className: "IssuerBundle",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "IssuerCredentials"
                }
            },
            organizationDetails: {
                serializedName: "org_details",
                type: {
                    name: "Composite",
                    className: "OrganizationDetails"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "IssuerAttributes"
                }
            }
        }
    }
};
var Contact = {
    serializedName: "Contact",
    type: {
        name: "Composite",
        className: "Contact",
        modelProperties: {
            emailAddress: {
                serializedName: "email",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            phone: {
                serializedName: "phone",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var Contacts = {
    serializedName: "Contacts",
    type: {
        name: "Composite",
        className: "Contacts",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            contactList: {
                serializedName: "contacts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Contact"
                        }
                    }
                }
            }
        }
    }
};
var KeyCreateParameters = {
    serializedName: "KeyCreateParameters",
    type: {
        name: "Composite",
        className: "KeyCreateParameters",
        modelProperties: {
            kty: {
                required: true,
                serializedName: "kty",
                constraints: {
                    MinLength: 1
                },
                type: {
                    name: "String"
                }
            },
            keySize: {
                serializedName: "key_size",
                type: {
                    name: "Number"
                }
            },
            keyOps: {
                serializedName: "key_ops",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            keyAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            curve: {
                serializedName: "crv",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var KeyImportParameters = {
    serializedName: "KeyImportParameters",
    type: {
        name: "Composite",
        className: "KeyImportParameters",
        modelProperties: {
            hsm: {
                serializedName: "Hsm",
                type: {
                    name: "Boolean"
                }
            },
            key: {
                required: true,
                serializedName: "key",
                type: {
                    name: "Composite",
                    className: "JsonWebKey"
                }
            },
            keyAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var KeyOperationsParameters = {
    serializedName: "KeyOperationsParameters",
    type: {
        name: "Composite",
        className: "KeyOperationsParameters",
        modelProperties: {
            algorithm: {
                required: true,
                serializedName: "alg",
                constraints: {
                    MinLength: 1
                },
                type: {
                    name: "String"
                }
            },
            value: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var KeySignParameters = {
    serializedName: "KeySignParameters",
    type: {
        name: "Composite",
        className: "KeySignParameters",
        modelProperties: {
            algorithm: {
                required: true,
                serializedName: "alg",
                constraints: {
                    MinLength: 1
                },
                type: {
                    name: "String"
                }
            },
            value: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var KeyVerifyParameters = {
    serializedName: "KeyVerifyParameters",
    type: {
        name: "Composite",
        className: "KeyVerifyParameters",
        modelProperties: {
            algorithm: {
                required: true,
                serializedName: "alg",
                constraints: {
                    MinLength: 1
                },
                type: {
                    name: "String"
                }
            },
            digest: {
                required: true,
                serializedName: "digest",
                type: {
                    name: "Base64Url"
                }
            },
            signature: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var KeyUpdateParameters = {
    serializedName: "KeyUpdateParameters",
    type: {
        name: "Composite",
        className: "KeyUpdateParameters",
        modelProperties: {
            keyOps: {
                serializedName: "key_ops",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            keyAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var KeyRestoreParameters = {
    serializedName: "KeyRestoreParameters",
    type: {
        name: "Composite",
        className: "KeyRestoreParameters",
        modelProperties: {
            keyBundleBackup: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var SecretSetParameters = {
    serializedName: "SecretSetParameters",
    type: {
        name: "Composite",
        className: "SecretSetParameters",
        modelProperties: {
            value: {
                required: true,
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            secretAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            }
        }
    }
};
var SecretUpdateParameters = {
    serializedName: "SecretUpdateParameters",
    type: {
        name: "Composite",
        className: "SecretUpdateParameters",
        modelProperties: {
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            secretAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var CertificateCreateParameters = {
    serializedName: "CertificateCreateParameters",
    type: {
        name: "Composite",
        className: "CertificateCreateParameters",
        modelProperties: {
            certificatePolicy: {
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "CertificatePolicy"
                }
            },
            certificateAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var CertificateImportParameters = {
    serializedName: "CertificateImportParameters",
    type: {
        name: "Composite",
        className: "CertificateImportParameters",
        modelProperties: {
            base64EncodedCertificate: {
                required: true,
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "pwd",
                type: {
                    name: "String"
                }
            },
            certificatePolicy: {
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "CertificatePolicy"
                }
            },
            certificateAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var CertificateUpdateParameters = {
    serializedName: "CertificateUpdateParameters",
    type: {
        name: "Composite",
        className: "CertificateUpdateParameters",
        modelProperties: {
            certificatePolicy: {
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "CertificatePolicy"
                }
            },
            certificateAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var CertificateMergeParameters = {
    serializedName: "CertificateMergeParameters",
    type: {
        name: "Composite",
        className: "CertificateMergeParameters",
        modelProperties: {
            x509Certificates: {
                required: true,
                serializedName: "x5c",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "ByteArray"
                        }
                    }
                }
            },
            certificateAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var CertificateIssuerSetParameters = {
    serializedName: "CertificateIssuerSetParameters",
    type: {
        name: "Composite",
        className: "CertificateIssuerSetParameters",
        modelProperties: {
            provider: {
                required: true,
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "IssuerCredentials"
                }
            },
            organizationDetails: {
                serializedName: "org_details",
                type: {
                    name: "Composite",
                    className: "OrganizationDetails"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "IssuerAttributes"
                }
            }
        }
    }
};
var CertificateIssuerUpdateParameters = {
    serializedName: "CertificateIssuerUpdateParameters",
    type: {
        name: "Composite",
        className: "CertificateIssuerUpdateParameters",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "IssuerCredentials"
                }
            },
            organizationDetails: {
                serializedName: "org_details",
                type: {
                    name: "Composite",
                    className: "OrganizationDetails"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "IssuerAttributes"
                }
            }
        }
    }
};
var CertificateOperationUpdateParameter = {
    serializedName: "CertificateOperationUpdateParameter",
    type: {
        name: "Composite",
        className: "CertificateOperationUpdateParameter",
        modelProperties: {
            cancellationRequested: {
                required: true,
                serializedName: "cancellation_requested",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var KeyOperationResult = {
    serializedName: "KeyOperationResult",
    type: {
        name: "Composite",
        className: "KeyOperationResult",
        modelProperties: {
            kid: {
                readOnly: true,
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            result: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var KeyVerifyResult = {
    serializedName: "KeyVerifyResult",
    type: {
        name: "Composite",
        className: "KeyVerifyResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var KeyListResult = {
    serializedName: "KeyListResult",
    type: {
        name: "Composite",
        className: "KeyListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DeletedKeyListResult = {
    serializedName: "DeletedKeyListResult",
    type: {
        name: "Composite",
        className: "DeletedKeyListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedKeyItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SecretListResult = {
    serializedName: "SecretListResult",
    type: {
        name: "Composite",
        className: "SecretListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecretItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DeletedSecretListResult = {
    serializedName: "DeletedSecretListResult",
    type: {
        name: "Composite",
        className: "DeletedSecretListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedSecretItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var CertificateListResult = {
    serializedName: "CertificateListResult",
    type: {
        name: "Composite",
        className: "CertificateListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CertificateItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DeletedCertificateListResult = {
    serializedName: "DeletedCertificateListResult",
    type: {
        name: "Composite",
        className: "DeletedCertificateListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedCertificateItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var CertificateIssuerListResult = {
    serializedName: "CertificateIssuerListResult",
    type: {
        name: "Composite",
        className: "CertificateIssuerListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CertificateIssuerItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var BackupKeyResult = {
    serializedName: "BackupKeyResult",
    type: {
        name: "Composite",
        className: "BackupKeyResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var BackupSecretResult = {
    serializedName: "BackupSecretResult",
    type: {
        name: "Composite",
        className: "BackupSecretResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var BackupStorageResult = {
    serializedName: "BackupStorageResult",
    type: {
        name: "Composite",
        className: "BackupStorageResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var PendingCertificateSigningRequestResult = {
    serializedName: "PendingCertificateSigningRequestResult",
    type: {
        name: "Composite",
        className: "PendingCertificateSigningRequestResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var StorageAccountAttributes = {
    serializedName: "StorageAccountAttributes",
    type: {
        name: "Composite",
        className: "StorageAccountAttributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            created: {
                readOnly: true,
                serializedName: "created",
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                readOnly: true,
                serializedName: "updated",
                type: {
                    name: "UnixTime"
                }
            },
            recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var StorageBundle = {
    serializedName: "StorageBundle",
    type: {
        name: "Composite",
        className: "StorageBundle",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                readOnly: true,
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            activeKeyName: {
                readOnly: true,
                serializedName: "activeKeyName",
                type: {
                    name: "String"
                }
            },
            autoRegenerateKey: {
                readOnly: true,
                serializedName: "autoRegenerateKey",
                type: {
                    name: "Boolean"
                }
            },
            regenerationPeriod: {
                readOnly: true,
                serializedName: "regenerationPeriod",
                type: {
                    name: "String"
                }
            },
            attributes: {
                readOnly: true,
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "StorageAccountAttributes"
                }
            },
            tags: {
                readOnly: true,
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var DeletedStorageBundle = {
    serializedName: "DeletedStorageBundle",
    type: {
        name: "Composite",
        className: "DeletedStorageBundle",
        modelProperties: tslib.__assign(tslib.__assign({}, StorageBundle.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var StorageAccountCreateParameters = {
    serializedName: "StorageAccountCreateParameters",
    type: {
        name: "Composite",
        className: "StorageAccountCreateParameters",
        modelProperties: {
            resourceId: {
                required: true,
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            activeKeyName: {
                required: true,
                serializedName: "activeKeyName",
                type: {
                    name: "String"
                }
            },
            autoRegenerateKey: {
                required: true,
                serializedName: "autoRegenerateKey",
                type: {
                    name: "Boolean"
                }
            },
            regenerationPeriod: {
                serializedName: "regenerationPeriod",
                type: {
                    name: "String"
                }
            },
            storageAccountAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "StorageAccountAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var StorageAccountUpdateParameters = {
    serializedName: "StorageAccountUpdateParameters",
    type: {
        name: "Composite",
        className: "StorageAccountUpdateParameters",
        modelProperties: {
            activeKeyName: {
                serializedName: "activeKeyName",
                type: {
                    name: "String"
                }
            },
            autoRegenerateKey: {
                serializedName: "autoRegenerateKey",
                type: {
                    name: "Boolean"
                }
            },
            regenerationPeriod: {
                serializedName: "regenerationPeriod",
                type: {
                    name: "String"
                }
            },
            storageAccountAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "StorageAccountAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var StorageAccountRegenerteKeyParameters = {
    serializedName: "StorageAccountRegenerteKeyParameters",
    type: {
        name: "Composite",
        className: "StorageAccountRegenerteKeyParameters",
        modelProperties: {
            keyName: {
                required: true,
                serializedName: "keyName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var StorageAccountItem = {
    serializedName: "StorageAccountItem",
    type: {
        name: "Composite",
        className: "StorageAccountItem",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                readOnly: true,
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            attributes: {
                readOnly: true,
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "StorageAccountAttributes"
                }
            },
            tags: {
                readOnly: true,
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var DeletedStorageAccountItem = {
    serializedName: "DeletedStorageAccountItem",
    type: {
        name: "Composite",
        className: "DeletedStorageAccountItem",
        modelProperties: tslib.__assign(tslib.__assign({}, StorageAccountItem.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var StorageListResult = {
    serializedName: "StorageListResult",
    type: {
        name: "Composite",
        className: "StorageListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageAccountItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DeletedStorageListResult = {
    serializedName: "DeletedStorageListResult",
    type: {
        name: "Composite",
        className: "DeletedStorageListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedStorageAccountItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SasDefinitionAttributes = {
    serializedName: "SasDefinitionAttributes",
    type: {
        name: "Composite",
        className: "SasDefinitionAttributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            created: {
                readOnly: true,
                serializedName: "created",
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                readOnly: true,
                serializedName: "updated",
                type: {
                    name: "UnixTime"
                }
            },
            recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SasDefinitionBundle = {
    serializedName: "SasDefinitionBundle",
    type: {
        name: "Composite",
        className: "SasDefinitionBundle",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            secretId: {
                readOnly: true,
                serializedName: "sid",
                type: {
                    name: "String"
                }
            },
            templateUri: {
                readOnly: true,
                serializedName: "templateUri",
                type: {
                    name: "String"
                }
            },
            sasType: {
                readOnly: true,
                serializedName: "sasType",
                type: {
                    name: "String"
                }
            },
            validityPeriod: {
                readOnly: true,
                serializedName: "validityPeriod",
                type: {
                    name: "String"
                }
            },
            attributes: {
                readOnly: true,
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SasDefinitionAttributes"
                }
            },
            tags: {
                readOnly: true,
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var DeletedSasDefinitionBundle = {
    serializedName: "DeletedSasDefinitionBundle",
    type: {
        name: "Composite",
        className: "DeletedSasDefinitionBundle",
        modelProperties: tslib.__assign(tslib.__assign({}, SasDefinitionBundle.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var SasDefinitionItem = {
    serializedName: "SasDefinitionItem",
    type: {
        name: "Composite",
        className: "SasDefinitionItem",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            secretId: {
                readOnly: true,
                serializedName: "sid",
                type: {
                    name: "String"
                }
            },
            attributes: {
                readOnly: true,
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SasDefinitionAttributes"
                }
            },
            tags: {
                readOnly: true,
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var DeletedSasDefinitionItem = {
    serializedName: "DeletedSasDefinitionItem",
    type: {
        name: "Composite",
        className: "DeletedSasDefinitionItem",
        modelProperties: tslib.__assign(tslib.__assign({}, SasDefinitionItem.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var SasDefinitionListResult = {
    serializedName: "SasDefinitionListResult",
    type: {
        name: "Composite",
        className: "SasDefinitionListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SasDefinitionItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DeletedSasDefinitionListResult = {
    serializedName: "DeletedSasDefinitionListResult",
    type: {
        name: "Composite",
        className: "DeletedSasDefinitionListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedSasDefinitionItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SasDefinitionCreateParameters = {
    serializedName: "SasDefinitionCreateParameters",
    type: {
        name: "Composite",
        className: "SasDefinitionCreateParameters",
        modelProperties: {
            templateUri: {
                required: true,
                serializedName: "templateUri",
                type: {
                    name: "String"
                }
            },
            sasType: {
                required: true,
                serializedName: "sasType",
                type: {
                    name: "String"
                }
            },
            validityPeriod: {
                required: true,
                serializedName: "validityPeriod",
                type: {
                    name: "String"
                }
            },
            sasDefinitionAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SasDefinitionAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var SasDefinitionUpdateParameters = {
    serializedName: "SasDefinitionUpdateParameters",
    type: {
        name: "Composite",
        className: "SasDefinitionUpdateParameters",
        modelProperties: {
            templateUri: {
                serializedName: "templateUri",
                type: {
                    name: "String"
                }
            },
            sasType: {
                serializedName: "sasType",
                type: {
                    name: "String"
                }
            },
            validityPeriod: {
                serializedName: "validityPeriod",
                type: {
                    name: "String"
                }
            },
            sasDefinitionAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SasDefinitionAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var KeyVaultError = {
    serializedName: "KeyVaultError",
    type: {
        name: "Composite",
        className: "KeyVaultError",
        modelProperties: {
            error: {
                readOnly: true,
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
var CertificateRestoreParameters = {
    serializedName: "CertificateRestoreParameters",
    type: {
        name: "Composite",
        className: "CertificateRestoreParameters",
        modelProperties: {
            certificateBundleBackup: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var BackupCertificateResult = {
    serializedName: "BackupCertificateResult",
    type: {
        name: "Composite",
        className: "BackupCertificateResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Attributes: Attributes,
    JsonWebKey: JsonWebKey,
    KeyAttributes: KeyAttributes,
    KeyBundle: KeyBundle,
    KeyItem: KeyItem,
    DeletedKeyBundle: DeletedKeyBundle,
    DeletedKeyItem: DeletedKeyItem,
    SecretAttributes: SecretAttributes,
    SecretBundle: SecretBundle,
    SecretItem: SecretItem,
    DeletedSecretBundle: DeletedSecretBundle,
    DeletedSecretItem: DeletedSecretItem,
    SecretRestoreParameters: SecretRestoreParameters,
    StorageRestoreParameters: StorageRestoreParameters,
    CertificateAttributes: CertificateAttributes,
    CertificateItem: CertificateItem,
    CertificateIssuerItem: CertificateIssuerItem,
    KeyProperties: KeyProperties,
    SecretProperties: SecretProperties,
    SubjectAlternativeNames: SubjectAlternativeNames,
    X509CertificateProperties: X509CertificateProperties,
    Trigger: Trigger,
    Action: Action,
    LifetimeAction: LifetimeAction,
    IssuerParameters: IssuerParameters,
    CertificatePolicy: CertificatePolicy,
    CertificateBundle: CertificateBundle,
    DeletedCertificateBundle: DeletedCertificateBundle,
    DeletedCertificateItem: DeletedCertificateItem,
    ErrorModel: ErrorModel,
    CertificateOperation: CertificateOperation,
    IssuerCredentials: IssuerCredentials,
    AdministratorDetails: AdministratorDetails,
    OrganizationDetails: OrganizationDetails,
    IssuerAttributes: IssuerAttributes,
    IssuerBundle: IssuerBundle,
    Contact: Contact,
    Contacts: Contacts,
    KeyCreateParameters: KeyCreateParameters,
    KeyImportParameters: KeyImportParameters,
    KeyOperationsParameters: KeyOperationsParameters,
    KeySignParameters: KeySignParameters,
    KeyVerifyParameters: KeyVerifyParameters,
    KeyUpdateParameters: KeyUpdateParameters,
    KeyRestoreParameters: KeyRestoreParameters,
    SecretSetParameters: SecretSetParameters,
    SecretUpdateParameters: SecretUpdateParameters,
    CertificateCreateParameters: CertificateCreateParameters,
    CertificateImportParameters: CertificateImportParameters,
    CertificateUpdateParameters: CertificateUpdateParameters,
    CertificateMergeParameters: CertificateMergeParameters,
    CertificateIssuerSetParameters: CertificateIssuerSetParameters,
    CertificateIssuerUpdateParameters: CertificateIssuerUpdateParameters,
    CertificateOperationUpdateParameter: CertificateOperationUpdateParameter,
    KeyOperationResult: KeyOperationResult,
    KeyVerifyResult: KeyVerifyResult,
    KeyListResult: KeyListResult,
    DeletedKeyListResult: DeletedKeyListResult,
    SecretListResult: SecretListResult,
    DeletedSecretListResult: DeletedSecretListResult,
    CertificateListResult: CertificateListResult,
    DeletedCertificateListResult: DeletedCertificateListResult,
    CertificateIssuerListResult: CertificateIssuerListResult,
    BackupKeyResult: BackupKeyResult,
    BackupSecretResult: BackupSecretResult,
    BackupStorageResult: BackupStorageResult,
    PendingCertificateSigningRequestResult: PendingCertificateSigningRequestResult,
    StorageAccountAttributes: StorageAccountAttributes,
    StorageBundle: StorageBundle,
    DeletedStorageBundle: DeletedStorageBundle,
    StorageAccountCreateParameters: StorageAccountCreateParameters,
    StorageAccountUpdateParameters: StorageAccountUpdateParameters,
    StorageAccountRegenerteKeyParameters: StorageAccountRegenerteKeyParameters,
    StorageAccountItem: StorageAccountItem,
    DeletedStorageAccountItem: DeletedStorageAccountItem,
    StorageListResult: StorageListResult,
    DeletedStorageListResult: DeletedStorageListResult,
    SasDefinitionAttributes: SasDefinitionAttributes,
    SasDefinitionBundle: SasDefinitionBundle,
    DeletedSasDefinitionBundle: DeletedSasDefinitionBundle,
    SasDefinitionItem: SasDefinitionItem,
    DeletedSasDefinitionItem: DeletedSasDefinitionItem,
    SasDefinitionListResult: SasDefinitionListResult,
    DeletedSasDefinitionListResult: DeletedSasDefinitionListResult,
    SasDefinitionCreateParameters: SasDefinitionCreateParameters,
    SasDefinitionUpdateParameters: SasDefinitionUpdateParameters,
    KeyVaultError: KeyVaultError,
    CertificateRestoreParameters: CertificateRestoreParameters,
    BackupCertificateResult: BackupCertificateResult
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        required: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
var certificateName0 = {
    parameterPath: "certificateName",
    mapper: {
        required: true,
        serializedName: "certificate-name",
        type: {
            name: "String"
        }
    }
};
var certificateName1 = {
    parameterPath: "certificateName",
    mapper: {
        required: true,
        serializedName: "certificate-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z-]+$/
        },
        type: {
            name: "String"
        }
    }
};
var certificateVersion = {
    parameterPath: "certificateVersion",
    mapper: {
        required: true,
        serializedName: "certificate-version",
        type: {
            name: "String"
        }
    }
};
var includePending = {
    parameterPath: ["options", "includePending"],
    mapper: {
        serializedName: "includePending",
        type: {
            name: "Boolean"
        }
    }
};
var issuerName = {
    parameterPath: "issuerName",
    mapper: {
        required: true,
        serializedName: "issuer-name",
        type: {
            name: "String"
        }
    }
};
var keyName0 = {
    parameterPath: "keyName",
    mapper: {
        required: true,
        serializedName: "key-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z-]+$/
        },
        type: {
            name: "String"
        }
    }
};
var keyName1 = {
    parameterPath: "keyName",
    mapper: {
        required: true,
        serializedName: "key-name",
        type: {
            name: "String"
        }
    }
};
var keyVersion = {
    parameterPath: "keyVersion",
    mapper: {
        required: true,
        serializedName: "key-version",
        type: {
            name: "String"
        }
    }
};
var maxresults = {
    parameterPath: ["options", "maxresults"],
    mapper: {
        serializedName: "maxresults",
        constraints: {
            InclusiveMaximum: 25,
            InclusiveMinimum: 1
        },
        type: {
            name: "Number"
        }
    }
};
var sasDefinitionName = {
    parameterPath: "sasDefinitionName",
    mapper: {
        required: true,
        serializedName: "sas-definition-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z]+$/
        },
        type: {
            name: "String"
        }
    }
};
var secretName0 = {
    parameterPath: "secretName",
    mapper: {
        required: true,
        serializedName: "secret-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z-]+$/
        },
        type: {
            name: "String"
        }
    }
};
var secretName1 = {
    parameterPath: "secretName",
    mapper: {
        required: true,
        serializedName: "secret-name",
        type: {
            name: "String"
        }
    }
};
var secretVersion = {
    parameterPath: "secretVersion",
    mapper: {
        required: true,
        serializedName: "secret-version",
        type: {
            name: "String"
        }
    }
};
var storageAccountName0 = {
    parameterPath: "storageAccountName",
    mapper: {
        required: true,
        serializedName: "storage-account-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z]+$/
        },
        type: {
            name: "String"
        }
    }
};
var storageAccountName1 = {
    parameterPath: "storageAccountName",
    mapper: {
        required: true,
        serializedName: "storage-account-name",
        type: {
            name: "String"
        }
    }
};
var vaultBaseUrl = {
    parameterPath: "vaultBaseUrl",
    mapper: {
        required: true,
        serializedName: "vaultBaseUrl",
        defaultValue: "",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var packageName = "@azure/keyvault-keys";
var packageVersion = "4.0.0";
var KeyVaultClientContext = /** @class */ (function (_super) {
    tslib.__extends(KeyVaultClientContext, _super);
    /**
     * Initializes a new instance of the KeyVaultClientContext class.
     * @param apiVersion Client API version.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param [options] The parameter options
     */
    function KeyVaultClientContext(credentials, apiVersion, options) {
        var _this = this;
        if (apiVersion == undefined) {
            throw new Error("'apiVersion' cannot be null.");
        }
        if (credentials == undefined) {
            throw new Error("'credentials' cannot be null.");
        }
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            var defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = packageName + "/" + packageVersion + " " + defaultUserAgent;
        }
        _this = _super.call(this, credentials, options) || this;
        _this.baseUri = "{vaultBaseUrl}";
        _this.requestContentType = "application/json; charset=utf-8";
        _this.apiVersion = apiVersion;
        _this.credentials = credentials;
        return _this;
    }
    return KeyVaultClientContext;
}(coreHttp.ServiceClient));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var KeyVaultClient = /** @class */ (function (_super) {
    tslib.__extends(KeyVaultClient, _super);
    /**
     * Initializes a new instance of the KeyVaultClient class.
     * @param apiVersion Client API version.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param [options] The parameter options
     */
    function KeyVaultClient(credentials, apiVersion, options) {
        return _super.call(this, credentials, apiVersion, options) || this;
    }
    KeyVaultClient.prototype.createKey = function (vaultBaseUrl, keyName, kty, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            kty: kty,
            options: options
        }, createKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.importKey = function (vaultBaseUrl, keyName, key, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            key: key,
            options: options
        }, importKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteKey = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, deleteKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateKey = function (vaultBaseUrl, keyName, keyVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            options: options
        }, updateKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.getKey = function (vaultBaseUrl, keyName, keyVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            options: options
        }, getKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.getKeyVersions = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, getKeyVersionsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getKeys = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getKeysOperationSpec, callback);
    };
    KeyVaultClient.prototype.backupKey = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, backupKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.restoreKey = function (vaultBaseUrl, keyBundleBackup, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyBundleBackup: keyBundleBackup,
            options: options
        }, restoreKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.encrypt = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            value: value,
            options: options
        }, encryptOperationSpec, callback);
    };
    KeyVaultClient.prototype.decrypt = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            value: value,
            options: options
        }, decryptOperationSpec, callback);
    };
    KeyVaultClient.prototype.sign = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            value: value,
            options: options
        }, signOperationSpec, callback);
    };
    KeyVaultClient.prototype.verify = function (vaultBaseUrl, keyName, keyVersion, algorithm, digest, signature, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            digest: digest,
            signature: signature,
            options: options
        }, verifyOperationSpec, callback);
    };
    KeyVaultClient.prototype.wrapKey = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            value: value,
            options: options
        }, wrapKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.unwrapKey = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            value: value,
            options: options
        }, unwrapKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedKeys = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getDeletedKeysOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedKey = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, getDeletedKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.purgeDeletedKey = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, purgeDeletedKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.recoverDeletedKey = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, recoverDeletedKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.setSecret = function (vaultBaseUrl, secretName, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            value: value,
            options: options
        }, setSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteSecret = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, deleteSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateSecret = function (vaultBaseUrl, secretName, secretVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            secretVersion: secretVersion,
            options: options
        }, updateSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSecret = function (vaultBaseUrl, secretName, secretVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            secretVersion: secretVersion,
            options: options
        }, getSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSecrets = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getSecretsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSecretVersions = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, getSecretVersionsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedSecrets = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getDeletedSecretsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedSecret = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, getDeletedSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.purgeDeletedSecret = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, purgeDeletedSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.recoverDeletedSecret = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, recoverDeletedSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.backupSecret = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, backupSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.restoreSecret = function (vaultBaseUrl, secretBundleBackup, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretBundleBackup: secretBundleBackup,
            options: options
        }, restoreSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificates = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getCertificatesOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, deleteCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.setCertificateContacts = function (vaultBaseUrl, contacts, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            contacts: contacts,
            options: options
        }, setCertificateContactsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateContacts = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getCertificateContactsOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteCertificateContacts = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, deleteCertificateContactsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateIssuers = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getCertificateIssuersOperationSpec, callback);
    };
    KeyVaultClient.prototype.setCertificateIssuer = function (vaultBaseUrl, issuerName, provider, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            issuerName: issuerName,
            provider: provider,
            options: options
        }, setCertificateIssuerOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateCertificateIssuer = function (vaultBaseUrl, issuerName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            issuerName: issuerName,
            options: options
        }, updateCertificateIssuerOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateIssuer = function (vaultBaseUrl, issuerName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            issuerName: issuerName,
            options: options
        }, getCertificateIssuerOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteCertificateIssuer = function (vaultBaseUrl, issuerName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            issuerName: issuerName,
            options: options
        }, deleteCertificateIssuerOperationSpec, callback);
    };
    KeyVaultClient.prototype.createCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, createCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.importCertificate = function (vaultBaseUrl, certificateName, base64EncodedCertificate, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            base64EncodedCertificate: base64EncodedCertificate,
            options: options
        }, importCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateVersions = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, getCertificateVersionsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificatePolicy = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, getCertificatePolicyOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateCertificatePolicy = function (vaultBaseUrl, certificateName, certificatePolicy, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            certificatePolicy: certificatePolicy,
            options: options
        }, updateCertificatePolicyOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateCertificate = function (vaultBaseUrl, certificateName, certificateVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            certificateVersion: certificateVersion,
            options: options
        }, updateCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificate = function (vaultBaseUrl, certificateName, certificateVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            certificateVersion: certificateVersion,
            options: options
        }, getCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateCertificateOperation = function (vaultBaseUrl, certificateName, cancellationRequested, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            cancellationRequested: cancellationRequested,
            options: options
        }, updateCertificateOperationOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateOperation = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, getCertificateOperationOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteCertificateOperation = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, deleteCertificateOperationOperationSpec, callback);
    };
    KeyVaultClient.prototype.mergeCertificate = function (vaultBaseUrl, certificateName, x509Certificates, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            x509Certificates: x509Certificates,
            options: options
        }, mergeCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.backupCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, backupCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.restoreCertificate = function (vaultBaseUrl, certificateBundleBackup, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateBundleBackup: certificateBundleBackup,
            options: options
        }, restoreCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedCertificates = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getDeletedCertificatesOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, getDeletedCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.purgeDeletedCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, purgeDeletedCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.recoverDeletedCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, recoverDeletedCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.getStorageAccounts = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getStorageAccountsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedStorageAccounts = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getDeletedStorageAccountsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, getDeletedStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.purgeDeletedStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, purgeDeletedStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.recoverDeletedStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, recoverDeletedStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.backupStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, backupStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.restoreStorageAccount = function (vaultBaseUrl, storageBundleBackup, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageBundleBackup: storageBundleBackup,
            options: options
        }, restoreStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, deleteStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.getStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, getStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.setStorageAccount = function (vaultBaseUrl, storageAccountName, resourceId, activeKeyName, autoRegenerateKey, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            resourceId: resourceId,
            activeKeyName: activeKeyName,
            autoRegenerateKey: autoRegenerateKey,
            options: options
        }, setStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, updateStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.regenerateStorageAccountKey = function (vaultBaseUrl, storageAccountName, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            keyName: keyName,
            options: options
        }, regenerateStorageAccountKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSasDefinitions = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, getSasDefinitionsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedSasDefinitions = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, getDeletedSasDefinitionsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            options: options
        }, getDeletedSasDefinitionOperationSpec, callback);
    };
    KeyVaultClient.prototype.recoverDeletedSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            options: options
        }, recoverDeletedSasDefinitionOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            options: options
        }, deleteSasDefinitionOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            options: options
        }, getSasDefinitionOperationSpec, callback);
    };
    KeyVaultClient.prototype.setSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, templateUri, sasType, validityPeriod, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            templateUri: templateUri,
            sasType: sasType,
            validityPeriod: validityPeriod,
            options: options
        }, setSasDefinitionOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            options: options
        }, updateSasDefinitionOperationSpec, callback);
    };
    return KeyVaultClient;
}(KeyVaultClientContext));
// Operation Specifications
var serializer = new coreHttp.Serializer(Mappers);
var createKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/create",
    urlParameters: [vaultBaseUrl, keyName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            kty: "kty",
            keySize: ["options", "keySize"],
            keyOps: ["options", "keyOps"],
            keyAttributes: ["options", "keyAttributes"],
            tags: ["options", "tags"],
            curve: ["options", "curve"]
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyCreateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var importKeyOperationSpec = {
    httpMethod: "PUT",
    path: "keys/{key-name}",
    urlParameters: [vaultBaseUrl, keyName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            hsm: ["options", "hsm"],
            key: "key",
            keyAttributes: ["options", "keyAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyImportParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteKeyOperationSpec = {
    httpMethod: "DELETE",
    path: "keys/{key-name}",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedKeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateKeyOperationSpec = {
    httpMethod: "PATCH",
    path: "keys/{key-name}/{key-version}",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            keyOps: ["options", "keyOps"],
            keyAttributes: ["options", "keyAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyUpdateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getKeyOperationSpec = {
    httpMethod: "GET",
    path: "keys/{key-name}/{key-version}",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getKeyVersionsOperationSpec = {
    httpMethod: "GET",
    path: "keys/{key-name}/versions",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getKeysOperationSpec = {
    httpMethod: "GET",
    path: "keys",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var backupKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/backup",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: BackupKeyResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var restoreKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/restore",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            keyBundleBackup: "keyBundleBackup"
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyRestoreParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var encryptOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/encrypt",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyOperationsParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var decryptOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/decrypt",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyOperationsParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var signOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/sign",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: tslib.__assign(tslib.__assign({}, KeySignParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var verifyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/verify",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            digest: "digest",
            signature: "signature"
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyVerifyParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyVerifyResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var wrapKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/wrapkey",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyOperationsParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var unwrapKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/unwrapkey",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyOperationsParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedKeysOperationSpec = {
    httpMethod: "GET",
    path: "deletedkeys",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedKeyListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedKeyOperationSpec = {
    httpMethod: "GET",
    path: "deletedkeys/{key-name}",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedKeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var purgeDeletedKeyOperationSpec = {
    httpMethod: "DELETE",
    path: "deletedkeys/{key-name}",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [apiVersion],
    responses: {
        204: {},
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var recoverDeletedKeyOperationSpec = {
    httpMethod: "POST",
    path: "deletedkeys/{key-name}/recover",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var setSecretOperationSpec = {
    httpMethod: "PUT",
    path: "secrets/{secret-name}",
    urlParameters: [vaultBaseUrl, secretName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            value: "value",
            tags: ["options", "tags"],
            contentType: ["options", "contentType"],
            secretAttributes: ["options", "secretAttributes"]
        },
        mapper: tslib.__assign(tslib.__assign({}, SecretSetParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteSecretOperationSpec = {
    httpMethod: "DELETE",
    path: "secrets/{secret-name}",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedSecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateSecretOperationSpec = {
    httpMethod: "PATCH",
    path: "secrets/{secret-name}/{secret-version}",
    urlParameters: [vaultBaseUrl, secretName1, secretVersion],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            contentType: ["options", "contentType"],
            secretAttributes: ["options", "secretAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, SecretUpdateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSecretOperationSpec = {
    httpMethod: "GET",
    path: "secrets/{secret-name}/{secret-version}",
    urlParameters: [vaultBaseUrl, secretName1, secretVersion],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSecretsOperationSpec = {
    httpMethod: "GET",
    path: "secrets",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: SecretListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSecretVersionsOperationSpec = {
    httpMethod: "GET",
    path: "secrets/{secret-name}/versions",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: SecretListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedSecretsOperationSpec = {
    httpMethod: "GET",
    path: "deletedsecrets",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedSecretListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedSecretOperationSpec = {
    httpMethod: "GET",
    path: "deletedsecrets/{secret-name}",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedSecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var purgeDeletedSecretOperationSpec = {
    httpMethod: "DELETE",
    path: "deletedsecrets/{secret-name}",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [apiVersion],
    responses: {
        204: {},
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var recoverDeletedSecretOperationSpec = {
    httpMethod: "POST",
    path: "deletedsecrets/{secret-name}/recover",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var backupSecretOperationSpec = {
    httpMethod: "POST",
    path: "secrets/{secret-name}/backup",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: BackupSecretResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var restoreSecretOperationSpec = {
    httpMethod: "POST",
    path: "secrets/restore",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            secretBundleBackup: "secretBundleBackup"
        },
        mapper: tslib.__assign(tslib.__assign({}, SecretRestoreParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificatesOperationSpec = {
    httpMethod: "GET",
    path: "certificates",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, includePending, apiVersion],
    responses: {
        200: {
            bodyMapper: CertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteCertificateOperationSpec = {
    httpMethod: "DELETE",
    path: "certificates/{certificate-name}",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedCertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var setCertificateContactsOperationSpec = {
    httpMethod: "PUT",
    path: "certificates/contacts",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: "contacts",
        mapper: tslib.__assign(tslib.__assign({}, Contacts), { required: true })
    },
    responses: {
        200: {
            bodyMapper: Contacts
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateContactsOperationSpec = {
    httpMethod: "GET",
    path: "certificates/contacts",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: Contacts
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteCertificateContactsOperationSpec = {
    httpMethod: "DELETE",
    path: "certificates/contacts",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: Contacts
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateIssuersOperationSpec = {
    httpMethod: "GET",
    path: "certificates/issuers",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: CertificateIssuerListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var setCertificateIssuerOperationSpec = {
    httpMethod: "PUT",
    path: "certificates/issuers/{issuer-name}",
    urlParameters: [vaultBaseUrl, issuerName],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            provider: "provider",
            credentials: ["options", "credentials"],
            organizationDetails: ["options", "organizationDetails"],
            attributes: ["options", "attributes"]
        },
        mapper: tslib.__assign(tslib.__assign({}, CertificateIssuerSetParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: IssuerBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateCertificateIssuerOperationSpec = {
    httpMethod: "PATCH",
    path: "certificates/issuers/{issuer-name}",
    urlParameters: [vaultBaseUrl, issuerName],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            provider: ["options", "provider"],
            credentials: ["options", "credentials"],
            organizationDetails: ["options", "organizationDetails"],
            attributes: ["options", "attributes"]
        },
        mapper: tslib.__assign(tslib.__assign({}, CertificateIssuerUpdateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: IssuerBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateIssuerOperationSpec = {
    httpMethod: "GET",
    path: "certificates/issuers/{issuer-name}",
    urlParameters: [vaultBaseUrl, issuerName],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: IssuerBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteCertificateIssuerOperationSpec = {
    httpMethod: "DELETE",
    path: "certificates/issuers/{issuer-name}",
    urlParameters: [vaultBaseUrl, issuerName],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: IssuerBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var createCertificateOperationSpec = {
    httpMethod: "POST",
    path: "certificates/{certificate-name}/create",
    urlParameters: [vaultBaseUrl, certificateName1],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            certificatePolicy: ["options", "certificatePolicy"],
            certificateAttributes: ["options", "certificateAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, CertificateCreateParameters), { required: true })
    },
    responses: {
        202: {
            bodyMapper: CertificateOperation
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var importCertificateOperationSpec = {
    httpMethod: "POST",
    path: "certificates/{certificate-name}/import",
    urlParameters: [vaultBaseUrl, certificateName1],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            base64EncodedCertificate: "base64EncodedCertificate",
            password: ["options", "password"],
            certificatePolicy: ["options", "certificatePolicy"],
            certificateAttributes: ["options", "certificateAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, CertificateImportParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateVersionsOperationSpec = {
    httpMethod: "GET",
    path: "certificates/{certificate-name}/versions",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: CertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificatePolicyOperationSpec = {
    httpMethod: "GET",
    path: "certificates/{certificate-name}/policy",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: CertificatePolicy
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateCertificatePolicyOperationSpec = {
    httpMethod: "PATCH",
    path: "certificates/{certificate-name}/policy",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: "certificatePolicy",
        mapper: tslib.__assign(tslib.__assign({}, CertificatePolicy), { required: true })
    },
    responses: {
        200: {
            bodyMapper: CertificatePolicy
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateCertificateOperationSpec = {
    httpMethod: "PATCH",
    path: "certificates/{certificate-name}/{certificate-version}",
    urlParameters: [
        vaultBaseUrl,
        certificateName0,
        certificateVersion
    ],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            certificatePolicy: ["options", "certificatePolicy"],
            certificateAttributes: ["options", "certificateAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, CertificateUpdateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateOperationSpec = {
    httpMethod: "GET",
    path: "certificates/{certificate-name}/{certificate-version}",
    urlParameters: [
        vaultBaseUrl,
        certificateName0,
        certificateVersion
    ],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateCertificateOperationOperationSpec = {
    httpMethod: "PATCH",
    path: "certificates/{certificate-name}/pending",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            cancellationRequested: "cancellationRequested"
        },
        mapper: tslib.__assign(tslib.__assign({}, CertificateOperationUpdateParameter), { required: true })
    },
    responses: {
        200: {
            bodyMapper: CertificateOperation
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateOperationOperationSpec = {
    httpMethod: "GET",
    path: "certificates/{certificate-name}/pending",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: CertificateOperation
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteCertificateOperationOperationSpec = {
    httpMethod: "DELETE",
    path: "certificates/{certificate-name}/pending",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: CertificateOperation
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var mergeCertificateOperationSpec = {
    httpMethod: "POST",
    path: "certificates/{certificate-name}/pending/merge",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            x509Certificates: "x509Certificates",
            certificateAttributes: ["options", "certificateAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, CertificateMergeParameters), { required: true })
    },
    responses: {
        201: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var backupCertificateOperationSpec = {
    httpMethod: "POST",
    path: "certificates/{certificate-name}/backup",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: BackupCertificateResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var restoreCertificateOperationSpec = {
    httpMethod: "POST",
    path: "certificates/restore",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            certificateBundleBackup: "certificateBundleBackup"
        },
        mapper: tslib.__assign(tslib.__assign({}, CertificateRestoreParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedCertificatesOperationSpec = {
    httpMethod: "GET",
    path: "deletedcertificates",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, includePending, apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedCertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedCertificateOperationSpec = {
    httpMethod: "GET",
    path: "deletedcertificates/{certificate-name}",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedCertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var purgeDeletedCertificateOperationSpec = {
    httpMethod: "DELETE",
    path: "deletedcertificates/{certificate-name}",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    responses: {
        204: {},
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var recoverDeletedCertificateOperationSpec = {
    httpMethod: "POST",
    path: "deletedcertificates/{certificate-name}/recover",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getStorageAccountsOperationSpec = {
    httpMethod: "GET",
    path: "storage",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: StorageListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedStorageAccountsOperationSpec = {
    httpMethod: "GET",
    path: "deletedstorage",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedStorageListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedStorageAccountOperationSpec = {
    httpMethod: "GET",
    path: "deletedstorage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedStorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var purgeDeletedStorageAccountOperationSpec = {
    httpMethod: "DELETE",
    path: "deletedstorage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    responses: {
        204: {},
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var recoverDeletedStorageAccountOperationSpec = {
    httpMethod: "POST",
    path: "deletedstorage/{storage-account-name}/recover",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var backupStorageAccountOperationSpec = {
    httpMethod: "POST",
    path: "storage/{storage-account-name}/backup",
    urlParameters: [vaultBaseUrl, storageAccountName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: BackupStorageResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var restoreStorageAccountOperationSpec = {
    httpMethod: "POST",
    path: "storage/restore",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            storageBundleBackup: "storageBundleBackup"
        },
        mapper: tslib.__assign(tslib.__assign({}, StorageRestoreParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteStorageAccountOperationSpec = {
    httpMethod: "DELETE",
    path: "storage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedStorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getStorageAccountOperationSpec = {
    httpMethod: "GET",
    path: "storage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var setStorageAccountOperationSpec = {
    httpMethod: "PUT",
    path: "storage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            resourceId: "resourceId",
            activeKeyName: "activeKeyName",
            autoRegenerateKey: "autoRegenerateKey",
            regenerationPeriod: ["options", "regenerationPeriod"],
            storageAccountAttributes: ["options", "storageAccountAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, StorageAccountCreateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateStorageAccountOperationSpec = {
    httpMethod: "PATCH",
    path: "storage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            activeKeyName: ["options", "activeKeyName"],
            autoRegenerateKey: ["options", "autoRegenerateKey"],
            regenerationPeriod: ["options", "regenerationPeriod"],
            storageAccountAttributes: ["options", "storageAccountAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, StorageAccountUpdateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var regenerateStorageAccountKeyOperationSpec = {
    httpMethod: "POST",
    path: "storage/{storage-account-name}/regeneratekey",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            keyName: "keyName"
        },
        mapper: tslib.__assign(tslib.__assign({}, StorageAccountRegenerteKeyParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSasDefinitionsOperationSpec = {
    httpMethod: "GET",
    path: "storage/{storage-account-name}/sas",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: SasDefinitionListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedSasDefinitionsOperationSpec = {
    httpMethod: "GET",
    path: "deletedstorage/{storage-account-name}/sas",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedSasDefinitionListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedSasDefinitionOperationSpec = {
    httpMethod: "GET",
    path: "deletedstorage/{storage-account-name}/sas/{sas-definition-name}",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedSasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var recoverDeletedSasDefinitionOperationSpec = {
    httpMethod: "POST",
    path: "deletedstorage/{storage-account-name}/sas/{sas-definition-name}/recover",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: SasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteSasDefinitionOperationSpec = {
    httpMethod: "DELETE",
    path: "storage/{storage-account-name}/sas/{sas-definition-name}",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedSasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSasDefinitionOperationSpec = {
    httpMethod: "GET",
    path: "storage/{storage-account-name}/sas/{sas-definition-name}",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: SasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var setSasDefinitionOperationSpec = {
    httpMethod: "PUT",
    path: "storage/{storage-account-name}/sas/{sas-definition-name}",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            templateUri: "templateUri",
            sasType: "sasType",
            validityPeriod: "validityPeriod",
            sasDefinitionAttributes: ["options", "sasDefinitionAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, SasDefinitionCreateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateSasDefinitionOperationSpec = {
    httpMethod: "PATCH",
    path: "storage/{storage-account-name}/sas/{sas-definition-name}",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            templateUri: ["options", "templateUri"],
            sasType: ["options", "sasType"],
            validityPeriod: ["options", "validityPeriod"],
            sasDefinitionAttributes: ["options", "sasDefinitionAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, SasDefinitionUpdateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
var SDK_VERSION = "4.0.0";

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Creates a new ChallengeBasedAuthenticationPolicy factory.
 *
 * @param credential The TokenCredential implementation that can supply the challenge token.
 */
function challengeBasedAuthenticationPolicy(credential) {
    var tokenCache = new coreHttp.ExpiringAccessTokenCache();
    return {
        create: function (nextPolicy, options) {
            return new ChallengeBasedAuthenticationPolicy(nextPolicy, options, credential, tokenCache);
        }
    };
}
var AuthenticationChallenge = /** @class */ (function () {
    function AuthenticationChallenge(scopes) {
        this.scopes = scopes;
    }
    return AuthenticationChallenge;
}());
/**
 *
 * Provides a RequestPolicy that can request a token from a TokenCredential
 * implementation and then apply it to the Authorization header of a request
 * as a Bearer token.
 *
 */
var ChallengeBasedAuthenticationPolicy = /** @class */ (function (_super) {
    tslib.__extends(ChallengeBasedAuthenticationPolicy, _super);
    /**
     * Creates a new ChallengeBasedAuthenticationPolicy object.
     *
     * @param nextPolicy The next RequestPolicy in the request pipeline.
     * @param options Options for this RequestPolicy.
     * @param credential The TokenCredential implementation that can supply the bearer token.
     * @param tokenCache The cache for the most recent AccessToken returned by the TokenCredential.
     */
    function ChallengeBasedAuthenticationPolicy(nextPolicy, options, credential, tokenCache) {
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.credential = credential;
        _this.tokenCache = tokenCache;
        _this.challenge = undefined;
        return _this;
    }
    ChallengeBasedAuthenticationPolicy.prototype.parseWWWAuthenticate = function (www_authenticate) {
        // Parses an authentication message like:
        // ```
        // Bearer authorization="some_authorization", resource="https://some.url"
        // ```
        var authenticateArray = www_authenticate.split(" ");
        // Remove the "Bearer" piece
        delete authenticateArray[0];
        // Split the KV comma-separated list
        var commaSep = authenticateArray.join().split(",");
        for (var _i = 0, commaSep_1 = commaSep; _i < commaSep_1.length; _i++) {
            var item = commaSep_1[_i];
            // Split the key/value pairs
            var kv = item.split("=");
            if (kv[0].trim() == "resource") {
                // Remove the quotations around the string
                var resource = kv[1].trim().replace(/['"]+/g, '');
                return resource;
            }
        }
        return "";
    };
    /**
     * Applies the Bearer token to the request through the Authorization header.
     * @param webResource
     */
    ChallengeBasedAuthenticationPolicy.prototype.sendRequest = function (webResource) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var originalBody, response, www_authenticate, resource, challenge;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!webResource.headers)
                            webResource.headers = new coreHttp.HttpHeaders();
                        originalBody = webResource.body;
                        if (!(this.challenge == undefined)) return [3 /*break*/, 1];
                        // Use a blank to start the challenge
                        webResource.body = "";
                        return [3 /*break*/, 3];
                    case 1: 
                    // or use the cached token if we have one
                    return [4 /*yield*/, this.authenticateRequest(webResource)];
                    case 2:
                        // or use the cached token if we have one
                        _a.sent();
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this._nextPolicy.sendRequest(webResource)];
                    case 4:
                        response = _a.sent();
                        if (!(response.status == 401)) return [3 /*break*/, 7];
                        webResource.body = originalBody;
                        www_authenticate = response.headers.get("WWW-Authenticate");
                        if (!www_authenticate) return [3 /*break*/, 6];
                        resource = this.parseWWWAuthenticate(www_authenticate);
                        challenge = new AuthenticationChallenge(resource + "/.default");
                        if (!(this.challenge != challenge)) return [3 /*break*/, 6];
                        this.challenge = challenge;
                        this.tokenCache.setCachedToken(undefined);
                        return [4 /*yield*/, this.authenticateRequest(webResource)];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6: return [2 /*return*/, this._nextPolicy.sendRequest(webResource)];
                    case 7: return [2 /*return*/, response];
                }
            });
        });
    };
    ChallengeBasedAuthenticationPolicy.prototype.authenticateRequest = function (webResource) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var accessToken;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        accessToken = this.tokenCache.getCachedToken();
                        if (!(accessToken === undefined)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.credential.getToken(this.challenge.scopes)];
                    case 1:
                        accessToken = (_a.sent()) || undefined;
                        this.tokenCache.setCachedToken(accessToken);
                        _a.label = 2;
                    case 2:
                        if (accessToken) {
                            webResource.headers.set(coreHttp.Constants.HeaderConstants.AUTHORIZATION, "Bearer " + accessToken.token);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    return ChallengeBasedAuthenticationPolicy;
}(coreHttp.BaseRequestPolicy));

// Copyright (c) Microsoft Corporation.
/**
 * @summary Reaches to the service and updates the delete key's poll operation.
 * @param [options] The optional parameters, which are an abortSignal from @azure/abort-controller and a function that triggers the poller's onProgress function.
 */
function update(options) {
    if (options === void 0) { options = {}; }
    return tslib.__awaiter(this, void 0, void 0, function () {
        var state, name, client, requestOptions, deletedKey, _a, error_1;
        return tslib.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    state = this.state;
                    name = state.name, client = state.client;
                    requestOptions = state.requestOptions || {};
                    if (options.abortSignal) {
                        requestOptions.abortSignal = options.abortSignal;
                    }
                    if (!!state.isStarted) return [3 /*break*/, 2];
                    return [4 /*yield*/, client.deleteKey(name, requestOptions)];
                case 1:
                    deletedKey = _b.sent();
                    state.isStarted = true;
                    state.result = deletedKey;
                    if (!deletedKey.properties.recoveryId) {
                        state.isCompleted = true;
                    }
                    _b.label = 2;
                case 2:
                    if (!!state.isCompleted) return [3 /*break*/, 6];
                    _b.label = 3;
                case 3:
                    _b.trys.push([3, 5, , 6]);
                    _a = state;
                    return [4 /*yield*/, client.getDeletedKey(name, { requestOptions: requestOptions })];
                case 4:
                    _a.result = _b.sent();
                    state.isCompleted = true;
                    return [3 /*break*/, 6];
                case 5:
                    error_1 = _b.sent();
                    if (error_1.statusCode === 403) {
                        // At this point, the resource exists but the user doesn't have access to it.
                        state.isCompleted = true;
                    }
                    else if (error_1.statusCode !== 404) {
                        state.error = error_1;
                        state.isCompleted = true;
                    }
                    return [3 /*break*/, 6];
                case 6: return [2 /*return*/, makeDeleteKeyPollOperation(state)];
            }
        });
    });
}
/**
 * @summary Reaches to the service and cancels the key's operation, also updating the key's poll operation
 * @param [options] The optional parameters, which is only an abortSignal from @azure/abort-controller
 */
function cancel(_) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        return tslib.__generator(this, function (_a) {
            throw new Error("Canceling the deletion of a key is not supported.");
        });
    });
}
/**
 * @summary Serializes the create key's poll operation
 */
function toString() {
    return JSON.stringify({
        state: this.state
    });
}
/**
 * @summary Builds a create key's poll operation
 * @param [state] A poll operation's state, in case the new one is intended to follow up where the previous one was left.
 */
function makeDeleteKeyPollOperation(state) {
    return {
        state: tslib.__assign({}, state),
        update: update,
        cancel: cancel,
        toString: toString
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that deletes a poller that waits until a key finishes being deleted
 */
var DeleteKeyPoller = /** @class */ (function (_super) {
    tslib.__extends(DeleteKeyPoller, _super);
    function DeleteKeyPoller(options) {
        var _this = this;
        var client = options.client, name = options.name, requestOptions = options.requestOptions, _a = options.intervalInMs, intervalInMs = _a === void 0 ? 2000 : _a, resumeFrom = options.resumeFrom;
        var state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        var operation = makeDeleteKeyPollOperation(tslib.__assign(tslib.__assign({}, state), { name: name,
            requestOptions: requestOptions,
            client: client }));
        _this = _super.call(this, operation) || this;
        _this.intervalInMs = intervalInMs;
        return _this;
    }
    /**
     * The method used by the poller to wait before attempting to update its operation.
     * @memberof DeleteKeyPoller
     */
    DeleteKeyPoller.prototype.delay = function () {
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                return [2 /*return*/, coreHttp.delay(this.intervalInMs)];
            });
        });
    };
    return DeleteKeyPoller;
}(coreLro.Poller));

// Copyright (c) Microsoft Corporation.
/**
 * @summary Reaches to the service and updates the delete key's poll operation.
 * @param [options] The optional parameters, which are an abortSignal from @azure/abort-controller and a function that triggers the poller's onProgress function.
 */
function update$1(options) {
    if (options === void 0) { options = {}; }
    return tslib.__awaiter(this, void 0, void 0, function () {
        var state, name, client, requestOptions, _a, _1, _b, _c, error_1;
        return tslib.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    state = this.state;
                    name = state.name, client = state.client;
                    requestOptions = state.requestOptions || {};
                    if (options.abortSignal) {
                        requestOptions.abortSignal = options.abortSignal;
                    }
                    if (!!state.isStarted) return [3 /*break*/, 6];
                    _d.label = 1;
                case 1:
                    _d.trys.push([1, 3, , 4]);
                    _a = state;
                    return [4 /*yield*/, client.getKey(name, { requestOptions: requestOptions })];
                case 2:
                    _a.result = _d.sent();
                    state.isCompleted = true;
                    return [3 /*break*/, 4];
                case 3:
                    _1 = _d.sent();
                    return [3 /*break*/, 4];
                case 4:
                    if (!!state.isCompleted) return [3 /*break*/, 6];
                    _b = state;
                    return [4 /*yield*/, client.recoverDeletedKey(name, { requestOptions: requestOptions })];
                case 5:
                    _b.result = _d.sent();
                    state.isStarted = true;
                    _d.label = 6;
                case 6:
                    if (!!state.isCompleted) return [3 /*break*/, 10];
                    _d.label = 7;
                case 7:
                    _d.trys.push([7, 9, , 10]);
                    _c = state;
                    return [4 /*yield*/, client.getKey(name, { requestOptions: requestOptions })];
                case 8:
                    _c.result = _d.sent();
                    state.isCompleted = true;
                    return [3 /*break*/, 10];
                case 9:
                    error_1 = _d.sent();
                    if (error_1.statusCode === 403) {
                        // At this point, the resource exists but the user doesn't have access to it.
                        state.isCompleted = true;
                    }
                    else if (error_1.statusCode !== 404) {
                        state.error = error_1;
                        state.isCompleted = true;
                    }
                    return [3 /*break*/, 10];
                case 10: return [2 /*return*/, makeRecoverDeletedKeyPollOperation(state)];
            }
        });
    });
}
/**
 * @summary Reaches to the service and cancels the key's operation, also updating the key's poll operation
 * @param [options] The optional parameters, which is only an abortSignal from @azure/abort-controller
 */
function cancel$1(_) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        return tslib.__generator(this, function (_a) {
            throw new Error("Canceling the deletion of a key is not supported.");
        });
    });
}
/**
 * @summary Serializes the create key's poll operation
 */
function toString$1() {
    return JSON.stringify({
        state: this.state
    });
}
/**
 * @summary Builds a create key's poll operation
 * @param [state] A poll operation's state, in case the new one is intended to follow up where the previous one was left.
 */
function makeRecoverDeletedKeyPollOperation(state) {
    return {
        state: tslib.__assign({}, state),
        update: update$1,
        cancel: cancel$1,
        toString: toString$1
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that deletes a poller that waits until a key finishes being deleted
 */
var RecoverDeletedKeyPoller = /** @class */ (function (_super) {
    tslib.__extends(RecoverDeletedKeyPoller, _super);
    function RecoverDeletedKeyPoller(options) {
        var _this = this;
        var client = options.client, name = options.name, requestOptions = options.requestOptions, _a = options.intervalInMs, intervalInMs = _a === void 0 ? 2000 : _a, resumeFrom = options.resumeFrom;
        var state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        var operation = makeRecoverDeletedKeyPollOperation(tslib.__assign(tslib.__assign({}, state), { name: name,
            requestOptions: requestOptions,
            client: client }));
        _this = _super.call(this, operation) || this;
        _this.intervalInMs = intervalInMs;
        return _this;
    }
    /**
     * The method used by the poller to wait before attempting to update its operation.
     * @memberof RecoverDeletedKeyPoller
     */
    RecoverDeletedKeyPoller.prototype.delay = function () {
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                return [2 /*return*/, coreHttp.delay(this.intervalInMs)];
            });
        });
    };
    return RecoverDeletedKeyPoller;
}(coreLro.Poller));

function parseKeyvaultIdentifier(collection, identifier) {
    if (typeof collection != "string" || !(collection = collection.trim())) {
        throw new Error("Invalid collection argument");
    }
    if (typeof identifier != "string" || !(identifier = identifier.trim())) {
        throw new Error("Invalid identifier argument");
    }
    var baseUri;
    try {
        baseUri = url.parse(identifier, true, true);
    }
    catch (e) {
        throw new Error("Invalid " + collection + " identifier: " + identifier + ". Not a valid URI");
    }
    // Path is of the form '/collection/name[/version]'
    var segments = (baseUri.pathname || "").split("/");
    if (segments.length !== 3 && segments.length !== 4) {
        throw new Error("Invalid " + collection + " identifier: " + identifier + ". Bad number of segments: " + segments.length);
    }
    if (collection !== segments[1]) {
        throw new Error("Invalid " + collection + " identifier: " + identifier + ". segment [1] should be \"" + collection + "\", found \"" + segments[1] + "\"");
    }
    var vaultUrl = baseUri.protocol + "//" + baseUri.host;
    var name = segments[2];
    var version = segments.length === 4 ? segments[3] : undefined;
    return {
        vaultUrl: vaultUrl,
        name: name,
        version: version
    };
}

// This is part of constructing the autogenerated client. In the future, it should not
// be required. See also: https://github.com/Azure/azure-sdk-for-js/issues/5508
var SERVICE_API_VERSION = "7.0";
/**
 * A client used to perform cryptographic operations with Azure Key Vault keys.
 */
var CryptographyClient = /** @class */ (function () {
    /**
     * Constructs a new instance of the Cryptography client for the given key
     *
     * Example usage:
     * ```ts
     * import { KeyClient, CryptographyClient } from "@azure/keyvault-keys";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;
     * let credentials = new DefaultAzureCredential();
     *
     * let keyClient = new KeyClient(vaultUrl, credentials);
     * let keyVaultKey = await keyClient.getKey("MyKey");
     *
     * let client = new CryptographyClient(keyVaultKey.id, credentials);
     * // or
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * ```
     * @param key The key to use during cryptography tasks.
     * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.
     * @param {PipelineOptions} [pipelineOptions={}] Optional. Pipeline options used to configure Key Vault API requests.
     *                                                         Omit this parameter to use the default pipeline configuration.
     * @memberof CryptographyClient
     */
    function CryptographyClient(key, // keyUrl or KeyVaultKey
    credential, pipelineOptions) {
        if (pipelineOptions === void 0) { pipelineOptions = {}; }
        var libInfo = "azsdk-js-keyvault-keys/" + SDK_VERSION;
        if (pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions.userAgentPrefix !== undefined
                ? pipelineOptions.userAgentOptions.userAgentPrefix + " " + libInfo
                : libInfo;
        }
        else {
            pipelineOptions.userAgentOptions = {
                userAgentPrefix: libInfo
            };
        }
        var authPolicy = coreHttp.isTokenCredential(credential)
            ? challengeBasedAuthenticationPolicy(credential)
            : coreHttp.signingPolicy(credential);
        var internalPipelineOptions = tslib.__assign(tslib.__assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                logPolicyOptions: {
                    allowedHeaderNames: [
                        "x-ms-keyvault-region",
                        "x-ms-keyvault-network-info",
                        "x-ms-keyvault-service-version"
                    ]
                }
            }
        });
        var pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new KeyVaultClient(credential, SERVICE_API_VERSION, pipeline);
        var parsed;
        if (typeof key === "string") {
            this.key = key;
            parsed = parseKeyvaultIdentifier("keys", this.key);
            this.hasTriedToGetKey = false;
        }
        else if (key.key) {
            this.key = key.key;
            parsed = parseKeyvaultIdentifier("keys", this.key.kid);
            this.hasTriedToGetKey = true;
        }
        else {
            throw new Error("The provided key is malformed as it does not have a value for the `key` property.");
        }
        if (parsed.name == "") {
            throw new Error("Could not find 'name' of key in key URL");
        }
        if (!parsed.version || parsed.version == "") {
            throw new Error("Could not find 'version' of key in key URL");
        }
        if (!parsed.vaultUrl || parsed.vaultUrl == "") {
            throw new Error("Could not find 'vaultUrl' of key in key URL");
        }
        this.vaultUrl = parsed.vaultUrl;
        this.name = parsed.name;
        this.version = parsed.version;
    }
    /**
     * @internal
     * @ignore
     * Retrieves the {@link JsonWebKey} from the Key Vault.
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.getKey();
     * ```
     * @param {GetKeyOptions} [options] Options for retrieving key.
     */
    CryptographyClient.prototype.getKey = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, key;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("getKey", requestOptions);
                        if (!(typeof this.key === "string")) return [3 /*break*/, 2];
                        if (!this.name || this.name === "") {
                            throw new Error("getKey requires a key with a name");
                        }
                        return [4 /*yield*/, this.client.getKey(this.vaultUrl, this.name, options && options.version ? options.version : this.version ? this.version : "", this.setParentSpan(span, requestOptions))];
                    case 1:
                        key = _a.sent();
                        return [2 /*return*/, key.key];
                    case 2: return [2 /*return*/, this.key];
                }
            });
        });
    };
    /**
     * Encrypts the given plaintext with the specified cryptography algorithm
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.encrypt("RSA1_5", Buffer.from("My Message"));
     * ```
     * @param {EncryptionAlgorithm} algorithm The algorithm to use.
     * @param {Uint8Array} plaintext The text to encrypt.
     * @param {EncryptOptions} [options] Additional options.
     */
    CryptographyClient.prototype.encrypt = function (algorithm, plaintext, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, keyPEM, padded, encrypted, keyPEM, encrypted, result;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("encrypt", requestOptions);
                        if (!coreHttp.isNode) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.fetchFullKeyIfPossible()];
                    case 1:
                        _a.sent();
                        if (typeof this.key !== "string") {
                            switch (algorithm) {
                                case "RSA1_5": {
                                    if (this.key.kty != "RSA") {
                                        span.end();
                                        throw new Error("Key type does not match algorithm");
                                    }
                                    if (this.key.keyOps && !this.key.keyOps.includes("encrypt")) {
                                        span.end();
                                        throw new Error("Key does not support the encrypt operation");
                                    }
                                    keyPEM = convertJWKtoPEM(this.key);
                                    padded = { key: keyPEM, padding: constants.RSA_PKCS1_PADDING };
                                    encrypted = crypto.publicEncrypt(padded, Buffer.from(plaintext));
                                    return [2 /*return*/, { result: encrypted, algorithm: algorithm, keyID: this.key.kid }];
                                }
                                case "RSA-OAEP": {
                                    if (this.key.kty != "RSA") {
                                        span.end();
                                        throw new Error("Key type does not match algorithm");
                                    }
                                    if (this.key.keyOps && !this.key.keyOps.includes("encrypt")) {
                                        span.end();
                                        throw new Error("Key does not support the encrypt operation");
                                    }
                                    keyPEM = convertJWKtoPEM(this.key);
                                    encrypted = crypto.publicEncrypt(keyPEM, Buffer.from(plaintext));
                                    return [2 /*return*/, { result: encrypted, algorithm: algorithm, keyID: this.key.kid }];
                                }
                            }
                        }
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, , 4, 5]);
                        return [4 /*yield*/, this.client.encrypt(this.vaultUrl, this.name, this.version, algorithm, plaintext, this.setParentSpan(span, requestOptions))];
                    case 3:
                        result = _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/, { result: result.result, algorithm: algorithm, keyID: this.getKeyID() }];
                }
            });
        });
    };
    /**
     * Decrypts the given ciphertext with the specified cryptography algorithm
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.decrypt("RSA1_5", encryptedBuffer);
     * ```
     * @param {EncryptionAlgorithm} algorithm The algorithm to use.
     * @param {Uint8Array} ciphertext The text to decrypt.
     * @param {EncryptOptions} [options] Additional options.
     */
    CryptographyClient.prototype.decrypt = function (algorithm, ciphertext, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, result;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("decrypt", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.decrypt(this.vaultUrl, this.name, this.version, algorithm, ciphertext, this.setParentSpan(span, requestOptions))];
                    case 2:
                        result = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, { result: result.result, keyID: this.getKeyID(), algorithm: algorithm }];
                }
            });
        });
    };
    /**
     * Wraps the given key using the specified cryptography algorithm
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.wrapKey("RSA1_5", keyToWrap);
     * ```
     * @param {KeyWrapAlgorithm} algorithm The encryption algorithm to use to wrap the given key.
     * @param {Uint8Array} key The key to wrap.
     * @param {EncryptOptions} [options] Additional options.
     */
    CryptographyClient.prototype.wrapKey = function (algorithm, key, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, keyPEM, padded, encrypted, keyPEM, encrypted, result;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("wrapKey", requestOptions);
                        if (!coreHttp.isNode) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.fetchFullKeyIfPossible()];
                    case 1:
                        _a.sent();
                        if (typeof this.key !== "string") {
                            switch (algorithm) {
                                case "RSA1_5": {
                                    if (this.key.kty != "RSA") {
                                        span.end();
                                        throw new Error("Key type does not match algorithm");
                                    }
                                    if (this.key.keyOps && !this.key.keyOps.includes("wrapKey")) {
                                        span.end();
                                        throw new Error("Key does not support the wrapKey operation");
                                    }
                                    keyPEM = convertJWKtoPEM(this.key);
                                    padded = { key: keyPEM, padding: constants.RSA_PKCS1_PADDING };
                                    encrypted = crypto.publicEncrypt(padded, Buffer.from(key));
                                    return [2 /*return*/, { result: encrypted, algorithm: algorithm, keyID: this.getKeyID() }];
                                }
                                case "RSA-OAEP": {
                                    if (this.key.kty != "RSA") {
                                        span.end();
                                        throw new Error("Key type does not match algorithm");
                                    }
                                    if (this.key.keyOps && !this.key.keyOps.includes("wrapKey")) {
                                        span.end();
                                        throw new Error("Key does not support the wrapKey operation");
                                    }
                                    keyPEM = convertJWKtoPEM(this.key);
                                    encrypted = crypto.publicEncrypt(keyPEM, Buffer.from(key));
                                    return [2 /*return*/, { result: encrypted, algorithm: algorithm, keyID: this.getKeyID() }];
                                }
                            }
                        }
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, , 4, 5]);
                        return [4 /*yield*/, this.client.wrapKey(this.vaultUrl, this.name, this.version, algorithm, key, this.setParentSpan(span, requestOptions))];
                    case 3:
                        result = _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/, { result: result.result, algorithm: algorithm, keyID: this.getKeyID() }];
                }
            });
        });
    };
    /**
     * Unwraps the given wrapped key using the specified cryptography algorithm
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.unwrapKey("RSA1_5", keyToUnwrap);
     * ```
     * @param {KeyWrapAlgorithm} algorithm The decryption algorithm to use to unwrap the key.
     * @param {Uint8Array} encryptedKey The encrypted key to unwrap.
     * @param {EncryptOptions} [options] Additional options.
     */
    CryptographyClient.prototype.unwrapKey = function (algorithm, encryptedKey, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, result;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("unwrapKey", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.unwrapKey(this.vaultUrl, this.name, this.version, algorithm, encryptedKey, this.setParentSpan(span, requestOptions))];
                    case 2:
                        result = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, { result: result.result, keyID: this.getKeyID() }];
                }
            });
        });
    };
    /**
     * Cryptographically sign the digest of a message
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.sign("RS256", digest);
     * ```
     * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use.
     * @param {Uint8Array} digest The digest of the data to sign.
     * @param {EncryptOptions} [options] Additional options.
     */
    CryptographyClient.prototype.sign = function (algorithm, digest, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, result;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("sign", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.sign(this.vaultUrl, this.name, this.version, algorithm, digest, this.setParentSpan(span, requestOptions))];
                    case 2:
                        result = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, { result: result.result, algorithm: algorithm, keyID: this.getKeyID() }];
                }
            });
        });
    };
    /**
     * Verify the signed message digest
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.verify("RS256", signedDigest, signature);
     * ```
     * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use to verify with.
     * @param {Uint8Array} digest The digest to verify.
     * @param {Uint8Array} signature The signature to verify the digest against.
     * @param {EncryptOptions} [options] Additional options.
     */
    CryptographyClient.prototype.verify = function (algorithm, digest, signature, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("verify", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.verify(this.vaultUrl, this.name, this.version, algorithm, digest, signature, this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, { result: response.value ? response.value : false, keyID: this.getKeyID() }];
                }
            });
        });
    };
    /**
     * Cryptographically sign a block of data
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.signData("RS256", message);
     * ```
     * @param {KeySignatureAlgorithm} algorithm The signing algorithm to use.
     * @param {Uint8Array} data The data to sign.
     * @param {EncryptOptions} [options] Additional options.
     */
    CryptographyClient.prototype.signData = function (algorithm, data, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, digest, _a, result;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("signData", requestOptions);
                        _a = algorithm;
                        switch (_a) {
                            case "ES256": return [3 /*break*/, 1];
                            case "ES256K": return [3 /*break*/, 1];
                            case "PS256": return [3 /*break*/, 1];
                            case "RS256": return [3 /*break*/, 1];
                            case "ES384": return [3 /*break*/, 3];
                            case "PS384": return [3 /*break*/, 3];
                            case "RS384": return [3 /*break*/, 3];
                            case "ES512": return [3 /*break*/, 5];
                            case "PS512": return [3 /*break*/, 5];
                            case "RS512": return [3 /*break*/, 5];
                        }
                        return [3 /*break*/, 7];
                    case 1: return [4 /*yield*/, createHash("sha256", data)];
                    case 2:
                        digest = _b.sent();
                        return [3 /*break*/, 8];
                    case 3: return [4 /*yield*/, createHash("sha384", data)];
                    case 4:
                        digest = _b.sent();
                        return [3 /*break*/, 8];
                    case 5: return [4 /*yield*/, createHash("sha512", data)];
                    case 6:
                        digest = _b.sent();
                        return [3 /*break*/, 8];
                    case 7:
                        {
                            throw new Error("Unsupported signature algorithm");
                        }
                        _b.label = 8;
                    case 8:
                        _b.trys.push([8, , 10, 11]);
                        return [4 /*yield*/, this.client.sign(this.vaultUrl, this.name, this.version, algorithm, digest, this.setParentSpan(span, requestOptions))];
                    case 9:
                        result = _b.sent();
                        return [3 /*break*/, 11];
                    case 10:
                        span.end();
                        return [7 /*endfinally*/];
                    case 11: return [2 /*return*/, { result: result.result, algorithm: algorithm, keyID: this.getKeyID() }];
                }
            });
        });
    };
    /**
     * Verify the signed block of data
     *
     * Example usage:
     * ```ts
     * let client = new CryptographyClient(keyVaultKey, credentials);
     * let result = await client.verifyData("RS256", signedMessage, signature);
     * ```
     * @param {KeySignatureAlgorithm} algorithm The algorithm to use to verify with.
     * @param {Uint8Array} data The signed block of data to verify.
     * @param {Uint8Array} signature The signature to verify the block against.
     * @param {EncryptOptions} [options] Additional options.
     */
    CryptographyClient.prototype.verifyData = function (algorithm, data, signature, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, keyPEM, verifier, keyPEM, verifier, keyPEM, verifier, digest, _a, result;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("verifyData", requestOptions);
                        if (!coreHttp.isNode) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.fetchFullKeyIfPossible()];
                    case 1:
                        _b.sent();
                        if (typeof this.key !== "string") {
                            switch (algorithm) {
                                case "RS256": {
                                    if (this.key.kty != "RSA") {
                                        throw new Error("Key type does not match algorithm");
                                    }
                                    if (this.key.keyOps && !this.key.keyOps.includes("verify")) {
                                        throw new Error("Key does not support the verify operation");
                                    }
                                    keyPEM = convertJWKtoPEM(this.key);
                                    verifier = crypto.createVerify("SHA256");
                                    verifier.update(Buffer.from(data));
                                    verifier.end();
                                    return [2 /*return*/, {
                                            result: verifier.verify(keyPEM, Buffer.from(signature)),
                                            keyID: this.getKeyID()
                                        }];
                                }
                                case "RS384": {
                                    if (this.key.kty != "RSA") {
                                        throw new Error("Key type does not match algorithm");
                                    }
                                    if (this.key.keyOps && !this.key.keyOps.includes("verify")) {
                                        throw new Error("Key does not support the verify operation");
                                    }
                                    keyPEM = convertJWKtoPEM(this.key);
                                    verifier = crypto.createVerify("SHA384");
                                    verifier.update(Buffer.from(data));
                                    verifier.end();
                                    return [2 /*return*/, {
                                            result: verifier.verify(keyPEM, Buffer.from(signature)),
                                            keyID: this.getKeyID()
                                        }];
                                }
                                case "RS512": {
                                    if (this.key.kty != "RSA") {
                                        throw new Error("Key type does not match algorithm");
                                    }
                                    if (this.key.keyOps && !this.key.keyOps.includes("verify")) {
                                        throw new Error("Key does not support the verify operation");
                                    }
                                    keyPEM = convertJWKtoPEM(this.key);
                                    verifier = crypto.createVerify("SHA512");
                                    verifier.update(Buffer.from(data));
                                    verifier.end();
                                    return [2 /*return*/, {
                                            result: verifier.verify(keyPEM, Buffer.from(signature)),
                                            keyID: this.getKeyID()
                                        }];
                                }
                            }
                        }
                        _b.label = 2;
                    case 2:
                        _a = algorithm;
                        switch (_a) {
                            case "ES256": return [3 /*break*/, 3];
                            case "ES256K": return [3 /*break*/, 3];
                            case "PS256": return [3 /*break*/, 3];
                            case "RS256": return [3 /*break*/, 3];
                            case "ES384": return [3 /*break*/, 5];
                            case "PS384": return [3 /*break*/, 5];
                            case "RS384": return [3 /*break*/, 5];
                            case "ES512": return [3 /*break*/, 7];
                            case "PS512": return [3 /*break*/, 7];
                            case "RS512": return [3 /*break*/, 7];
                        }
                        return [3 /*break*/, 9];
                    case 3: return [4 /*yield*/, createHash("sha256", data)];
                    case 4:
                        digest = _b.sent();
                        return [3 /*break*/, 10];
                    case 5: return [4 /*yield*/, createHash("sha384", data)];
                    case 6:
                        digest = _b.sent();
                        return [3 /*break*/, 10];
                    case 7: return [4 /*yield*/, createHash("sha512", data)];
                    case 8:
                        digest = _b.sent();
                        return [3 /*break*/, 10];
                    case 9:
                        {
                            throw new Error("Unsupported signature algorithm");
                        }
                        _b.label = 10;
                    case 10:
                        _b.trys.push([10, , 12, 13]);
                        return [4 /*yield*/, this.client.verify(this.vaultUrl, this.name, this.version, algorithm, digest, signature, this.setParentSpan(span, requestOptions))];
                    case 11:
                        result = _b.sent();
                        return [3 /*break*/, 13];
                    case 12:
                        span.end();
                        return [7 /*endfinally*/];
                    case 13: return [2 /*return*/, { result: result.value, keyID: this.getKeyID() }];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Attempts to fetch the key from the service.
     */
    CryptographyClient.prototype.fetchFullKeyIfPossible = function () {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var result, _a;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!!this.hasTriedToGetKey) return [3 /*break*/, 5];
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.getKey()];
                    case 2:
                        result = _b.sent();
                        this.key = result;
                        return [3 /*break*/, 4];
                    case 3:
                        _a = _b.sent();
                        return [3 /*break*/, 4];
                    case 4:
                        this.hasTriedToGetKey = true;
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Attempts to retrieve the ID of the key.
     */
    CryptographyClient.prototype.getKeyID = function () {
        var kid;
        if (typeof this.key !== "string") {
            kid = this.key.kid;
        }
        else {
            kid = this.key;
        }
        return kid;
    };
    /**
     * @internal
     * @ignore
     * Creates a span using the tracer that was set by the user.
     * @param {string} methodName The name of the method creating the span.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    CryptographyClient.prototype.createSpan = function (methodName, requestOptions) {
        var tracer = coreTracing.getTracer();
        return tracer.startSpan("CryptographyClient " + methodName, requestOptions && requestOptions.spanOptions);
    };
    /**
     * @internal
     * @ignore
     * Returns updated HTTP options with the given span as the parent of future spans,
     * if applicable.
     * @param {Span} span The span for the current operation.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    CryptographyClient.prototype.setParentSpan = function (span, options) {
        if (options === void 0) { options = {}; }
        if (span.isRecordingEvents()) {
            return tslib.__assign(tslib.__assign({}, options), { spanOptions: tslib.__assign(tslib.__assign({}, options.spanOptions), { parent: span }) });
        }
        else {
            return options;
        }
    };
    return CryptographyClient;
}());
/**
 * @internal
 * @ignore
 * Encodes a length of a packet in DER format
 */
function encodeLength(length) {
    if (length <= 127) {
        return Uint8Array.of(length);
    }
    else if (length < 256) {
        return Uint8Array.of(0x81, length);
    }
    else if (length < 65536) {
        return Uint8Array.of(0x82, length >> 8, length & 0xff);
    }
    else {
        throw new Error("Unsupported length to encode");
    }
}
/**
 * @internal
 * @ignore
 * Encodes a buffer for DER, as sets the id to the given id
 */
function encodeBuffer(buffer, bufferId) {
    if (buffer.length == 0) {
        return buffer;
    }
    var result = new Uint8Array(buffer);
    // If the high bit is set, prepend a 0
    if ((result[0] & 0x80) === 0x80) {
        var array = new Uint8Array(result.length + 1);
        array[0] = 0;
        array.set(result, 1);
        result = array;
    }
    // Prepend the DER header for this buffer
    var encodedLength = encodeLength(result.length);
    var totalLength = 1 + encodedLength.length + result.length;
    var outputBuffer = new Uint8Array(totalLength);
    outputBuffer[0] = bufferId;
    outputBuffer.set(encodedLength, 1);
    outputBuffer.set(result, 1 + encodedLength.length);
    return outputBuffer;
}
/**
 * @internal
 * @ignore
 * Encode a JWK to PEM format. To do so, it internally repackages the JWK as a DER
 * that is then encoded as a PEM.
 */
function convertJWKtoPEM(key) {
    if (!key.n || !key.e) {
        throw new Error("Unsupported key format for local operations");
    }
    var encoded_n = encodeBuffer(key.n, 0x2); // INTEGER
    var encoded_e = encodeBuffer(key.e, 0x2); // INTEGER
    var encoded_ne = new Uint8Array(encoded_n.length + encoded_e.length);
    encoded_ne.set(encoded_n, 0);
    encoded_ne.set(encoded_e, encoded_n.length);
    var full_encoded = encodeBuffer(encoded_ne, 0x30); //SEQUENCE
    var buffer = Buffer.from(full_encoded).toString("base64");
    var beginBanner = "-----BEGIN RSA PUBLIC KEY-----\n";
    var endBanner = "-----END RSA PUBLIC KEY-----";
    /*
     Fill in the PEM with 64 character lines as per RFC:
  
     "To represent the encapsulated text of a PEM message, the encoding
     function's output is delimited into text lines (using local
     conventions), with each line except the last containing exactly 64
     printable characters and the final line containing 64 or fewer
     printable characters."
    */
    var outputString = beginBanner;
    var lines = buffer.match(/.{1,64}/g);
    if (lines) {
        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
            var line = lines_1[_i];
            outputString += line;
            outputString += "\n";
        }
    }
    else {
        throw new Error("Could not create correct PEM");
    }
    outputString += endBanner;
    return outputString;
}
/**
 * @internal
 * @ignore
 * Use the platform-local hashing functionality
 */
function createHash(algorithm, data) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        var hash, digest, _a, _b;
        return tslib.__generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (!coreHttp.isNode) return [3 /*break*/, 1];
                    hash = crypto.createHash(algorithm);
                    hash.update(Buffer.from(data));
                    digest = hash.digest();
                    return [2 /*return*/, digest];
                case 1:
                    if (!(window && window.crypto && window.crypto.subtle)) return [3 /*break*/, 3];
                    _b = (_a = Buffer).from;
                    return [4 /*yield*/, window.crypto.subtle.digest(algorithm, Buffer.from(data))];
                case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                case 3: throw new Error("Browser does not support cryptography functions");
            }
        });
    });
}

// Copyright (c) Microsoft Corporation.
// This is part of constructing the autogenerated client. In the future, it should not
// be required. See also: https://github.com/Azure/azure-sdk-for-js/issues/5508
var SERVICE_API_VERSION$1 = "7.0";
/**
 * The KeyClient provides methods to manage {@link KeyVaultKey} in the
 * Azure Key Vault. The client supports creating, retrieving, updating,
 * deleting, purging, backing up, restoring and listing KeyVaultKeys. The
 * client also supports listing {@link DeletedKey} for a soft-delete enabled Azure Key
 * Vault.
 */
var KeyClient = /** @class */ (function () {
    /**
     * Creates an instance of KeyClient.
     *
     * Example usage:
     * ```ts
     * import { KeyClient } from "@azure/keyvault-keys";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;
     * let credentials = new DefaultAzureCredential();
     *
     * let client = new KeyClient(vaultUrl, credentials);
     * ```
     * @param {string} vaultUrl the URL of the Key Vault. It should have this shape: https://${your-key-vault-name}.vault.azure.net
     * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.
     * @param {PipelineOptions} [pipelineOptions] Pipeline options used to configure Key Vault API requests. Omit this parameter to use the default pipeline configuration.
     * @memberof KeyClient
     */
    function KeyClient(vaultUrl, credential, pipelineOptions) {
        if (pipelineOptions === void 0) { pipelineOptions = {}; }
        /**
         * @internal
         * @ignore
         * A self reference that bypasses private methods, for the pollers.
         */
        this.pollerClient = {
            recoverDeletedKey: this.recoverDeletedKey.bind(this),
            getKey: this.getKey.bind(this),
            deleteKey: this.deleteKey.bind(this),
            getDeletedKey: this.getDeletedKey.bind(this)
        };
        this.vaultUrl = vaultUrl;
        var libInfo = "azsdk-js-keyvault-keys/" + SDK_VERSION;
        if (pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions.userAgentPrefix !== undefined
                ? pipelineOptions.userAgentOptions.userAgentPrefix + " " + libInfo
                : libInfo;
        }
        else {
            pipelineOptions.userAgentOptions = {
                userAgentPrefix: libInfo
            };
        }
        var authPolicy = coreHttp.isTokenCredential(credential)
            ? challengeBasedAuthenticationPolicy(credential)
            : coreHttp.signingPolicy(credential);
        var internalPipelineOptions = tslib.__assign(tslib.__assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                logPolicyOptions: {
                    allowedHeaderNames: [
                        "x-ms-keyvault-region",
                        "x-ms-keyvault-network-info",
                        "x-ms-keyvault-service-version"
                    ]
                }
            }
        });
        var pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new KeyVaultClient(credential, SERVICE_API_VERSION$1, pipeline);
    }
    /**
     * @internal
     * @ignore
     * Sends a delete request for the given KeyVault Key's name to the KeyVault service.
     * Since the KeyVault Key won't be immediately deleted, we have {@link beginDeleteKey}.
     * @param {string} name The name of the KeyVault Key.
     * @param {DeleteKeyOptions} [options] Optional parameters for the underlying HTTP request.
     */
    KeyClient.prototype.deleteKey = function (name, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("deleteKey", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.deleteKey(this.vaultUrl, name, this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Sends a request to recover a deleted KeyVault Key based on the given name.
     * Since the KeyVault Key won't be immediately recover the deleted key, we have {@link beginRecoverDeletedKey}.
     * @param {string} name The name of the KeyVault Key.
     * @param {RecoverDeletedKeyOptions} [options] Optional parameters for the underlying HTTP request.
     */
    KeyClient.prototype.recoverDeletedKey = function (name, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("recoverDeletedKey", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.recoverDeletedKey(this.vaultUrl, name, this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * The create key operation can be used to create any key type in Azure Key Vault. If the named key
     * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create
     * permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * // Create an elliptic-curve key:
     * let result = await client.createKey("MyKey", "EC");
     * ```
     * @summary Creates a new key, stores it, then returns key parameters and properties to the client.
     * @param {string} name The name of the key.
     * @param {JsonWebKeyType} keyType The type of the key. One of the following: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'.
     * @param {CreateKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.createKey = function (name, keyType, options) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, enabled, notBefore, expires, remainingOptions, unflattenedOptions, span, response, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 5];
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        enabled = requestOptions.enabled, notBefore = requestOptions.notBefore, expires = requestOptions.expiresOn, remainingOptions = tslib.__rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                        unflattenedOptions = tslib.__assign(tslib.__assign({}, remainingOptions), { keyAttributes: {
                                enabled: enabled,
                                notBefore: notBefore,
                                expires: expires
                            } });
                        span = this.createSpan("createKey", unflattenedOptions);
                        response = void 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.createKey(this.vaultUrl, name, keyType, this.setParentSpan(span, unflattenedOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                    case 5: return [4 /*yield*/, this.client.createKey(this.vaultUrl, name, keyType, options)];
                    case 6:
                        response = _a.sent();
                        return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * The createEcKey method creates a new eliptic curve key in Azure Key Vault. If the named key
     * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create
     * permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let result = await client.createEcKey("MyKey", { curve: "P-256" });
     * ```
     * @summary Creates a new key, stores it, then returns key parameters and properties to the client.
     * @param {string} name The name of the key.
     * @param {CreateEcKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.createEcKey = function (name, options) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, enabled, notBefore, expires, remainingOptions, unflattenedOptions, span, response, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 5];
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        enabled = requestOptions.enabled, notBefore = requestOptions.notBefore, expires = requestOptions.expiresOn, remainingOptions = tslib.__rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                        unflattenedOptions = tslib.__assign(tslib.__assign({}, remainingOptions), { keyAttributes: {
                                enabled: enabled,
                                notBefore: notBefore,
                                expires: expires
                            } });
                        span = this.createSpan("createEcKey", unflattenedOptions);
                        response = void 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.createKey(this.vaultUrl, name, options.hsm ? "EC-HSM" : "EC", this.setParentSpan(span, unflattenedOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                    case 5: return [4 /*yield*/, this.client.createKey(this.vaultUrl, name, "EC", options)];
                    case 6:
                        response = _a.sent();
                        return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * The createRSAKey method creates a new RSA key in Azure Key Vault. If the named key
     * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create
     * permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let result = await client.createRsaKey("MyKey", { keySize: 2048 });
     * ```
     * @summary Creates a new key, stores it, then returns key parameters and properties to the client.
     * @param {string} name The name of the key.
     * @param {CreateRsaKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.createRsaKey = function (name, options) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, enabled, notBefore, expires, remainingOptions, unflattenedOptions, span, response, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 5];
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        enabled = requestOptions.enabled, notBefore = requestOptions.notBefore, expires = requestOptions.expiresOn, remainingOptions = tslib.__rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                        unflattenedOptions = tslib.__assign(tslib.__assign({}, remainingOptions), { keyAttributes: {
                                enabled: enabled,
                                notBefore: notBefore,
                                expires: expires
                            } });
                        span = this.createSpan("createRsaKey", unflattenedOptions);
                        response = void 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.createKey(this.vaultUrl, name, options.hsm ? "RSA-HSM" : "RSA", this.setParentSpan(span, unflattenedOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                    case 5: return [4 /*yield*/, this.client.createKey(this.vaultUrl, name, "RSA", options)];
                    case 6:
                        response = _a.sent();
                        return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * The import key operation may be used to import any key type into an Azure Key Vault. If the
     * named key already exists, Azure Key Vault creates a new version of the key. This operation
     * requires the keys/import permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * // Key contents in myKeyContents
     * let result = await client.importKey("MyKey", myKeyContents);
     * ```
     * @summary Imports an externally created key, stores it, and returns key parameters and properties
     * to the client.
     * @param {string} name Name for the imported key.
     * @param {JsonWebKey} key The JSON web key.
     * @param {ImportKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.importKey = function (name, key, options) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, enabled, notBefore, expires, hsm, remainingOptions, unflattenedOptions, span, response, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 5];
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        enabled = requestOptions.enabled, notBefore = requestOptions.notBefore, expires = requestOptions.expiresOn, hsm = requestOptions.hardwareProtected, remainingOptions = tslib.__rest(requestOptions, ["enabled", "notBefore", "expiresOn", "hardwareProtected"]);
                        unflattenedOptions = tslib.__assign(tslib.__assign({}, remainingOptions), { keyAttributes: {
                                enabled: enabled,
                                notBefore: notBefore,
                                expires: expires,
                                hsm: hsm
                            } });
                        span = this.createSpan("importKey", unflattenedOptions);
                        response = void 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.importKey(this.vaultUrl, name, key, this.setParentSpan(span, unflattenedOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                    case 5: return [4 /*yield*/, this.client.importKey(this.vaultUrl, name, key, options)];
                    case 6:
                        response = _a.sent();
                        return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * The delete operation applies to any key stored in Azure Key Vault. Individual versions
     * of a key can not be deleted, only all versions of a given key at once.
     *
     * This function returns a Long Running Operation poller that allows you to wait indifinetly until the key is deleted.
     *
     * This operation requires the keys/delete permission.
     *
     * Example usage:
     * ```ts
     * const client = new KeyClient(url, credentials);
     * await client.createKey("MyKey", "EC");
     * const poller = await client.beginDeleteKey("MyKey");
     *
     * // Serializing the poller
     * const serialized = poller.toString();
     * // A new poller can be created with:
     * // await client.beginDeleteKey("MyKey", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedKey = await poller.pollUntilDone();
     * console.log(deletedKey);
     * ```
     * @summary Deletes a key from a specified key vault.
     * @param {string} name The name of the key.
     * @param {BeginDeleteKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.beginDeleteKey = function (name, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, poller;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        poller = new DeleteKeyPoller({
                            name: name,
                            client: this.pollerClient,
                            intervalInMs: options.intervalInMs,
                            resumeFrom: options.resumeFrom,
                            requestOptions: requestOptions
                        });
                        // This will initialize the poller's operation (the deletion of the key).
                        return [4 /*yield*/, poller.poll()];
                    case 1:
                        // This will initialize the poller's operation (the deletion of the key).
                        _a.sent();
                        return [2 /*return*/, poller];
                }
            });
        });
    };
    /**
     * The updateKeyProperties method changes specified properties of an existing stored key. Properties that
     * are not specified in the request are left unchanged. The value of a key itself cannot be
     * changed. This operation requires the keys/set permission.
     *
     * Example usage:
     * ```ts
     * let keyName = "MyKey";
     * let client = new KeyClient(url, credentials);
     * let key = await client.getKey(keyName);
     * let result = await client.updateKeyProperties(keyName, key.version, { enabled: false });
     * ```
     * @summary Updates the properties associated with a specified key in a given key vault.
     * @param {string} name The name of the key.
     * @param {string} keyVersion The version of the key.
     * @param {UpdateKeyPropertiesOptions} [options] The optional parameters.
     */
    KeyClient.prototype.updateKeyProperties = function (name, keyVersion, options) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, enabled, notBefore, expires, remainingOptions, unflattenedOptions, span, response, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 5];
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        enabled = requestOptions.enabled, notBefore = requestOptions.notBefore, expires = requestOptions.expiresOn, remainingOptions = tslib.__rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                        unflattenedOptions = tslib.__assign(tslib.__assign({}, remainingOptions), { keyAttributes: {
                                enabled: enabled,
                                notBefore: notBefore,
                                expires: expires
                            } });
                        span = this.createSpan("updateKeyProperties", unflattenedOptions);
                        response = void 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.updateKey(this.vaultUrl, name, keyVersion, this.setParentSpan(span, unflattenedOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                    case 5: return [4 /*yield*/, this.client.updateKey(this.vaultUrl, name, keyVersion, options)];
                    case 6:
                        response = _a.sent();
                        return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * The get method gets a specified key and is applicable to any key stored in Azure Key Vault.
     * This operation requires the keys/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let key = await client.getKey("MyKey");
     * ```
     * @summary Get a specified key from a given key vault.
     * @param {string} name The name of the key.
     * @param {GetKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.getKey = function (name, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("getKey", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.getKey(this.vaultUrl, name, options && options.version ? options.version : "", this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * The getDeletedKey method returns the specified deleted key along with its properties.
     * This operation requires the keys/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let key = await client.getDeletedKey("MyDeletedKey");
     * ```
     * @summary Gets the specified deleted key.
     * @param {string} name The name of the key.
     * @param {GetDeletedKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.getDeletedKey = function (name, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var responseOptions, span, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        responseOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("getDeletedKey", responseOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.getDeletedKey(this.vaultUrl, name, this.setParentSpan(span, responseOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * The purge deleted key operation removes the key permanently, without the possibility of
     * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation
     * requires the keys/purge permission.
     *
     * Example usage:
     * ```ts
     * const client = new KeyClient(url, credentials);
     * const deletePoller = await client.beginDeleteKey("MyKey")
     * await deletePoller.pollUntilDone();
     * await client.purgeDeletedKey("MyKey");
     * ```
     * @summary Permanently deletes the specified key.
     * @param name The name of the key.
     * @param {PurgeDeletedKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.purgeDeletedKey = function (name, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var responseOptions, span;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        responseOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("purgeDeletedKey", responseOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.purgeDeletedKey(this.vaultUrl, name, this.setParentSpan(span, responseOptions))];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Recovers the deleted key in the specified vault. This operation can only be performed on a
     * soft-delete enabled vault.
     *
     * This function returns a Long Running Operation poller that allows you to wait indifinetly until the deleted key is recovered.
     *
     * This operation requires the keys/recover permission.
     *
     * Example usage:
     * ```ts
     * const client = new KeyClient(url, credentials);
     * await client.createKey("MyKey", "EC");
     * const deletePoller = await client.beginDeleteKey("MyKey");
     * await deletePoller.pollUntilDone();
     * const poller = await client.beginRecoverDeletedKey("MyKey");
     *
     * // Serializing the poller
     * const serialized = poller.toString();
     * // A new poller can be created with:
     * // await client.beginRecoverDeletedKey("MyKey", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const key = await poller.pollUntilDone();
     * console.log(key);
     * ```
     * @summary Recovers the deleted key to the latest version.
     * @param name The name of the deleted key.
     * @param {BeginRecoverDeletedKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.beginRecoverDeletedKey = function (name, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, poller;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        poller = new RecoverDeletedKeyPoller({
                            name: name,
                            client: this.pollerClient,
                            intervalInMs: options.intervalInMs,
                            resumeFrom: options.resumeFrom,
                            requestOptions: requestOptions
                        });
                        // This will initialize the poller's operation (the deletion of the key).
                        return [4 /*yield*/, poller.poll()];
                    case 1:
                        // This will initialize the poller's operation (the deletion of the key).
                        _a.sent();
                        return [2 /*return*/, poller];
                }
            });
        });
    };
    /**
     * Requests that a backup of the specified key be downloaded to the client. All versions of the
     * key will be downloaded. This operation requires the keys/backup permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let backupContents = await client.backupKey("MyKey");
     * ```
     * @summary Backs up the specified key.
     * @param {string} name The name of the key.
     * @param {BackupKeyOptions} [options] The optional parameters.
     */
    KeyClient.prototype.backupKey = function (name, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("backupKey", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.backupKey(this.vaultUrl, name, this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, response.value];
                }
            });
        });
    };
    /**
     * Restores a backed up key, and all its versions, to a vault. This operation requires the
     * keys/restore permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * let backupContents = await client.backupKey("MyKey");
     * // ...
     * let key = await client.restoreKeyBackup(backupContents);
     * ```
     * @summary Restores a backed up key to a vault.
     * @param {Uint8Array} backup The backup blob associated with a key bundle.
     * @param {RestoreKeyBackupOptions} [options] The optional parameters.
     */
    KeyClient.prototype.restoreKeyBackup = function (backup, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("restoreKeyBackup", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.restoreKey(this.vaultUrl, backup, this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getKeyFromKeyBundle(response)];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listPropertiesOfKeyVersions}.
     * @param {string} name The name of the KeyVault Key.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListPropertiesOfKeyVersionsOptions} [options] Common options for the iterative endpoints.
     */
    KeyClient.prototype.listPropertiesOfKeyVersionsPage = function (name, continuationState, options) {
        return tslib.__asyncGenerator(this, arguments, function listPropertiesOfKeyVersionsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib.__assign({ maxresults: continuationState.maxPageSize }, options);
                        return [4 /*yield*/, tslib.__await(this.client.getKeyVersions(this.vaultUrl, name, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 4];
                        return [4 /*yield*/, tslib.__await(currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 10];
                        return [4 /*yield*/, tslib.__await(this.client.getKeyVersions(continuationState.continuationToken, name, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib.__await(currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 8: return [3 /*break*/, 10];
                    case 9: return [3 /*break*/, 4];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listPropertiesOfKeyVersions}.
     * @param {string} name The name of the KeyVault Key.
     * @param {ListPropertiesOfKeyVersionsOptions} [options] Common options for the iterative endpoints.
     */
    KeyClient.prototype.listPropertiesOfKeyVersionsAll = function (name, options) {
        return tslib.__asyncGenerator(this, arguments, function listPropertiesOfKeyVersionsAll_1() {
            var f, _a, _b, page, _i, page_1, item, e_1_1;
            var e_1, _c;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib.__asyncValues(this.listPropertiesOfKeyVersionsPage(name, f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_1 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_1.length)) return [3 /*break*/, 8];
                        item = page_1[_i];
                        return [4 /*yield*/, tslib.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates all versions of the given key in the vault. The full key identifier, properties, and tags are provided
     * in the response. This operation requires the keys/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * for await (const keyProperties of client.listPropertiesOfKeyVersions("MyKey")) {
     *   const key = await client.getKey(keyProperties.name);
     *   console.log("key version: ", key);
     * }
     * ```
     * @param {string} name Name of the key to fetch versions for
     * @param {ListPropertiesOfKeyVersionsOptions} [options] The optional parameters.
     */
    KeyClient.prototype.listPropertiesOfKeyVersions = function (name, options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
        var span = this.createSpan("listPropertiesOfKeyVersions", requestOptions);
        var updatedOptions = tslib.__assign(tslib.__assign({}, requestOptions), this.setParentSpan(span, requestOptions));
        var iter = this.listPropertiesOfKeyVersionsAll(name, updatedOptions);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listPropertiesOfKeyVersionsPage(name, settings, updatedOptions);
            },
            _a;
    };
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listPropertiesOfKeys}.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListPropertiesOfKeysOptions} [options] Common options for the iterative endpoints.
     */
    KeyClient.prototype.listPropertiesOfKeysPage = function (continuationState, options) {
        return tslib.__asyncGenerator(this, arguments, function listPropertiesOfKeysPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib.__assign({ maxresults: continuationState.maxPageSize }, options);
                        return [4 /*yield*/, tslib.__await(this.client.getKeys(this.vaultUrl, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 4];
                        return [4 /*yield*/, tslib.__await(currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 10];
                        return [4 /*yield*/, tslib.__await(this.client.getKeys(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib.__await(currentSetResponse.value.map(this.getKeyPropertiesFromKeyItem))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 8: return [3 /*break*/, 10];
                    case 9: return [3 /*break*/, 4];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listPropertiesOfKeys}.
     * @param {ListPropertiesOfKeysOptions} [options] Common options for the iterative endpoints.
     */
    KeyClient.prototype.listPropertiesOfKeysAll = function (options) {
        return tslib.__asyncGenerator(this, arguments, function listPropertiesOfKeysAll_1() {
            var f, _a, _b, page, _i, page_2, item, e_2_1;
            var e_2, _c;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib.__asyncValues(this.listPropertiesOfKeysPage(f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_2 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_2.length)) return [3 /*break*/, 8];
                        item = page_2[_i];
                        return [4 /*yield*/, tslib.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_2_1 = _d.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_2) throw e_2.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates the latest version of all keys in the vault.  The full key identifier and properties are provided
     * in the response. No values are returned for the keys. This operations requires the keys/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * for await (const keyProperties of client.listPropertiesOfKeys()) {
     *   const key = await client.getKey(keyProperties.name);
     *   console.log("key: ", key);
     * }
     * ```
     * @summary List all keys in the vault
     * @param {ListPropertiesOfKeysOptions} [options] The optional parameters.
     */
    KeyClient.prototype.listPropertiesOfKeys = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
        var span = this.createSpan("listPropertiesOfKeys", requestOptions);
        var updatedOptions = tslib.__assign(tslib.__assign({}, requestOptions), this.setParentSpan(span, requestOptions));
        var iter = this.listPropertiesOfKeysAll(updatedOptions);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listPropertiesOfKeysPage(settings, updatedOptions);
            },
            _a;
    };
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listDeletedKeys}.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListDeletedKeysOptions} [options] Common options for the iterative endpoints.
     */
    KeyClient.prototype.listDeletedKeysPage = function (continuationState, options) {
        return tslib.__asyncGenerator(this, arguments, function listDeletedKeysPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib.__assign({ maxresults: continuationState.maxPageSize }, options);
                        return [4 /*yield*/, tslib.__await(this.client.getDeletedKeys(this.vaultUrl, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 4];
                        return [4 /*yield*/, tslib.__await(currentSetResponse.value.map(this.getDeletedKeyFromKeyItem))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 10];
                        return [4 /*yield*/, tslib.__await(this.client.getDeletedKeys(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib.__await(currentSetResponse.value.map(this.getDeletedKeyFromKeyItem))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 8: return [3 /*break*/, 10];
                    case 9: return [3 /*break*/, 4];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listDeletedKeys}.
     * @param {ListDeletedKeysOptions} [options] Common options for the iterative endpoints.
     */
    KeyClient.prototype.listDeletedKeysAll = function (options) {
        return tslib.__asyncGenerator(this, arguments, function listDeletedKeysAll_1() {
            var f, _a, _b, page, _i, page_3, item, e_3_1;
            var e_3, _c;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib.__asyncValues(this.listDeletedKeysPage(f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_3 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_3.length)) return [3 /*break*/, 8];
                        item = page_3[_i];
                        return [4 /*yield*/, tslib.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_3_1 = _d.sent();
                        e_3 = { error: e_3_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_3) throw e_3.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates the deleted keys in the vault.  The full key identifier and properties are provided
     * in the response. No values are returned for the keys. This operations requires the keys/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new KeyClient(url, credentials);
     * for await (const deletedKey of client.listDeletedKeys()) {
     *   const deletedKey = await client.getKey(deletedKey.name);
     *   console.log("deleted key: ", deletedKey);
     * }
     * ```
     * @summary List all keys in the vault
     * @param {ListDeletedKeysOptions} [options] The optional parameters.
     */
    KeyClient.prototype.listDeletedKeys = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
        var span = this.createSpan("listDeletedKeys", requestOptions);
        var updatedOptions = tslib.__assign(tslib.__assign({}, options), this.setParentSpan(span, requestOptions));
        var iter = this.listDeletedKeysAll(updatedOptions);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listDeletedKeysPage(settings, updatedOptions);
            },
            _a;
    };
    /**
     * @internal
     * @ignore
     * Shapes the exposed {@link KeyVaultKey} based on either a received key bundle or deleted key bundle.
     */
    KeyClient.prototype.getKeyFromKeyBundle = function (bundle) {
        var keyBundle = bundle;
        var deletedKeyBundle = bundle;
        var parsedId = parseKeyvaultIdentifier("keys", keyBundle.key ? keyBundle.key.kid : undefined);
        var attributes = keyBundle.attributes || {};
        delete keyBundle.attributes;
        var resultObject = {
            key: keyBundle.key,
            id: keyBundle.key ? keyBundle.key.kid : undefined,
            name: parsedId.name,
            keyOperations: keyBundle.key ? keyBundle.key.keyOps : undefined,
            keyType: keyBundle.key ? keyBundle.key.kty : undefined,
            properties: tslib.__assign(tslib.__assign(tslib.__assign({ id: keyBundle.key ? keyBundle.key.kid : undefined, name: parsedId.name, expiresOn: attributes.expires, createdOn: attributes.created, updatedOn: attributes.updated, vaultUrl: parsedId.vaultUrl }, keyBundle), parsedId), attributes)
        };
        if (deletedKeyBundle.deletedDate) {
            resultObject.properties.deletedOn = deletedKeyBundle.deletedDate;
            delete resultObject.properties.deletedDate;
        }
        if (attributes.vaultUrl) {
            delete resultObject.properties.vaultUrl;
        }
        if (attributes.expires) {
            delete resultObject.properties.expires;
        }
        if (attributes.created) {
            delete resultObject.properties.created;
        }
        if (attributes.updated) {
            delete resultObject.properties.updated;
        }
        return resultObject;
    };
    /**
     * @internal
     * @ignore
     * Shapes the exposed {@link DeletedKey} based on a received KeyItem.
     */
    KeyClient.prototype.getDeletedKeyFromKeyItem = function (keyItem) {
        var parsedId = parseKeyvaultIdentifier("keys", keyItem.kid);
        var attributes = keyItem.attributes || {};
        var abstractProperties = tslib.__assign(tslib.__assign(tslib.__assign({ id: keyItem.kid, name: parsedId.name, deletedOn: attributes.deletedDate, expiresOn: attributes.expires, createdOn: attributes.created, updatedOn: attributes.updated }, keyItem), parsedId), keyItem.attributes);
        if (abstractProperties.deletedDate) {
            delete abstractProperties.deletedDate;
        }
        if (abstractProperties.expires) {
            delete abstractProperties.expires;
        }
        if (abstractProperties.created) {
            delete abstractProperties.created;
        }
        if (abstractProperties.updated) {
            delete abstractProperties.updated;
        }
        return {
            key: keyItem,
            id: keyItem.kid,
            name: abstractProperties.name,
            properties: abstractProperties
        };
    };
    /**
     * @internal
     * @ignore
     * Shapes the exposed {@link KeyProperties} based on a received KeyItem.
     */
    KeyClient.prototype.getKeyPropertiesFromKeyItem = function (keyItem) {
        var parsedId = parseKeyvaultIdentifier("keys", keyItem.kid);
        var attributes = keyItem.attributes || {};
        var resultObject = tslib.__assign(tslib.__assign(tslib.__assign({ createdOn: attributes.created, updatedOn: attributes.updated, vaultUrl: parsedId.vaultUrl }, keyItem), parsedId), keyItem.attributes);
        delete resultObject.attributes;
        if (keyItem.attributes.expires) {
            resultObject.expiresOn = keyItem.attributes.expires;
            delete resultObject.expires;
        }
        return resultObject;
    };
    /**
     * @internal
     * @ignore
     * Creates a span using the tracer that was set by the user.
     * @param {string} methodName The name of the method creating the span.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    KeyClient.prototype.createSpan = function (methodName, requestOptions) {
        var tracer = coreTracing.getTracer();
        return tracer.startSpan(methodName, requestOptions && requestOptions.spanOptions);
    };
    /**
     * @internal
     * @ignore
     * Returns updated HTTP options with the given span as the parent of future spans,
     * if applicable.
     * @param {Span} span The span for the current operation.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    KeyClient.prototype.setParentSpan = function (span, options) {
        if (options === void 0) { options = {}; }
        if (span.isRecordingEvents()) {
            return tslib.__assign(tslib.__assign({}, options), { spanOptions: tslib.__assign(tslib.__assign({}, options.spanOptions), { parent: span }) });
        }
        else {
            return options;
        }
    };
    return KeyClient;
}());

exports.CryptographyClient = CryptographyClient;
exports.KeyClient = KeyClient;
exports.logger = logger;
//# sourceMappingURL=index.js.map
